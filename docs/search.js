window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "src.fairreckitlib", "modulename": "src.fairreckitlib", "type": "module", "doc": "<p>This package contains the FairRecKit recommender system API.</p>\n\n<p>Modules:</p>\n\n<pre><code>recommender_system: the top level API intended for use by applications.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>core: base functionality that is used in the other packages.\ndata: data(set) functionality with a data registry and a data pipeline.\nevaluation: rating result performance evaluation computations as a pipeline.\nexperiment: combined computations of the data, model and evaluation pipelines.\nmodel: algorithmic rating result computations as a model pipeline.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core", "modulename": "src.fairreckitlib.core", "type": "module", "doc": "<p>This package contains core functionality to be used in other packages.</p>\n\n<p>Modules:</p>\n\n<pre><code>core_constants: core constants that are used in other packages.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>config: classes that are used for yml (object) configuration.\nevents: event dispatching/listening behaviour.\nio: various functions for commonly used IO operations.\nparsing: base functionality for parsing configuration files.\npipeline: base class functionality for a pipeline.\nthreading: base class thread and processing threads.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config", "modulename": "src.fairreckitlib.core.config", "type": "module", "doc": "<p>This package contains functionality for yml (object) configuration.</p>\n\n<p>Modules:</p>\n\n<pre><code>config_base_param: base configuration param classes.\nconfig_factories: (base) factory classes that are structured tree-like.\nconfig_object: base functionality for an object's name and parameters configuration.\nconfig_option_param: configuration option param implementations.\nconfig_parameters: configuration parameters container.\nconfig_value_param: configuration value param implementations.\nconfig_yml: base yml configuration class.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_base_param", "modulename": "src.fairreckitlib.core.config.config_base_param", "type": "module", "doc": "<p>This module contains functionality for base configuration parameters.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConfigParam: base class for all parameters.\nConfigOptionParam: (base) parameter that can be a value from a known list of options.\nConfigValueParam: (base) parameter that can be a value between a minimum and maximum.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigParam", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigParam", "type": "class", "doc": "<p>Config Param base class.</p>\n\n<p>Public methods:</p>\n\n<p>to_dict\nvalidate_value</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigParam.__init__", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigParam.__init__", "type": "function", "doc": "<p>Construct the ConfigParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default value of the parameter.</p>\n", "signature": "(self, name: str, value_type: Type, default_value: Any)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigParam.to_dict", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigParam.to_dict", "type": "function", "doc": "<p>Get a dictionary describing the parameter.</p>\n\n<p>The dictionary should at least contains keys for the name\nand default value of the parameter.</p>\n\n<p>Returns:\n    the dictionary containing the parameter descriptions.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Derived implementations should at least check for type mismatch and None.</p>\n\n<p>Args:\n    value: the value to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Any, str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigOptionParam", "type": "class", "doc": "<p>Config Option Parameter.</p>\n\n<p>The default_value and all the options are expected to be of the same value_type.\nThe default_value is expected to be present in the list of available options.</p>\n", "bases": "ConfigParam"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam.__init__", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigOptionParam.__init__", "type": "function", "doc": "<p>Construct the ConfigOptionParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default option of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Any,\n    options: List[Any]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam.to_dict", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigOptionParam.to_dict", "type": "function", "doc": "<p>Get a dictionary describing the option parameter.</p>\n\n<p>The dictionary contains keys for the name, default value\nand options of the parameter.</p>\n\n<p>Returns:\n    the dictionary containing the parameter descriptions.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigValueParam", "type": "class", "doc": "<p>Config Value Parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default_value is expected to be between the min_max_value.\nThe min_max_value is expected to have min_value &lt;= max_value.</p>\n", "bases": "ConfigParam"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam.__init__", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigValueParam.__init__", "type": "function", "doc": "<p>Construct the ConfigValueParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Any,\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam.to_dict", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigValueParam.to_dict", "type": "function", "doc": "<p>Get a dictionary describing the value parameter.</p>\n\n<p>The dictionary contains keys for the name, default value,\nminimum value and maximum value of the parameter.</p>\n\n<p>Returns:\n    the dictionary containing the parameter descriptions.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories", "modulename": "src.fairreckitlib.core.config.config_factories", "type": "module", "doc": "<p>This module contains the (base) factories that are used in other packages.</p>\n\n<p>Classes:</p>\n\n<pre><code>BaseFactory: base class for all factories.\nFactory: class that instantiates new objects (a leaf).\nGroupFactory: class that groups other factories (a branch).\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_factory_from_list: create object factory from list of object (param) creation tuples.\nresolve_factory: resolve the object factory from the name of the object.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory", "type": "class", "doc": "<p>Base class for all FairRecKit experiment factories.</p>\n\n<p>The abstraction is intended to support functionality for a tree-like structure.\nThe actual factory is a leaf and a group of factories that belong together a branch.</p>\n\n<p>Public methods:</p>\n\n<p>get_available\nget_available_names\nget_name\nis_available</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.__init__", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.__init__", "type": "function", "doc": "<p>Construct the base factory.</p>\n\n<p>Args:\n    factory_name: the name of the factory.</p>\n", "signature": "(self, factory_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.get_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.get_available", "type": "function", "doc": "<p>Get the available objects in the factory.</p>\n\n<p>The availability return type depends on the derived class.</p>\n", "signature": "(self) -> Any", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.get_available_names", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.get_available_names", "type": "function", "doc": "<p>Get the names that are available in the factory.</p>\n\n<p>Returns:\n    a list of names that is available.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.get_name", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.get_name", "type": "function", "doc": "<p>Get the name of the factory.</p>\n\n<p>Returns:\n    the factory name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.get_num_entries", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.get_num_entries", "type": "function", "doc": "<p>Get the number of entries present in the factory.</p>\n\n<p>Returns:\n    the amount of entries.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.is_obj_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.is_obj_available", "type": "function", "doc": "<p>Is the object with the specified name available.</p>\n\n<p>Args:\n    obj_name: the name of the object to query for availability.</p>\n\n<p>Returns:\n    whether the object is available.</p>\n", "signature": "(self, obj_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory", "type": "class", "doc": "<p>The factory that implements object and parameters creation.</p>\n\n<p>Public methods:</p>\n\n<p>add_obj\ncreate\ncreate_params</p>\n", "bases": "BaseFactory"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.add_obj", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.add_obj", "type": "function", "doc": "<p>Add object with associated parameter creation to the factory.</p>\n\n<p>Parameter creation is optional and should be None if the object has no parameters.</p>\n\n<p>Args:\n    obj_name: the name of the object\n    func_create_obj: the function that creates and returns a new object.\n    func_create_obj_params: the function that creates and returns the parameters\n        that are associated with a newly created object or None when the object\n        has no parameters.</p>\n\n<p>Raises:\n    KeyError: when the object name is already present in the factory.</p>\n", "signature": "(\n    self,\n    obj_name: str,\n    func_create_obj: Callable[[str, Dict[str, Any]], Any],\n    func_create_obj_params: Optional[Callable[[], src.fairreckitlib.core.config.config_parameters.ConfigParameters]] = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.create", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.create", "type": "function", "doc": "<p>Create and return a new object with the specified name.</p>\n\n<p>The specified parameters are expected to be of the same structure as the defaults\nof the ConfigParameters that are associated with the desired object. When no parameters\nare specified it will use the object's defaults.</p>\n\n<p>Args:\n    obj_name: the name of the object to create.\n    obj_params: the parameters of the object.</p>\n\n<p>Keyword Args:\n    Any: extra arguments that need to be passed to the object on creation.</p>\n\n<p>Returns:\n    the created object or None when it does not exist.</p>\n", "signature": "(self, obj_name: str, obj_params: Dict[str, Any] = None, **kwargs) -> Any", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.create_params", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.create_params", "type": "function", "doc": "<p>Create parameters for the object with the specified name.</p>\n\n<p>Args:\n    obj_name: name of the object to create parameters for.</p>\n\n<p>Returns:\n    the configuration parameters of the object or empty parameters when it does not exist.</p>\n", "signature": "(\n    self,\n    obj_name: str\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.on_create_params", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.on_create_params", "type": "function", "doc": "<p>Create parameters for the object with the specified name.</p>\n\n<p>Args:\n    obj_name: name of the object to create parameters for.</p>\n\n<p>Returns:\n    the configuration parameters of the object or empty parameters when it does not exist.</p>\n", "signature": "(\n    self,\n    obj_name: str\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.get_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.get_available", "type": "function", "doc": "<p>Get the availability of all object names and their parameters.</p>\n\n<p>Each object in the factory has a name and parameters that consists of\na dictionary with name-value pairs.</p>\n\n<p>Returns:\n    a list of dictionary entries that includes the name and the parameters.</p>\n", "signature": "(self) -> List[Dict[str, Dict[str, Any]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.is_obj_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.is_obj_available", "type": "function", "doc": "<p>Is the object with the specified name available.</p>\n\n<p>Checks the object for existing in this factory.</p>\n\n<p>Args:\n    obj_name: the name of the object to query for availability.</p>\n\n<p>Returns:\n    whether the object is available.</p>\n", "signature": "(self, obj_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory", "type": "class", "doc": "<p>The factory that groups other factories together.</p>\n\n<p>Public methods:</p>\n\n<p>add_factory\nget_factory\nget_sub_availability</p>\n", "bases": "BaseFactory"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.add_factory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.add_factory", "type": "function", "doc": "<p>Add the specified factory to the group.</p>\n\n<p>The name of the factory is used as the key.</p>\n\n<p>Args:\n    factory: to add to the group.</p>\n\n<p>Raises:\n    KeyError: when the name of the factory already exists in the group.</p>\n", "signature": "(\n    self,\n    factory: src.fairreckitlib.core.config.config_factories.BaseFactory\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.get_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.get_available", "type": "function", "doc": "<p>Get the availability of all factories in the group.</p>\n\n<p>Each factory has a name and availability that depends on the\ntype of the factory. Effectively this will generate a tree-like\nstructure of the factory's availability.</p>\n\n<p>Returns:\n    a dictionary with factory name and availability pairs.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.get_factory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.get_factory", "type": "function", "doc": "<p>Get the factory with the specified name.</p>\n\n<p>Args:\n    factory_name: the name of the factory to retrieve</p>\n\n<p>Returns:\n    the requested factory or None when not available.</p>\n", "signature": "(\n    self,\n    factory_name: str\n) -> src.fairreckitlib.core.config.config_factories.BaseFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.get_sub_availability", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.get_sub_availability", "type": "function", "doc": "<p>Get the sub availability from the factory with the specified name (and type).</p>\n\n<p>Args:\n    sub_factory_name: the name of the sub-factory to query for availability.\n    sub_type: the subtype of the sub-factory to query for availability or None\n        for the complete availability.</p>\n\n<p>Returns:\n    a dictionary containing the availability of the sub-factory (type).</p>\n", "signature": "(self, sub_factory_name: str, sub_type: str = None) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.is_obj_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.is_obj_available", "type": "function", "doc": "<p>Is the object with the specified name available.</p>\n\n<p>Checks the object for existing in any of the child factories.</p>\n\n<p>Args:\n    obj_name: the name of the object to query for availability.</p>\n\n<p>Returns:\n    whether the object is available.</p>\n", "signature": "(self, obj_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.create_factory_from_list", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "create_factory_from_list", "type": "function", "doc": "<p>Create and return the factory with the specified tuple entries.</p>\n\n<p>Each tuple in the list consists of three things; the name of the object,\nthe object creation function and the parameter creation function.</p>\n\n<p>Args:\n    factory_name: the name of the factory to create.\n    obj_tuple_list: a list of object tuples to add after factory creation.</p>\n\n<p>Returns:\n    the factory with the added objects.</p>\n", "signature": "(\n    factory_name: str,\n    obj_tuple_list: List[Tuple[str, Callable[[str, Dict[str, Any]], Any], Optional[Callable[[], src.fairreckitlib.core.config.config_parameters.ConfigParameters]]]]\n) -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.resolve_factory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "resolve_factory", "type": "function", "doc": "<p>Resolve the object factory from the name of the object.</p>\n\n<p>Args:\n    obj_name: the name of the object.\n    obj_factory: the (group) factory to query for the object.</p>\n\n<p>Returns:\n    the resolved factory or None when not found.</p>\n", "signature": "(\n    obj_name: str,\n    obj_factory: Union[src.fairreckitlib.core.config.config_factories.Factory, src.fairreckitlib.core.config.config_factories.GroupFactory]\n) -> Optional[src.fairreckitlib.core.config.config_factories.Factory]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_object", "modulename": "src.fairreckitlib.core.config.config_object", "type": "module", "doc": "<p>This module contains the base functionality for an object's configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>ObjectConfig: base class configuration for an object with a name and parameters.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>object_config_list_to_yml_format: convert list of ObjectConfig's to a yml format.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_object.ObjectConfig", "modulename": "src.fairreckitlib.core.config.config_object", "qualname": "ObjectConfig", "type": "class", "doc": "<p>Base Object Configuration.</p>\n\n<p>name: the name of the object.\nparams: the parameters of the object.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.core.config.config_object.ObjectConfig.__init__", "modulename": "src.fairreckitlib.core.config.config_object", "qualname": "ObjectConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_object.ObjectConfig.to_yml_format", "modulename": "src.fairreckitlib.core.config.config_object", "qualname": "ObjectConfig.to_yml_format", "type": "function", "doc": "<p>Format object configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the object configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param", "modulename": "src.fairreckitlib.core.config.config_option_param", "type": "module", "doc": "<p>This module contains functionality for configuration option parameters.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConfigSingleOptionParam: parameter that can be a single value from a known list of options.\nConfigMultiOptionParam: parameter that can be multiple values from a known list of options.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_bool_param: create boolean option parameter.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigMultiOptionParam", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigMultiOptionParam", "type": "class", "doc": "<p>Config Multi Option Parameter.</p>\n\n<p>The default_value and all the options are expected to be strings or None.\nThe default_value list is expected to have at least one entry.\nThe default_value list is expected to be present in the list of available options.</p>\n", "bases": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigMultiOptionParam.__init__", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigMultiOptionParam.__init__", "type": "function", "doc": "<p>Construct the ConfigMultiOptionParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    default_value: the default option(s) of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(self, name: str, default_value: List[str], options: List[str])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigMultiOptionParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigMultiOptionParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks for None, type mismatch, duplicates and if the value is one of the allowed options.</p>\n\n<p>Args:\n    value: the list of options to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, List[str], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigSingleOptionParam", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigSingleOptionParam", "type": "class", "doc": "<p>Config Single Option Parameter.</p>\n\n<p>The default_value and all the options are expected to be either strings or booleans.\nThe default_value is expected to be present in the list of available options.\nThe options list is expected to have unique values.</p>\n", "bases": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigSingleOptionParam.__init__", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigSingleOptionParam.__init__", "type": "function", "doc": "<p>Construct the ConfigOptionParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default option of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[str, bool],\n    options: Union[List[str], List[bool]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigSingleOptionParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigSingleOptionParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks for None, type mismatch and if the value is one of the allowed options.</p>\n\n<p>Args:\n    value: the option to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Union[str, bool], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.create_bool_param", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "create_bool_param", "type": "function", "doc": "<p>Create a boolean option parameter.</p>\n\n<p>Args:\n    name: the name of the boolean parameter.\n    default_value: the default boolean value.</p>\n\n<p>Returns:\n    the boolean parameter.</p>\n", "signature": "(\n    name: str,\n    default_value: bool\n) -> src.fairreckitlib.core.config.config_option_param.ConfigSingleOptionParam", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters", "modulename": "src.fairreckitlib.core.config.config_parameters", "type": "module", "doc": "<p>This module contains a container of configuration parameters.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConfigParameters: container that stores multiple ConfigParam's.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_empty_parameters: create parameters with no entries.\ncreate_params_random_seed: create configuration with only a random seed parameter.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters", "type": "class", "doc": "<p>Config Parameters.</p>\n\n<p>Container with varying Config parameters using a dictionary.\nMoreover, he added option/value parameters are stored separately.</p>\n\n<p>Public methods:</p>\n\n<p>add_bool\nadd_multi_option\nadd_single_option\nadd_number\nadd_random_seed\nadd_range\nget_defaults\nget_num_params\nget_param\nget_param_names\nto_dict</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.__init__", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.__init__", "type": "function", "doc": "<p>Construct the ConfigParameters.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_bool", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_bool", "type": "function", "doc": "<p>Add a boolean parameter.</p>\n\n<p>Sugar for an option parameter that is either True or False.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n      name: name of the boolean parameter.\n      default_value: the default boolean value.</p>\n", "signature": "(self, name: str, default_value: bool) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_multi_option", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_multi_option", "type": "function", "doc": "<p>Add a multi option parameter.</p>\n\n<p>The default_value and all the options are expected to be strings or None.\nThe default_value list is expected to have at least one entry.\nThe default_value list is expected to be present in the list of available options.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    default_value: the default option(s) of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(self, name: str, default_value: List[str], options: List[str]) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_single_option", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_single_option", "type": "function", "doc": "<p>Add a single option parameter.</p>\n\n<p>The default_value and all the options are expected to be strings.\nThe default_value is expected to be present in the list of available options.\nThe options list is expected to have unique values.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type:  the type of the parameter.\n    default_option: default option of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_option: str,\n    options: List[str]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_number", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_number", "type": "function", "doc": "<p>Add a number parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default value is expected to be between the min_max_value.\nThe min_max_value is expected to have min_value &lt;= max_value.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[int, float],\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_random_seed", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_random_seed", "type": "function", "doc": "<p>Add a random seed parameter.</p>\n\n<p>An integer number parameter, where the default_value is None.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the random seed parameter.</p>\n", "signature": "(self, name: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_range", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_range", "type": "function", "doc": "<p>Add a range parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default_value min and max values are expected to be between the min_max_value.\nThe default_value and min_max_value are expected to have min_value &lt;= max_value.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: tuple with the default minimum and maximum value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[Tuple[int, int], Tuple[float, float]],\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.get_defaults", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.get_defaults", "type": "function", "doc": "<p>Get the default values from all parameters.</p>\n\n<p>Returns:\n    a dictionary containing name-default pairs for all parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.get_num_params", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.get_num_params", "type": "function", "doc": "<p>Get the number of parameters.</p>\n\n<p>Returns:\n    the parameter count.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.get_param", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.get_param", "type": "function", "doc": "<p>Get the parameter with the specified name.</p>\n\n<p>Returns:\n     the parameter on success or None on failure.</p>\n", "signature": "(\n    self,\n    param_name: str\n) -> Optional[src.fairreckitlib.core.config.config_base_param.ConfigParam]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.get_param_names", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.get_param_names", "type": "function", "doc": "<p>Get the names of all parameters.</p>\n\n<p>Returns:\n    a list of all parameter names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.to_dict", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.to_dict", "type": "function", "doc": "<p>Get a dictionary describing all the parameters.</p>\n\n<p>The parameters in the dictionary are stored separately:\n    PARAM_KEY_OPTIONS: list of all option parameter descriptions.\n    PARAM_KEY_VALUES: list of all value parameter descriptions.</p>\n\n<p>Returns:\n    a dictionary containing the parameters' descriptions.</p>\n", "signature": "(self) -> Dict[str, List[Dict[str, Any]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_param", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_param", "type": "function", "doc": "<p>Add a parameter to the internal dictionary.</p>\n\n<p>This function is only used internally by the parameters,\nuse the other add functions instead.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    param: the parameter to add.</p>\n", "signature": "(\n    self,\n    param: src.fairreckitlib.core.config.config_base_param.ConfigParam\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.create_empty_parameters", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "create_empty_parameters", "type": "function", "doc": "<p>Create the Config parameters with no entries.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.create_params_random_seed", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "create_params_random_seed", "type": "function", "doc": "<p>Create the configuration with only the random 'seed' parameter.</p>\n\n<p>Returns:\n    the configuration parameters with one parameter: 'seed'.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param", "modulename": "src.fairreckitlib.core.config.config_value_param", "type": "module", "doc": "<p>This module contains functionality for configuration value parameters.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConfigNumberParam: parameter that can be a number between a minimum and maximum.\nConfigRandomParam: parameter that can be used to pick the (optional) random seed.\nConfigRangeParam: parameter that can be a range between a minimum and maximum.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>validate_min_max:\nvalidate_type:\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigNumberParam", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigNumberParam", "type": "class", "doc": "<p>Config Number Parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default_value is expected to be between the min_max_value.\nThe min_max_value is expected to have min_value &lt;= max_value.</p>\n", "bases": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigNumberParam.__init__", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigNumberParam.__init__", "type": "function", "doc": "<p>Construct the ConfigNumberParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[int, float],\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigNumberParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigNumberParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks for None, type mismatch (conversion between int and float is allowed) and if\nthe value is between the minimum and maximum value of the parameter.</p>\n\n<p>Args:\n    value: the number to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Union[int, float], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRandomParam", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRandomParam", "type": "class", "doc": "<p>Config Random Parameter.</p>\n", "bases": "ConfigNumberParam"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRandomParam.__init__", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRandomParam.__init__", "type": "function", "doc": "<p>Construct the ConfigRandomParam.</p>\n\n<p>Args:\n    name: the name of the random seed parameter.</p>\n", "signature": "(self, name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRandomParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRandomParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks are the same as ConfigNumberParam.validate_value, but None is allowed.</p>\n\n<p>Args:\n    value: the random seed to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Optional[int], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRangeParam", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRangeParam", "type": "class", "doc": "<p>Config Range Parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default_value min and max values are expected to be between the min_max_value.\nThe default_value and min_max_value are expected to have min_value &lt;= max_value.</p>\n", "bases": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRangeParam.__init__", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRangeParam.__init__", "type": "function", "doc": "<p>Construct the ConfigRangeParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: tuple with the default minimum and maximum value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[Tuple[int, int], Tuple[float, float]],\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRangeParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRangeParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks for None, type mismatch (conversion between int and float is allowed) and if\nthe min-max range is between the minimum and maximum value of the parameter.</p>\n\n<p>Args:\n    value: the min-max range dictionary to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Dict[str, Union[int, float]], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRangeParam.validate_dict", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRangeParam.validate_dict", "type": "function", "doc": "<p>Validate the specified value to a min-max range dictionary.</p>\n\n<p>Args:\n    value: the min-max range dictionary to validate.</p>\n\n<p>Returns:\n    whether it was successful, the validated dictionary and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Dict[str, Any], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.validate_min_max", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "validate_min_max", "type": "function", "doc": "<p>Validate the value with the specified min- and max-value.</p>\n\n<p>Args:\n    value_name: the name associated with the value.\n    value: the value to validate.\n    min_value: the minimum value to use for validation.\n    max_value: the maximum value to use for validation.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(\n    value_name: str,\n    value: Union[int, float],\n    min_value: Union[int, float],\n    max_value: Union[int, float]\n) -> Tuple[bool, Union[int, float], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.validate_type", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "validate_type", "type": "function", "doc": "<p>Validate the value to be of the correct type.</p>\n\n<p>Conversion between int/float is allowed and will return True, but\nwith the optional message that the value was cast to the correct value_type.</p>\n\n<p>Args:\n    value_name: the name associated with the value.\n    value: the value to validate the type of.\n    value_type: the type of the value.\n    default_value: the default value to return on invalidation.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(\n    value_name: str,\n    value: Any,\n    value_type: Type,\n    default_value: Union[int, float]\n) -> Tuple[bool, Union[int, float], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_yml", "modulename": "src.fairreckitlib.core.config.config_yml", "type": "module", "doc": "<p>This module contains the base functionality for an object's configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>YmlConfig: base class configuration that is compatible with an yml format.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>format_yml_config_dict: convert dict of YmlConfig's to an yml format.\nformat_yml_config_dict_list: convert dict with list of YmlConfig's to an yml format.\nformat_yml_config_list: convert list of YmlConfig's to an yml format.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_yml.YmlConfig", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "YmlConfig", "type": "class", "doc": "<p>Base YML Configuration.</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_yml.YmlConfig.to_yml_format", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "YmlConfig.to_yml_format", "type": "function", "doc": "<p>Format configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_yml.format_yml_config_dict", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "format_yml_config_dict", "type": "function", "doc": "<p>Format yml configuration dictionary.</p>\n\n<p>Returns:\n    a list containing the yml configuration's.</p>\n", "signature": "(\n    yml_configs: Dict[str, src.fairreckitlib.core.config.config_yml.YmlConfig]\n) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_yml.format_yml_config_dict_list", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "format_yml_config_dict_list", "type": "function", "doc": "<p>Format yml configuration dictionary with list values.</p>\n\n<p>Returns:\n    a dictionary containing the lists of yml configurations.</p>\n", "signature": "(\n    yml_config_lists: Dict[str, List[src.fairreckitlib.core.config.config_yml.YmlConfig]]\n) -> Dict[str, List[Dict[str, Any]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_yml.format_yml_config_list", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "format_yml_config_list", "type": "function", "doc": "<p>Format yml configuration list to a yml compatible list.</p>\n\n<p>Returns:\n    a list containing the yml configuration's.</p>\n", "signature": "(\n    yml_configs: List[src.fairreckitlib.core.config.config_yml.YmlConfig]\n) -> List[Dict[str, Any]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.core_constants", "modulename": "src.fairreckitlib.core.core_constants", "type": "module", "doc": "<p>This module contains configuration constants that are used in other packages.</p>\n\n<p>Constants:</p>\n\n<pre><code>ELLIOT_API: name of the Elliot API.\nIMPLICIT_API: name of the Implicit API.\nLENSKIT_API: name of the LensKit API.\nREXMEX_API: name of the Rexmex API.\nSURPRISE_API: name of the Surprise API.\n\nKEY_NAME: the key that is used for a name.\nKEY_PARAMS: the key that is used for params.\nKEY_RANDOM_SEED: the key that is used for a random seed param.\nKEY_TYPE: the key that is used for types.\n\nTYPE_PREDICTION: the prediction experiment type.\nTYPE_RECOMMENDATION: the recommender experiment type.\n\nVALID_TYPES: the valid experiment types.\n\nKEY_TOP_K: the key that is used for top k.\nKEY_RATED_ITEMS_FILTER: the key that is used for the rated items filter.\n\nDEFAULT_TOP_K: the default top k for recommender experiments.\nDEFAULT_RATED_ITEMS_FILTER: the default rated items filter for recommender experiments.\n\nMIN_TOP_K: the minimum top k for recommender experiments.\nMAX_TOP_K: the maximum top k for recommender experiments.\n\nMODEL_USER_BATCH_SIZE: the batch size of users that is used when model computations are done.\nMODEL_RATINGS_FILE: the file that is used to store the computed model ratings.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events", "modulename": "src.fairreckitlib.core.events", "type": "module", "doc": "<p>This package contains functionality for event dispatching/listening behaviour.</p>\n\n<p>Modules:</p>\n\n<pre><code>event_args: (base) class for event arguments.\nevent_dispatcher: class that can dispatch events to listeners.\nevent_error: event ids, event args and a print switch that are error related.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_args", "modulename": "src.fairreckitlib.core.events.event_args", "type": "module", "doc": "<p>This module contains the base event arguments dataclasses.</p>\n\n<p>Classes:</p>\n\n<pre><code>EventArgs: base event args for all events.\nMessageEventArgs: event args that has a message.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_args.EventArgs", "modulename": "src.fairreckitlib.core.events.event_args", "qualname": "EventArgs", "type": "class", "doc": "<p>Base Event Arguments.</p>\n\n<p>Event arguments classes are allowed to be shared for different event ids.</p>\n\n<p>event_id: the unique ID that classifies the event.</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_args.EventArgs.__init__", "modulename": "src.fairreckitlib.core.events.event_args", "qualname": "EventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_args.MessageEventArgs", "modulename": "src.fairreckitlib.core.events.event_args", "qualname": "MessageEventArgs", "type": "class", "doc": "<p>Message Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the message event.\nmessage: the message.</p>\n", "bases": "EventArgs"}, {"fullname": "src.fairreckitlib.core.events.event_args.MessageEventArgs.__init__", "modulename": "src.fairreckitlib.core.events.event_args", "qualname": "MessageEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, message: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "type": "module", "doc": "<p>This module contains a class that implements dispatcher/listener behaviour.</p>\n\n<p>Classes:</p>\n\n<pre><code>EventDispatcher: can dispatch an event to the respectively subscribed listeners.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher", "type": "class", "doc": "<p>Event Dispatcher provides tools to communicate events to listeners.</p>\n\n<p>The dispatcher is a centralized object that keeps track of all registered listeners\nfor a specified event ID. These listeners can be added and removed dynamically.</p>\n\n<p>Public methods:</p>\n\n<p>add_listener\nget_num_listeners\nget_num_listeners_total\nremove_listener\ndispatch</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.__init__", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.__init__", "type": "function", "doc": "<p>Construct the EventDispatcher.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.add_listener", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.add_listener", "type": "function", "doc": "<p>Add a listener for the specified event ID.</p>\n\n<p>The event_listener and func_on_event are joined as a tuple to describe the listener\nand is expected to be unique. The listener will be notified by the dispatcher\nevery time that the event arguments with the specified ID is propagated.\nThis function raises a KeyError when the listener tuple already exists.</p>\n\n<p>Args:\n    event_id: unique ID that classifies the event.\n    event_listener: the listener of the event. This object is passed to\n        the event callback function as the first argument when the event is dispatched.\n    func_on_event: the callback functions that are called when the event\n        is dispatched. The first argument is the event_listener, followed by event args.\n        and any keyword args</p>\n", "signature": "(\n    self,\n    event_id: str,\n    event_listener: Any,\n    func_on_event: Tuple[Callable[[Any, src.fairreckitlib.core.events.event_args.EventArgs], NoneType], Optional[Callable[[Any, src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.get_num_listeners", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.get_num_listeners", "type": "function", "doc": "<p>Get the amount of listeners for the specified event id.</p>\n\n<p>Args:\n    event_id: the event id to query the number of listeners of.</p>\n\n<p>Returns:\n    the number of listeners of the event or None when the event is not registered.</p>\n", "signature": "(self, event_id: str) -> Optional[int]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.get_num_listeners_total", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.get_num_listeners_total", "type": "function", "doc": "<p>Get the total amount of listeners for the dispatcher.</p>\n\n<p>Returns:\n    the number of listeners in total.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.remove_listener", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.remove_listener", "type": "function", "doc": "<p>Remove a listener for the specified event ID.</p>\n\n<p>The event_listener and func_on_event are joined as a tuple to describe the listener\nand is expected to be unique. The listener is also expected to be identical to the one\nthat was used in 'add_listener' and will no longer be notified by the dispatcher when the\nevent arguments with the specified ID is propagated.\nThis function raises a KeyError when either the event_id or listener tuple does not exist.</p>\n\n<p>Args:\n    event_id: unique ID that classifies the event.\n    event_listener: the listener of the event. This object is passed to\n        the event callback function as the first argument when the event is dispatched.\n    func_on_event: the callback functions that are called when the event\n        is dispatched. The first argument is the event_listener, followed by event args\n        and any keyword args.</p>\n", "signature": "(\n    self,\n    event_id: str,\n    event_listener: Any,\n    func_on_event: Tuple[Callable[[Any, src.fairreckitlib.core.events.event_args.EventArgs], NoneType], Optional[Callable[[Any, src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.dispatch", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.dispatch", "type": "function", "doc": "<p>Dispatch event arguments with the corresponding event ID.</p>\n\n<p>The event arguments with the specified ID will be propagated to all registered listeners.\nFor each listener their respective callback function is called with the listener\nas the first argument, followed by the specified event args and keyword args.</p>\n\n<p>Args:\n    event_args: the event's arguments.</p>\n\n<p>Keyword Args:\n    Any: varies depending on the event.</p>\n\n<p>Returns:\n    whether the event was dispatched to any registered listeners.</p>\n", "signature": "(\n    self,\n    event_args: src.fairreckitlib.core.events.event_args.EventArgs,\n    **kwargs\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_error", "modulename": "src.fairreckitlib.core.events.event_error", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch that are error related.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_FAILURE_ERROR: id of the event that is used when a failure occurs.\nON_RAISE_ERROR: id of the event that is used when an error was raised.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>ErrorEventArgs: event args for errors.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_error_events: list of error event IDs.\nget_error_event_print_switch: switch to print error event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_error.ErrorEventArgs", "modulename": "src.fairreckitlib.core.events.event_error", "qualname": "ErrorEventArgs", "type": "class", "doc": "<p>Error Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the error event.\nmessage: the error message.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.MessageEventArgs"}, {"fullname": "src.fairreckitlib.core.events.event_error.ErrorEventArgs.__init__", "modulename": "src.fairreckitlib.core.events.event_error", "qualname": "ErrorEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, message: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_error.get_error_events", "modulename": "src.fairreckitlib.core.events.event_error", "qualname": "get_error_events", "type": "function", "doc": "<p>Get a list of error event IDs.</p>\n\n<p>Returns:\n    a list of unique error event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_error.get_error_event_print_switch", "modulename": "src.fairreckitlib.core.events.event_error", "qualname": "get_error_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints error event IDs.</p>\n\n<p>Returns:\n    the print error event switch.</p>\n", "signature": "(\n    \n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io", "modulename": "src.fairreckitlib.core.io", "type": "module", "doc": "<p>This package contains functionality for commonly used IO operations.</p>\n\n<p>Modules:</p>\n\n<pre><code>event_io: event ids, event args and a print switch that are IO related.\nio_create: IO functions that create something on the disk and dispatch an IO event.\nio_delete: IO functions that delete something on the disk and dispatch an IO event.\nio_utility: IO utility functions that connect with external packages.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.event_io", "modulename": "src.fairreckitlib.core.io.event_io", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch that are IO related.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_MAKE_DIR: id of the event that is used when a directory is created.\nON_REMOVE_DIR: id of the event that is used when a directory is removed.\nON_CREATE_FILE: id of the event that is used when a file is created.\nON_REMOVE_FILE: id of the event that is used when a file is removed.\nON_RENAME_FILE: id of the event that is used when a file is renamed.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>DirEventArgs: event args related to a directory.\nFileEventArgs: event args related to a file.\nDataframeEventArgs: event args related to a dataframe.\nRenameFileEventArgs: event args related to renaming a file.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_io_events: list of IO event IDs.\nget_io_event_print_switch: switch to print IO event arguments by ID.\nprint_load_dataframe_event_args: print dataframe event arguments for loading.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.event_io.DirEventArgs", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "DirEventArgs", "type": "class", "doc": "<p>Directory Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the directory event.\ndirectory: the path to the directory.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.core.io.event_io.DirEventArgs.__init__", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "DirEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, directory: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.FileEventArgs", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "FileEventArgs", "type": "class", "doc": "<p>File Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the file event.\nfile_path: the path to the file.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.core.io.event_io.FileEventArgs.__init__", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "FileEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, file_path: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.DataframeEventArgs", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "DataframeEventArgs", "type": "class", "doc": "<p>Dataframe Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the dataframe event.\nfile_path: the path to the dataframe file.\ndataframe_name: the name of the dataframe.</p>\n", "bases": "FileEventArgs"}, {"fullname": "src.fairreckitlib.core.io.event_io.DataframeEventArgs.__init__", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "DataframeEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, file_path: str, dataframe_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.get_io_events", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "get_io_events", "type": "function", "doc": "<p>Get a list of IO event IDs.</p>\n\n<p>Returns:\n    a list of unique IO event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.get_io_event_print_switch", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "get_io_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints IO event IDs.</p>\n\n<p>Returns:\n    the print IO event switch.</p>\n", "signature": "(\n    \n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.print_load_df_event_args", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "print_load_df_event_args", "type": "function", "doc": "<p>Print dataframe event arguments for loading.</p>\n\n<p>It is assumed that the event started when elapsed_time is None and is finished otherwise.</p>\n\n<p>Args:\n    event_args: the arguments to print.\n    elapsed_time: the time that has passed since the loading started, expressed in seconds.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.core.io.event_io.DataframeEventArgs,\n    elapsed_time: float = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_create", "modulename": "src.fairreckitlib.core.io.io_create", "type": "module", "doc": "<p>This module contains IO functions that create something on the disk and dispatch an IO event.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_dir: create a directory on the disk with IO event dispatching.\ncreate_json: create a json file on the disk with IO event dispatching.\ncreate_yml: create a yml file on the disk with event dispatching.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.io_create.create_dir", "modulename": "src.fairreckitlib.core.io.io_create", "qualname": "create_dir", "type": "function", "doc": "<p>Create the specified directory.</p>\n\n<p>This functions checks whether the directory exists and the\nevent is only dispatched when the directory did not exist yet.</p>\n\n<p>Args:\n    directory: the directory to create on the disk.\n    event_dispatcher: used to dispatch the IO event.</p>\n\n<p>Returns:\n    the directory path.</p>\n", "signature": "(\n    directory: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_create.create_json", "modulename": "src.fairreckitlib.core.io.io_create", "qualname": "create_json", "type": "function", "doc": "<p>Create a JSON file with the specified data.</p>\n\n<p>The IO event is dispatched after the file is created.</p>\n\n<p>Args:\n    file_path: path to where the json file will be stored.\n    data: the source dictionary to save in the file.\n    event_dispatcher: used to dispatch the IO event.\n    encoding: the encoding to use for writing the file contents.\n    indent: the indent level for pretty printing JSON array elements and object members.</p>\n", "signature": "(\n    file_path: str,\n    data: Union[Dict[str, Any], List],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    encoding: str = 'utf-8',\n    indent=1\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_create.create_yml", "modulename": "src.fairreckitlib.core.io.io_create", "qualname": "create_yml", "type": "function", "doc": "<p>Create a YML file with the specified data.</p>\n\n<p>The IO event is dispatched after the file is created.</p>\n\n<p>Args:\n    file_path: path to where the json file will be stored.\n    data: the source dictionary to save in the file.\n    event_dispatcher: used to dispatch the IO event.\n    encoding: the encoding to use for writing the file contents.</p>\n", "signature": "(\n    file_path: str,\n    data: Union[Dict[str, Any], List],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    encoding: str = 'utf-8'\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_delete", "modulename": "src.fairreckitlib.core.io.io_delete", "type": "module", "doc": "<p>This module contains IO functions that delete something on the disk and dispatch an IO event.</p>\n\n<p>Functions:</p>\n\n<pre><code>delete_dir: delete a directory, recursively, with IO event dispatching.\ndelete_file: delete a file from the disk with IO event dispatching.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.io_delete.delete_dir", "modulename": "src.fairreckitlib.core.io.io_delete", "qualname": "delete_dir", "type": "function", "doc": "<p>Delete the specified directory.</p>\n\n<p>This functions removes all the files and directories that are present\nin the specified directory path (recursively).\nThe IO event is dispatched after the directory and/or files are deleted.</p>\n\n<p>Args:\n    directory: the path to the directory to delete.\n    event_dispatcher: used to dispatch the IO event.</p>\n", "signature": "(\n    directory: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_delete.delete_file", "modulename": "src.fairreckitlib.core.io.io_delete", "qualname": "delete_file", "type": "function", "doc": "<p>Delete the specified file.</p>\n\n<p>The IO event is dispatched after the file is deleted.</p>\n\n<p>Args:\n    file_path: the path to the file to delete.\n    event_dispatcher: used to dispatch the IO event.</p>\n", "signature": "(\n    file_path: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility", "modulename": "src.fairreckitlib.core.io.io_utility", "type": "module", "doc": "<p>This module contains IO utility functions that connect with external packages.</p>\n\n<p>Functions:</p>\n\n<pre><code>load_array_from_hdf5: load array data from hdf5 file.\nload_json: load dictionary from json file.\nload_yml: load dictionary from yml file.\nsave_array_to_hdf5: save array data to hdf5 file.\nsave_json: save dictionary to json file.\nsave_yml: save dictionary to yml file.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.io_utility.load_array_from_hdf5", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "load_array_from_hdf5", "type": "function", "doc": "<p>Load a single array from a HDF5 binary data file.</p>\n\n<p>This function raises a FileNotFoundError when the specified file does not exist.\nCounterpart of the save_array_to_hdf5 function.</p>\n\n<p>Args:\n    file_path: path to where the HDF5 file is stored.\n    array_name: name of the array to retrieve from the file.</p>\n\n<p>Returns:\n    the array data from the file.</p>\n", "signature": "(file_path: str, array_name: str) -> <built-in function array>", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.load_json", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "load_json", "type": "function", "doc": "<p>Load a json file.</p>\n\n<p>This function raises a FileNotFoundError when the specified file does not exist.\nCounterpart of the save_json function.</p>\n\n<p>Args:\n    file_path: path to where the json file is stored.\n    encoding: the encoding to use for reading the file contents.</p>\n\n<p>Returns:\n    the resulting dictionary.</p>\n", "signature": "(file_path: str, encoding: str = 'utf-8') -> Union[Dict[str, Any], List]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.load_yml", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "load_yml", "type": "function", "doc": "<p>Load a yml file.</p>\n\n<p>This function raises a FileNotFoundError when the specified file does not exist.\nCounterpart of the save_yml function.</p>\n\n<p>Args:\n    file_path: path to where the yml file is stored.\n    encoding: the encoding to use for reading the file contents.</p>\n\n<p>Returns:\n    the resulting dictionary.</p>\n", "signature": "(file_path: str, encoding: str = 'utf-8') -> Union[Dict[str, Any], List]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.save_array_to_hdf5", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "save_array_to_hdf5", "type": "function", "doc": "<p>Save a single array to a HDF5 binary data file.</p>\n\n<p>Counterpart of the load_array_from_hdf5 function.</p>\n\n<p>Args:\n    file_path: path to where the HDF5 file will be stored.\n    arr: the source array to save in the file.\n    array_name: name of the array to save in the file.</p>\n", "signature": "(file_path: str, arr: List[Any], array_name: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.save_json", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "save_json", "type": "function", "doc": "<p>Save a json file.</p>\n\n<p>Counterpart of the load_json function.</p>\n\n<p>Args:\n    file_path: path to where the json file will be stored.\n    data: the source dictionary to save in the file.\n    encoding: the encoding to use for writing the file contents.\n    indent: the indent level for pretty printing JSON array elements and object members.</p>\n", "signature": "(\n    file_path: str,\n    data: Union[Dict[str, Any], List],\n    *,\n    encoding: str = 'utf-8',\n    indent=None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.save_yml", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "save_yml", "type": "function", "doc": "<p>Save a yml file.</p>\n\n<p>Counterpart of the load_yml function.</p>\n\n<p>Args:\n    file_path: path to where the yml file will be stored.\n    data: the source dictionary to save in the file.\n    encoding: the encoding to use for writing the file contents.</p>\n", "signature": "(\n    file_path: str,\n    data: Union[Dict[str, Any], List],\n    *,\n    encoding: str = 'utf-8'\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing", "modulename": "src.fairreckitlib.core.parsing", "type": "module", "doc": "<p>This package contains base functionality for parsing configuration files.</p>\n\n<p>Modules:</p>\n\n<pre><code>parse_assert: parse functions in the form of commonly used assertions.\nparse_config_object: parse configuration object name and parameters.\nparse_config_params: parse configuration parameter(s).\nparse_event: event id, event args and a print function for a parse event.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "type": "module", "doc": "<p>This module contains parsing functionality for commonly used assertions.</p>\n\n<p>Functions:</p>\n\n<pre><code>assert_is_container_not_empty: assert a container to have entries.\nassert_is_key_in_dict: assert a dictionary to have a key.\nassert_is_one_of_list: assert a value to be one of the values of a list.\nassert_is_type: assert a value to be of a certain type.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert.assert_is_container_not_empty", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "qualname": "assert_is_container_not_empty", "type": "function", "doc": "<p>Assert whether the specified container is not empty.</p>\n\n<p>Args:\n    src_container: the container to assert.\n    event_dispatcher: to dispatch the parse event on failure.\n    error_msg: the error message describing the assertion failure.\n    one_of_list: a list of values that contains the expected value.\n    expected_type: the type that is expected to be parsed.\n    actual_type: the value that is attempted to be parsed.\n    default_value: the default value that is returned after parsing.</p>\n\n<p>Returns:\n    whether the assertion has passed.</p>\n", "signature": "(\n    src_container: Union[Dict, List],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    error_msg: str,\n    *,\n    one_of_list: List[Any] = None,\n    expected_type: Type = None,\n    actual_type: Type = None,\n    default_value: Any = None\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert.assert_is_key_in_dict", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "qualname": "assert_is_key_in_dict", "type": "function", "doc": "<p>Assert whether the specified key is present in the specified dictionary.</p>\n\n<p>Args:\n    src_key: the key to assert.\n    src_dict: the dictionary to check the key in.\n    event_dispatcher: to dispatch the parse event on failure.\n    error_msg: the error message describing the assertion failure.\n    one_of_list: a list of values that contains the expected value.\n    expected_type: the type that is expected to be parsed.\n    actual_type: the value that is attempted to be parsed.\n    default_value: the default value that is returned after parsing.</p>\n\n<p>Returns:\n    whether the assertion has passed.</p>\n", "signature": "(\n    src_key: str,\n    src_dict: Dict[str, Any],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    error_msg: str,\n    *,\n    one_of_list: List[Any] = None,\n    expected_type: Type = None,\n    actual_type: Any = None,\n    default_value: Any = None\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert.assert_is_one_of_list", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "qualname": "assert_is_one_of_list", "type": "function", "doc": "<p>Assert whether the specified value is present in the specified list.</p>\n\n<p>Args:\n    src_value: the value to assert.\n    src_list: the list to check the value in.\n    event_dispatcher: to dispatch the parse event on failure.\n    error_msg: the error message describing the assertion failure.\n    expected_type: the type that is expected to be parsed.\n    actual_type: the value that is attempted to be parsed.\n    default_value: the default value that is returned after parsing.</p>\n\n<p>Returns:\n    bool: whether the assertion has passed.</p>\n", "signature": "(\n    src_value: str,\n    src_list: List[str],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    error_msg: str,\n    *,\n    expected_type: Type = None,\n    actual_type: Any = None,\n    default_value: Any = None\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert.assert_is_type", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "qualname": "assert_is_type", "type": "function", "doc": "<p>Assert whether the specified value is of the expected type.</p>\n\n<p>Args:\n    value: the value to assert.\n    expected_type: the type that is expected.\n    event_dispatcher: to dispatch the parse event on failure.\n    error_msg: the error message describing the assertion failure.\n    one_of_list: a list of values that contains the expected value.\n    default_value: the default value that is returned after parsing.</p>\n\n<p>Returns:\n    bool: whether the assertion has passed.</p>\n", "signature": "(\n    value: Any,\n    expected_type: Type,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    error_msg: str,\n    *,\n    one_of_list: List[Any] = None,\n    default_value: Any = None\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_object", "modulename": "src.fairreckitlib.core.parsing.parse_config_object", "type": "module", "doc": "<p>This module contains functionality to parse configuration object name and parameters.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_config_object: parse an object name and parameters configuration.\nparse_config_object_list: parse a list of config objects\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_object.parse_config_object", "modulename": "src.fairreckitlib.core.parsing.parse_config_object", "qualname": "parse_config_object", "type": "function", "doc": "<p>Parse an object name and parameters configuration.</p>\n\n<p>Args:\n    obj_type_name: name of the object type.\n    obj_config: dictionary with the object's configuration.\n    obj_factory: the object (group) factory related to the object config.\n    event_dispatcher: to dispatch the parse event on failure.\n    params: dictionary with params that will override validation of existing config params.\n    default_config: the default configuration (used as default parse event arg on failure).</p>\n\n<p>Returns:\n    the parsed configuration and object name or None on failure.</p>\n", "signature": "(\n    obj_type_name: str,\n    obj_config: Dict[str, Any],\n    obj_factory: Union[src.fairreckitlib.core.config.config_factories.Factory, src.fairreckitlib.core.config.config_factories.GroupFactory],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    params: Dict[str, src.fairreckitlib.core.config.config_base_param.ConfigParam] = None,\n    default_config: src.fairreckitlib.core.config.config_object.ObjectConfig = None\n) -> Union[Tuple[src.fairreckitlib.core.config.config_object.ObjectConfig, str], Tuple[NoneType, NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_object.parse_config_object_list", "modulename": "src.fairreckitlib.core.parsing.parse_config_object", "qualname": "parse_config_object_list", "type": "function", "doc": "<p>Parse the object configurations for the specified category name.</p>\n\n<p>Args:\n    obj_category_name: name of the object category.\n    obj_type_name: name of the object type.\n    obj_config_list: list of dictionaries with the object's configuration.\n    obj_factory: the object (group) factory related to the object config.\n    event_dispatcher: to dispatch the parse event on failure.\n    params: dictionary with params that will override validation of existing config params.</p>\n\n<p>Returns:\n    a tuple list of the successfully parsed ObjectConfig's and their corresponding dictionary.</p>\n", "signature": "(\n    obj_category_name: str,\n    obj_type_name: str,\n    obj_config_list: List[Dict[str, Any]],\n    obj_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    params: Dict[str, src.fairreckitlib.core.config.config_base_param.ConfigParam] = None\n) -> List[Tuple[src.fairreckitlib.core.config.config_object.ObjectConfig, Dict[str, Any]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_params", "modulename": "src.fairreckitlib.core.parsing.parse_config_params", "type": "module", "doc": "<p>This module contains functionality to parse configuration parameter(s).</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_config_parameters: parse multiple parameters.\nparse_config_param: parse a single parameter.\ntrim_config_params: trim unnecessary params that are not present in the config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_params.parse_config_parameters", "modulename": "src.fairreckitlib.core.parsing.parse_config_params", "qualname": "parse_config_parameters", "type": "function", "doc": "<p>Parse the object's parameters configuration.</p>\n\n<p>Args:\n    params_config: dictionary with the configuration to parse.\n    parent_name: name of the parent related to the parameters' configuration.\n    parameters: the configuration parameters.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed params configuration as key-value pairs.</p>\n", "signature": "(\n    params_config: Any,\n    parent_name: str,\n    parameters: src.fairreckitlib.core.config.config_parameters.ConfigParameters,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_params.parse_config_param", "modulename": "src.fairreckitlib.core.parsing.parse_config_params", "qualname": "parse_config_param", "type": "function", "doc": "<p>Parse a parameter from the specified configuration.</p>\n\n<p>Args:\n    params_config: dictionary with the parameters' configuration.\n    parent_name: name of the parent related to the parameters' configuration.\n    param: the parameter that is being parsed.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    whether the parsing succeeded and the parsed (validated) value.</p>\n", "signature": "(\n    params_config: Dict[str, Any],\n    parent_name: str,\n    param: src.fairreckitlib.core.config.config_base_param.ConfigParam,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Tuple[bool, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_params.trim_config_params", "modulename": "src.fairreckitlib.core.parsing.parse_config_params", "qualname": "trim_config_params", "type": "function", "doc": "<p>Trim the parameters from the specified configuration.</p>\n\n<p>Removes unnecessary parameters that are not present in the\noriginal config parameter list.</p>\n\n<p>Args:\n    params_config: dictionary with the parameters' configuration.\n    parent_name: name of the parent related to the parameters' configuration.\n    parameters: the configuration parameters.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the dictionary with the trimmed parameters.</p>\n", "signature": "(\n    params_config: Dict[str, Any],\n    parent_name: str,\n    parameters: src.fairreckitlib.core.config.config_parameters.ConfigParameters,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event", "modulename": "src.fairreckitlib.core.parsing.parse_event", "type": "module", "doc": "<p>This module contains an event id, event args and print function for a parsing event.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_PARSE: id of the event that is used when parsing fails.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>ParseEventArgs: event args related to parsing.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>print_parse_event: print parse event arguments.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs", "type": "class", "doc": "<p>Parse Event Arguments.</p>\n\n<p>Only the message is required, other variables are optional.</p>\n\n<p>message: the message describing the parsing failure.\none_of_list: a list of values that contains the expected value.\nexpected_type: the type that is expected to be parsed.\nactual_type: the type that is attempted to be parsed.\ndefault_value: the default value that is returned after parsing.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.MessageEventArgs"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.__init__", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    message: str,\n    one_of_list: List[Any] = None,\n    expected_type: Type = None,\n    actual_type: Type = None,\n    default_value: Any = None\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.one_of_list", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.one_of_list", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Any]", "default_value": " = None"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.expected_type", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.expected_type", "type": "variable", "doc": "<p></p>\n", "annotation": ": Type", "default_value": " = None"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.actual_type", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.actual_type", "type": "variable", "doc": "<p></p>\n", "annotation": ": Type", "default_value": " = None"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.default_value", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.default_value", "type": "variable", "doc": "<p></p>\n", "annotation": ": Any", "default_value": " = None"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.print_parse_event", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "print_parse_event", "type": "function", "doc": "<p>Print parse event arguments.</p>\n\n<p>Args:\n    event_args: the arguments to print.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.core.parsing.parse_event.ParseEventArgs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.pipeline", "modulename": "src.fairreckitlib.core.pipeline", "type": "module", "doc": "<p>This module contains functionality for the core pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>core_pipeline: base class for the core pipeline.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "type": "module", "doc": "<p>This module contains the base core pipeline class.</p>\n\n<p>Classes:</p>\n\n<pre><code>CorePipeline: base pipeline class with shared IO functionality.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "qualname": "CorePipeline", "type": "class", "doc": "<p>Base class for FairRecKit pipelines.</p>\n\n<p>This class exposes some reusable functionality that can be used in derived\npipelines to read and/or write dataframes.</p>\n"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline.__init__", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "qualname": "CorePipeline.__init__", "type": "function", "doc": "<p>Construct the CorePipeline.</p>\n\n<p>Args:\n    event_dispatcher: used to dispatch events when running the core pipeline.</p>\n", "signature": "(\n    self,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline.read_dataframe", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "qualname": "CorePipeline.read_dataframe", "type": "function", "doc": "<p>Read a dataframe from the disk.</p>\n\n<p>This function dispatches an error event when the FileNotFoundError is raised,\nand thereafter the error is raised once more.</p>\n\n<p>Args:\n    dataframe_path: path to the dataframe file.\n    dataframe_name: name of the dataframe to use for event dispatching.\n    event_id_on_begin: the event_id to dispatch when loading starts.\n    event_id_on_end: the event_id to dispatch when loading is finished.\n    names: the column names of the dataframe or None to infer them from the header.</p>\n\n<p>Raises:\n    FileNotFoundError: when the dataframe file is not found.</p>\n\n<p>Returns:\n    the loaded dataframe.</p>\n", "signature": "(\n    self,\n    dataframe_path: str,\n    dataframe_name: str,\n    event_id_on_begin: str,\n    event_id_on_end: str,\n    *,\n    names=None\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline.write_dataframe", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "qualname": "CorePipeline.write_dataframe", "type": "function", "doc": "<p>Write a dataframe to the disk.</p>\n\n<p>This function is intended to write (append) a dataframe in chunks,\nincluding the header of the dataframe.\nIt is assumed that when the header is True that the dataframe file\nhas been created, which in turn will dispatch the IO event.</p>\n\n<p>Args:\n    dataframe_path: path to the dataframe file.\n    dataframe: the dataframe to append to the file.\n    header: whether to include the header.</p>\n", "signature": "(\n    self,\n    dataframe_path: str,\n    dataframe: pandas.core.frame.DataFrame,\n    header: bool\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading", "modulename": "src.fairreckitlib.core.threading", "type": "module", "doc": "<p>This package contains functionality for base threading and processing.</p>\n\n<p>Modules:</p>\n\n<pre><code>thread_base: base class for a thread that can be handled by the processor.\nthread_processor: processor that starts new and stops active threads.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_base", "modulename": "src.fairreckitlib.core.threading.thread_base", "type": "module", "doc": "<p>This module contains the base class for threads.</p>\n\n<p>Classes:</p>\n\n<pre><code>ThreadBase: base class that implements basic threading functionality.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase", "type": "class", "doc": "<p>Base class for all threads.</p>\n\n<p>Wraps the threading module in a class interface. The main function of each\nthread consists of three steps:</p>\n\n<p>1) Initialize\n2) Run\n3) Terminate</p>\n\n<p>Threads are not running on creation, only after the start() function is called.\nThe function is_running() will return True as long as the thread is active,\nonce the stop() function is called it requests the thread to finish.\nThreads cannot be cancelled so any derived class logic needs to account for this request\nby checking the is_running function pointer (in step 2) regularly.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_initialize (optional)\non_run (required)\non_terminate (optional)</p>\n\n<p>Public methods:</p>\n\n<p>get_name\nis_running\nstart\nstop</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.__init__", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.__init__", "type": "function", "doc": "<p>Construct the BaseThread.</p>\n\n<p>Args:\n    name the name of the thread.\n    verbose: whether the thread should give verbose output.</p>\n\n<p>Keyword Args:\n    varying: these are passed to the run function from step 2.</p>\n", "signature": "(self, name: str, verbose: bool, **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.start", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.start", "type": "function", "doc": "<p>Start running the thread.</p>\n\n<p>Args:\n    terminate_callback: call back function that is called once the thread is\n    finished running and is terminated. This function has one argument\n    which is the thread itself.</p>\n\n<p>Returns:\n    True when the thread successfully started or False when the thread is already running.</p>\n", "signature": "(self, terminate_callback: Callable[[Any], NoneType]) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.stop", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.stop", "type": "function", "doc": "<p>Stop running the thread.</p>\n\n<p>Does not cancel the thread, but rather requests for the thread to finish\nby settings the is_running flag to False. Derived classes need to account\nfor this request by checking the status regularly.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.get_name", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.get_name", "type": "function", "doc": "<p>Get the name of the thread.</p>\n\n<p>Returns:\n    the thread's name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.is_running", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.is_running", "type": "function", "doc": "<p>Get if the thread is still running.</p>\n\n<p>Returns:\n    whether the thread is running.</p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.on_initialize", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.on_initialize", "type": "function", "doc": "<p>Initialize the thread.</p>\n\n<p>This function is called once when the thread is started.\nIt should not be used directly, add specific logic in derived classes.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.on_run", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.on_run", "type": "function", "doc": "<p>Run the thread.</p>\n\n<p>This function is called once after the thread is initialized.\nIt should not be used directly, add specific logic in derived classes.</p>\n\n<p>Keyword Args:\n    varying: these are passed directly from the thread's constructor.</p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.on_terminate", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.on_terminate", "type": "function", "doc": "<p>Terminate the thread.</p>\n\n<p>This function is called once after the thread is done running.\nIt should not be used directly, add specific logic in derived classes.\nMoreover, derived classes are expected to call their super implementation\nafter their own implementation is finished.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.main", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.main", "type": "function", "doc": "<p>Run the main function target of the thread.</p>\n\n<p>Keyword Args:\n    varying: these are passed directly from the thread's constructor.</p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor", "modulename": "src.fairreckitlib.core.threading.thread_processor", "type": "module", "doc": "<p>This module contains a processor that handles active threads.</p>\n\n<p>Classes:</p>\n\n<pre><code>ThreadProcessor: class that starts new and stops running threads.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor", "type": "class", "doc": "<p>Processor for multiple threads (derived from ThreadBase class).</p>\n\n<p>Keeps track of all threads that are started by this processor.\nThe processor acquires ownership of these aforementioned threads and\nwill dispose of them after they are finished.\nAdditionally, these threads can be stopped as well.</p>\n\n<p>Public methods:</p>\n\n<p>get_active_threads\nget_num_active\nis_active_thread\nstart\nstop</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.__init__", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.__init__", "type": "function", "doc": "<p>Construct the ThreadProcessor.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.get_active_threads", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.get_active_threads", "type": "function", "doc": "<p>Get the names of any active threads.</p>\n\n<p>Returns:\n    a list of thread names that are currently running.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.get_num_active", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.get_num_active", "type": "function", "doc": "<p>Get the number of active threads for this processor.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.is_active_thread", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.is_active_thread", "type": "function", "doc": "<p>Get if the thread with the specified name is active.</p>\n\n<p>Args:\n    thread_name: the name of the thread to query.</p>\n\n<p>Returns:\n    whether the thread is handled by the processor.</p>\n", "signature": "(self, thread_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.start", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.start", "type": "function", "doc": "<p>Start the specified thread.</p>\n\n<p>The processor takes ownership of the thread and will clean it up\nafter it is done running.\nThis function returns a KeyError when a thread with the same name\nis already being handled by the processor.</p>\n\n<p>Args:\n    thread: the thread to start.</p>\n", "signature": "(\n    self,\n    thread: src.fairreckitlib.core.threading.thread_base.ThreadBase\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.stop", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.stop", "type": "function", "doc": "<p>Stop the thread with the specified name.</p>\n\n<p>The processor requests the thread to stop running.\nThis function returns a KeyError when a thread with the specified name\nis not being handled by the processor.</p>\n\n<p>Args:\n    thread_name: the name of the thread to stop.</p>\n", "signature": "(self, thread_name: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.remove", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.remove", "type": "function", "doc": "<p>Remove the thread from the processor.</p>\n", "signature": "(self, thread)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data", "modulename": "src.fairreckitlib.data", "type": "module", "doc": "<p>This package contains functionality for data(set) operations.</p>\n\n<p>Modules:</p>\n\n<pre><code>data_factory: create data factory with available data modifier factories.\ndata_modifier: base class and factory for dataframe modifications.\ndata_transition: data transition class.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>filter: dataframe filtering.\npipeline: run data modifiers on (multiple) datasets.\nratings: dataframe rating conversion.\nset: dataset definition/preprocessing/registry.\nsplit: dataframe splitting.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.data_factory", "modulename": "src.fairreckitlib.data.data_factory", "type": "module", "doc": "<p>This module contains functionality to create a data factory.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_DATA: key that is used to identify data.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_data_factory: create factory with data modifier factories.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.data_factory.create_data_factory", "modulename": "src.fairreckitlib.data.data_factory", "qualname": "create_data_factory", "type": "function", "doc": "<p>Create a group factory with all data modifier factories.</p>\n\n<p>Args:</p>\n\n<pre><code>data_registry: the data registry with available datasets.\n</code></pre>\n\n<p>Consists of three data modifier factories:\n    1) data filters.\n    2) data rating converters.\n    3) data splitters.</p>\n\n<p>Returns:\n    the group factory with available data modifier factories.</p>\n", "signature": "(\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry\n) -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier", "modulename": "src.fairreckitlib.data.data_modifier", "type": "module", "doc": "<p>This module contains the base class and factory for data modification.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataModifier: the base class for data modifying.\nDataModifierFactory: the factory that creates data modifiers related to a dataset matrix.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier", "type": "class", "doc": "<p>Base class for FairRecKit data modifiers.</p>\n\n<p>Public methods:</p>\n\n<p>get_name\nget_params\nrun</p>\n"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier.__init__", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier.__init__", "type": "function", "doc": "<p>Construct the DataModifier.</p>\n\n<p>Args:\n    name: the name of the modifier.\n    params: the modifier parameters.</p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier.get_name", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier.get_name", "type": "function", "doc": "<p>Get the name of the modifier.</p>\n\n<p>Returns:\n    the modifier name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier.get_params", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier.get_params", "type": "function", "doc": "<p>Get the parameters of the modifier.</p>\n\n<p>Returns:\n    the modifier parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier.run", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier.run", "type": "function", "doc": "<p>Run the modifier on the specified dataframe.</p>\n\n<p>Args:\n    dataframe: source df to modify.</p>\n\n<p>Returns:\n    any modification to the dataframe.</p>\n", "signature": "(self, dataframe: pandas.core.frame.DataFrame) -> Any", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifierFactory", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifierFactory", "type": "class", "doc": "<p>Factory for data modifier creation.</p>\n\n<p>The intended use is to associate the factory with a specific matrix of a dataset.\nBoth the created parameters and the created data modifiers are supplied\nwith a reference to the dataset and the name of the matrix they belong to.</p>\n", "bases": "src.fairreckitlib.core.config.config_factories.Factory"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifierFactory.__init__", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifierFactory.__init__", "type": "function", "doc": "<p>Construct the DataModifierFactory.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix that it relates to.\n    dataset: the dataset associated with the matrix.</p>\n", "signature": "(\n    self,\n    matrix_name: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifierFactory.create", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifierFactory.create", "type": "function", "doc": "<p>Create and return a new data modifier with the specified name.</p>\n\n<p>The specified parameters are expected to be of the same structure as the defaults\nof the ConfigParameters that are associated with the desired data modifier.\nWhen no parameters are specified it will use the data modifier's defaults.</p>\n\n<p>Args:\n    obj_name: the name of the data modifier to create.\n    obj_params: the parameters of the data modifier.</p>\n\n<p>Keyword Args:\n    Any: extra arguments that need to be passed to the data modifier on creation.</p>\n\n<p>Returns:\n    the created data modifier or None when it does not exist.</p>\n", "signature": "(\n    self,\n    obj_name: str,\n    obj_params: Dict[str, Any] = None,\n    **kwargs\n) -> src.fairreckitlib.data.data_modifier.DataModifier", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifierFactory.on_create_params", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifierFactory.on_create_params", "type": "function", "doc": "<p>Create parameters for the data modifier with the specified name.</p>\n\n<p>Args:\n    obj_name: name of the data modifier to create parameters for.</p>\n\n<p>Returns:\n    the configuration parameters of the object or empty parameters when it does not exist.</p>\n", "signature": "(\n    self,\n    obj_name: str\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.create_data_modifier_factory", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "create_data_modifier_factory", "type": "function", "doc": "<p>Create a data modifier factory for each dataset-matrix pair.</p>\n\n<p>Args:</p>\n\n<pre><code>data_registry: the data registry with available datasets.\nfactory_name: the name of the data modifier factory.\nfunc_on_add_entries: callback for each dataset-matrix pair to add data modifiers.\n</code></pre>\n\n<p>Returns:\n    the factory with all available data modifiers per dataset-matrix pair.</p>\n", "signature": "(\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    factory_name: str,\n    func_on_add_entries: Callable[[src.fairreckitlib.data.data_modifier.DataModifierFactory, src.fairreckitlib.data.set.dataset.Dataset], NoneType]\n) -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_transition", "modulename": "src.fairreckitlib.data.data_transition", "type": "module", "doc": "<p>This module contains a data transition definition.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataTransition: data descriptions to be used between pipelines.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.data_transition.DataTransition", "modulename": "src.fairreckitlib.data.data_transition", "qualname": "DataTransition", "type": "class", "doc": "<p>Data Transition to transfer pipeline data.</p>\n\n<p>dataset: the dataset that was used for the data transition.\nmatrix_name: the dataset matrix name that was used for the data transition.\noutput_dir: the output directory of the data transition.\ntrain_set_path: the train set path in the output directory.\ntest_set_path: the test set path in the output directory.\nrating_scale: the minimum and maximum rating in the train and test set combined.</p>\n"}, {"fullname": "src.fairreckitlib.data.data_transition.DataTransition.__init__", "modulename": "src.fairreckitlib.data.data_transition", "qualname": "DataTransition.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    output_dir: str,\n    train_set_path: str,\n    test_set_path: str,\n    rating_scale: Tuple[float, float]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_transition.DataTransition.get_rating_type", "modulename": "src.fairreckitlib.data.data_transition", "qualname": "DataTransition.get_rating_type", "type": "function", "doc": "<p>Get the rating type of the data transition.</p>\n\n<p>Returns:\n    the rating type (either 'explicit' or 'implicit').</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter", "modulename": "src.fairreckitlib.data.filter", "type": "module", "doc": "<p>This package contains functionality for filtering dataframes.</p>\n\n<p>Modules:</p>\n\n<pre><code>base_filter: Base class for data filters.\ncategorical_filter: Class to filter on categorical data.\ncount_filter: Class to filter on the number of appearances of each value of a column.\nfilter_config: subset/filter(pass) configuration classes.\nfilter_config_parsing: parse data subset/filter(pass) configurations.\nfilter_constants: Constants to be used in other modules.\nfilter_event: Event args and a print function for a filter event.\nfilter_factory: Create filter factory with available data filters.\nnumerical_filter: Class to filter on a range of numerical data.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.base_filter", "modulename": "src.fairreckitlib.data.filter.base_filter", "type": "module", "doc": "<p>Module that provides a base for all three types of filters: Numerical, Categorical, Count.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataFilter: Base filter class.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.base_filter.DataFilter", "modulename": "src.fairreckitlib.data.filter.base_filter", "qualname": "DataFilter", "type": "class", "doc": "<p>Base class to filter a df (not a dataframe in particular).</p>\n\n<p>Public method:\n    run</p>\n", "bases": "src.fairreckitlib.data.data_modifier.DataModifier"}, {"fullname": "src.fairreckitlib.data.filter.base_filter.DataFilter.__init__", "modulename": "src.fairreckitlib.data.filter.base_filter", "qualname": "DataFilter.__init__", "type": "function", "doc": "<p>Make Constructor of the class.</p>\n\n<p>Uses optional arguments to enable sole use of subclass.filter().</p>\n\n<p>Args:\n    name: Configuration name of the filter.\n    params: Configuration parameters.</p>\n", "signature": "(self, name: str, params: Dict[str, Any], **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.base_filter.DataFilter.run", "modulename": "src.fairreckitlib.data.filter.base_filter", "qualname": "DataFilter.run", "type": "function", "doc": "<p>Carry out the filtering.</p>\n\n<p>Args:\n    dataframe: Dataframe to be filtered on.</p>\n\n<p>Return:\n    The filtered dataframe.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.base_filter.DataFilter.get_type", "modulename": "src.fairreckitlib.data.filter.base_filter", "qualname": "DataFilter.get_type", "type": "function", "doc": "<p>Get the type of the filter.</p>\n\n<p>Returns:\n    The type name of the filter.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.categorical_filter", "modulename": "src.fairreckitlib.data.filter.categorical_filter", "type": "module", "doc": "<p>Module to filter on categories, like country or gender.</p>\n\n<p>Classes:</p>\n\n<pre><code>CategoricalFilter: Filter the dataframe on categorical data, such as country or gender.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_categorical_filter: Create an instance of CategoricalFilter.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.categorical_filter.CategoricalFilter", "modulename": "src.fairreckitlib.data.filter.categorical_filter", "qualname": "CategoricalFilter", "type": "class", "doc": "<p>Filter the dataframe on categorical data, such as country or gender.</p>\n\n<p>Public method:\n    filter</p>\n", "bases": "src.fairreckitlib.data.filter.base_filter.DataFilter"}, {"fullname": "src.fairreckitlib.data.filter.categorical_filter.CategoricalFilter.get_type", "modulename": "src.fairreckitlib.data.filter.categorical_filter", "qualname": "CategoricalFilter.get_type", "type": "function", "doc": "<p>Get the type of the filter.</p>\n\n<p>Returns:\n    The type name of the filter.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.categorical_filter.CategoricalFilter.filter", "modulename": "src.fairreckitlib.data.filter.categorical_filter", "qualname": "CategoricalFilter.filter", "type": "function", "doc": "<p>Filter on a list of categories.</p>\n\n<p>Args:\n    dataframe: Dataframe to be filtered.\n    column_name (str): Name of the column where the conditions need to be met.\n    conditions (List[Any]): A list of values,\n        where values of the column_name in the resulting dataframe meet some condition.</p>\n\n<p>Returns:\n    A filtered dataframe.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame,\n    column_name='',\n    conditions: List[Any] = None\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.categorical_filter.create_categorical_filter", "modulename": "src.fairreckitlib.data.filter.categorical_filter", "qualname": "create_categorical_filter", "type": "function", "doc": "<p>Create an instance of the class CategoricalFilter.</p>\n\n<p>Args:\n    name: Name of the filter.\n    params: Configuration file.\n    **kwargs: Contains dataset and matrix_name.</p>\n\n<p>Returns:\n    An instance of the CategoricalFilter class.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.data.filter.base_filter.DataFilter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.count_filter", "modulename": "src.fairreckitlib.data.filter.count_filter", "type": "module", "doc": "<p>Module to filter on count threshold. Can be used to filter on countries with many users.</p>\n\n<p>Classes:</p>\n\n<pre><code>CountFilter: Filter the dataframe on a column, such as country.\n    Show only those above a certain threshold.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_count_filter: Create an instance of CountFilter.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.count_filter.CountFilter", "modulename": "src.fairreckitlib.data.filter.count_filter", "qualname": "CountFilter", "type": "class", "doc": "<p>Filter the dataframe on a column, and select only whose count is above a given threshold.</p>\n\n<p>Public method:\n    filter</p>\n", "bases": "src.fairreckitlib.data.filter.base_filter.DataFilter"}, {"fullname": "src.fairreckitlib.data.filter.count_filter.CountFilter.get_type", "modulename": "src.fairreckitlib.data.filter.count_filter", "qualname": "CountFilter.get_type", "type": "function", "doc": "<p>Get the type of the filter.</p>\n\n<p>Returns:\n    The type name of the filter.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.count_filter.CountFilter.filter", "modulename": "src.fairreckitlib.data.filter.count_filter", "qualname": "CountFilter.filter", "type": "function", "doc": "<p>Filter out the values in column_name which count is below threshold.</p>\n\n<p>Args:\n    dataframe: Dataframe to be filtered.\n    column_name: Name of the column.\n    threshold:\n        Values above or equal to the threshold will be included in the resulting dataframe.</p>\n\n<p>Returns:\n    A filtered dataframe.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame,\n    column_name: str = '',\n    threshold: int = 1\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.count_filter.create_count_filter", "modulename": "src.fairreckitlib.data.filter.count_filter", "qualname": "create_count_filter", "type": "function", "doc": "<p>Create an instance of the class CountFilter.</p>\n\n<p>Args:\n    name: Name of the filter.\n    params: Configuration file.\n    **kwargs: Contains dataset and matrix_name.</p>\n\n<p>Returns:\n    An instance of the CountFilter class.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.data.filter.count_filter.CountFilter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_config", "modulename": "src.fairreckitlib.data.filter.filter_config", "type": "module", "doc": "<p>This module contains the subgroup/filter configurations.</p>\n\n<p>Classes:</p>\n\n<pre><code>FilterConfig: data filter configuration.\nFilterPassConfig: data filter pass configuration consisting of multiple filters.\nDataSubsetConfig: data subset configuration consisting of multiple filter passes.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_config.FilterConfig", "modulename": "src.fairreckitlib.data.filter.filter_config", "qualname": "FilterConfig", "type": "class", "doc": "<p>Filter Configuration.</p>\n\n<p>name: the name of the filter.\nparams: the parameters of the filter.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.data.filter.filter_config.FilterConfig.__init__", "modulename": "src.fairreckitlib.data.filter.filter_config", "qualname": "FilterConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_config.FilterPassConfig", "modulename": "src.fairreckitlib.data.filter.filter_config", "qualname": "FilterPassConfig", "type": "class", "doc": "<p>Filter Pass Configuration.</p>\n\n<p>The pass consists of multiple filters that are applied in order.</p>\n\n<p>filters: list of filter configurations.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.filter.filter_config.FilterPassConfig.__init__", "modulename": "src.fairreckitlib.data.filter.filter_config", "qualname": "FilterPassConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    filters: List[src.fairreckitlib.data.filter.filter_config.FilterConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_config.FilterPassConfig.to_yml_format", "modulename": "src.fairreckitlib.data.filter.filter_config", "qualname": "FilterPassConfig.to_yml_format", "type": "function", "doc": "<p>Format filter pass configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the subgroup configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_config.DataSubsetConfig", "modulename": "src.fairreckitlib.data.filter.filter_config", "qualname": "DataSubsetConfig", "type": "class", "doc": "<p>Data Subset Configuration.</p>\n\n<p>The subset of the data consists of multiple filter passes that are applied\non the dataset individually, and thereafter they are merged to create the subset.</p>\n\n<p>dataset: the name of the dataset.\nmatrix: the name of the dataset matrix.\nfilter_passes: the subset as a list of filter passes.</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_config.DataSubsetConfig.__init__", "modulename": "src.fairreckitlib.data.filter.filter_config", "qualname": "DataSubsetConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    dataset: str,\n    matrix: str,\n    filter_passes: List[src.fairreckitlib.data.filter.filter_config.FilterPassConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_config.DataSubsetConfig.to_yml_format", "modulename": "src.fairreckitlib.data.filter.filter_config", "qualname": "DataSubsetConfig.to_yml_format", "type": "function", "doc": "<p>Format data subset configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_config_parsing", "modulename": "src.fairreckitlib.data.filter.filter_config_parsing", "type": "module", "doc": "<p>This module contains parsers for the data subgroup/filter configurations.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_data_subset_config: parse data subset configuration with multiple filter passes.\nparse_data_filter_passes: parse multiple filter pass configurations.\nparse_data_filter_pass_config: parse data filter pass configuration to multiple filters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_config_parsing.parse_data_subset_config", "modulename": "src.fairreckitlib.data.filter.filter_config_parsing", "qualname": "parse_data_subset_config", "type": "function", "doc": "<p>Parse a data subset configuration.</p>\n\n<p>Args:\n    data_subset_config: the data subset configuration.\n    data_registry: the data registry containing the available datasets.\n    data_filter_factory: factory with available dataset-matrix filter factories.\n    event_dispatcher: to dispatch the parse event on failure.\n    data_parent_name: the data parent name related to the data subset.\n    required: whether parsing the subset is required to succeed.</p>\n\n<p>Returns:\n    parsed_config: the parsed configuration or None on failure.\n    dataset_name: the name of the parsed dataset or None on failure.</p>\n", "signature": "(\n    data_subset_config: Dict[str, Any],\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    data_filter_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    data_parent_name: str = None,\n    required: bool = True\n) -> Union[Tuple[src.fairreckitlib.data.filter.filter_config.DataSubsetConfig, str], Tuple[NoneType, NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_config_parsing.parse_data_filter_passes", "modulename": "src.fairreckitlib.data.filter.filter_config_parsing", "qualname": "parse_data_filter_passes", "type": "function", "doc": "<p>Parse a list of filter pass configurations.</p>\n\n<p>Args:\n    data_parent_name: the parent name related to the filter passes that are being parsed.\n    data_parent_config: the parent configuration to parse the filter passes from.\n    dataset_pair: a pair consisting of the dataset and the matrix name.\n    filter_factory: the filter factory containing available filters for the dataset.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a list of parsed subgroup configurations.</p>\n", "signature": "(\n    data_parent_name: str,\n    data_parent_config: Dict[str, Any],\n    dataset_pair: Tuple[src.fairreckitlib.data.set.dataset.Dataset, str],\n    filter_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> List[src.fairreckitlib.data.filter.filter_config.FilterPassConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_config_parsing.parse_data_filter_pass_config", "modulename": "src.fairreckitlib.data.filter.filter_config_parsing", "qualname": "parse_data_filter_pass_config", "type": "function", "doc": "<p>Parse data filter pass configuration to multiple filters.</p>\n\n<p>Args:\n    parent_filter_name: the filter parent name related to the filter pass that is being parsed.\n    filter_pass_config: the filter pass configuration to parse.\n    dataset_pair: a pair consisting of the dataset and the matrix name.\n    filter_factory: the filter factory containing available filters for the dataset.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    parent_filter_name: str,\n    filter_pass_config: Any,\n    dataset_pair: Tuple[src.fairreckitlib.data.set.dataset.Dataset, str],\n    filter_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[src.fairreckitlib.data.filter.filter_config.FilterPassConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_constants", "modulename": "src.fairreckitlib.data.filter.filter_constants", "type": "module", "doc": "<p>This module contains filtering constants that are used in other modules.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_DATA_SUBSET: key that is used to identify a data subset.\nKEY_DATA_FILTER_PASS: key that is used to identify a data filter pass.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_constants.deduce_filter_type", "modulename": "src.fairreckitlib.data.filter.filter_constants", "qualname": "deduce_filter_type", "type": "function", "doc": "<p>Get filter type ('numerical', 'categorical', 'count') from Configuration params.</p>\n\n<p>Args:\n    params: Configuration parameters.</p>\n\n<p>Return:\n    Either 'numerical', 'categorical' or 'count'. Default 'categorical'</p>\n", "signature": "(params: Dict[str, Any]) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_event", "modulename": "src.fairreckitlib.data.filter.filter_event", "type": "module", "doc": "<p>This module contains event args and a print function for a filter event.</p>\n\n<p>Classes:</p>\n\n<pre><code>FilterDataframeEventArgs: event args related to filtering a dataframe.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>print_filter_event_args: print filter event arguments.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_event.FilterDataframeEventArgs", "modulename": "src.fairreckitlib.data.filter.filter_event", "qualname": "FilterDataframeEventArgs", "type": "class", "doc": "<p>Filter Dataframe Event Arguments.</p>\n\n<p>message: the message describing the parsing failure.\nsubset: the subset that is created from the dataframe.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.filter.filter_event.FilterDataframeEventArgs.__init__", "modulename": "src.fairreckitlib.data.filter.filter_event", "qualname": "FilterDataframeEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    subset: src.fairreckitlib.data.filter.filter_config.DataSubsetConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_event.print_filter_event_args", "modulename": "src.fairreckitlib.data.filter.filter_event", "qualname": "print_filter_event_args", "type": "function", "doc": "<p>Print filter dataframe event arguments.</p>\n\n<p>It is assumed that the event started when elapsed_time is None and is finished otherwise.</p>\n\n<p>Args:\n    event_args: the arguments to print.\n    elapsed_time: the time that has passed since the filtering started, expressed in seconds.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.data.filter.filter_event.FilterDataframeEventArgs,\n    elapsed_time: float = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_factory", "modulename": "src.fairreckitlib.data.filter.filter_factory", "type": "module", "doc": "<p>This module combines all three types of filters into a factory.</p>\n\n<p>Functions:\n    create_filter_factory: Creates a factory of three filter objects.</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_factory.create_filter_factory", "modulename": "src.fairreckitlib.data.filter.filter_factory", "qualname": "create_filter_factory", "type": "function", "doc": "<p>Create the dataframe filter factory.</p>\n\n<p>Args:</p>\n\n<pre><code>data_registry: the data registry with available datasets.\n</code></pre>\n\n<p>Returns:\n    the factory with all available filters.</p>\n", "signature": "(\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry\n) -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_params", "modulename": "src.fairreckitlib.data.filter.filter_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for filters.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_params_numerical: TODO\ncreate_params_categorical: TODO\ncreate_params_count: TODO\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_params.create_params_numerical", "modulename": "src.fairreckitlib.data.filter.filter_params", "qualname": "create_params_numerical", "type": "function", "doc": "<p>Create the parameters of a numerical filter.</p>\n\n<p>Keyword Args:\n    column_name(str): the name of the column that has numerical values.\n    dataset(Dataset): the dataset associated with the filter.\n    matrix_name(str): the matrix name related to the dataset.</p>\n\n<p>Returns:\n    the configuration parameters of the numerical filter.</p>\n", "signature": "(\n    **kwargs\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_params.create_params_categorical", "modulename": "src.fairreckitlib.data.filter.filter_params", "qualname": "create_params_categorical", "type": "function", "doc": "<p>Create the parameters of a categorical filter.</p>\n\n<p>Keyword Args:\n    column_name(str): the name of the column that has categorical values.\n    dataset(Dataset): the dataset associated with the filter.\n    matrix_name(str): the matrix name related to the dataset.</p>\n\n<p>Returns:\n    the configuration parameters of the categorical filter.</p>\n", "signature": "(\n    **kwargs\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_params.create_params_count", "modulename": "src.fairreckitlib.data.filter.filter_params", "qualname": "create_params_count", "type": "function", "doc": "<p>Create the parameters of a count filter.</p>\n\n<p>Returns:\n    the configuration parameters of the count filter.</p>\n", "signature": "(**_) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_passes", "modulename": "src.fairreckitlib.data.filter.filter_passes", "type": "module", "doc": "<p>This module contains a function that performs filtering from filter passes.</p>\n\n<p>Functions:\n    filter_from_filter_passes: Apply filter to filter passes.</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_passes.filter_from_filter_passes", "modulename": "src.fairreckitlib.data.filter.filter_passes", "qualname": "filter_from_filter_passes", "type": "function", "doc": "<p>Apply filter to filter passes inside DataSubsetConfig.</p>\n\n<p>For each filter pass, a filtered dataframe is returned. After which the dataframes\nare appended to each other and returned.</p>\n\n<p>Args:\n    core_pipeline: Pipeline where this function is used. Required for IO actions.\n    output_dir: Directory to write temp dataframes to.\n    dataframe: Dataframe to be filtered.\n    subset: Configuration file containing filter passes.\n    filter_factory: Factory containing filters.</p>\n\n<p>Returns:\n    An aggregation of filtered dataframes.</p>\n", "signature": "(\n    core_pipeline: src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline,\n    output_dir: str,\n    dataframe: pandas.core.frame.DataFrame,\n    subset: src.fairreckitlib.data.filter.filter_config.DataSubsetConfig,\n    filter_factory: src.fairreckitlib.core.config.config_factories.GroupFactory\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.numerical_filter", "modulename": "src.fairreckitlib.data.filter.numerical_filter", "type": "module", "doc": "<p>Module to filter on numerical data, like age or rating.</p>\n\n<p>Classes:</p>\n\n<pre><code>NumericalFilter: Filter the dataframe on numerical data, such as age or rating.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_numerical_filter: Create an instance of NumericalFilter.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.numerical_filter.NumericalFilter", "modulename": "src.fairreckitlib.data.filter.numerical_filter", "qualname": "NumericalFilter", "type": "class", "doc": "<p>Filters the dataframe on numerical data, such as age or rating.</p>\n\n<p>Public method:\n    filter</p>\n", "bases": "src.fairreckitlib.data.filter.base_filter.DataFilter"}, {"fullname": "src.fairreckitlib.data.filter.numerical_filter.NumericalFilter.get_type", "modulename": "src.fairreckitlib.data.filter.numerical_filter", "qualname": "NumericalFilter.get_type", "type": "function", "doc": "<p>Get the type of the filter.</p>\n\n<p>Returns:\n    The type name of the filter.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.numerical_filter.NumericalFilter.filter", "modulename": "src.fairreckitlib.data.filter.numerical_filter", "qualname": "NumericalFilter.filter", "type": "function", "doc": "<p>Filter the dataframe on values in the range of min_val and max_val.</p>\n\n<p>Args:\n    dataframe: Dataframe to be filtered on.\n    column_name (str): Name of the column where the conditions need to be met.\n    min_val (int | float): Minimal number (default 0).\n    max_val (int | float): Maximum number (default infinite).</p>\n\n<p>Returns:\n    A filtered dataframe.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame,\n    column_name='',\n    min_val=0,\n    max_val=inf\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.numerical_filter.create_numerical_filter", "modulename": "src.fairreckitlib.data.filter.numerical_filter", "qualname": "create_numerical_filter", "type": "function", "doc": "<p>Create an instance of the class NumericalFilter.</p>\n\n<p>Args:\n    name: Name of the filter.\n    params: Configuration file.\n    **kwargs: Contains dataset and matrix_name.</p>\n\n<p>Returns:\n    An instance of the NumericalFilter class.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.data.filter.base_filter.DataFilter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline", "modulename": "src.fairreckitlib.data.pipeline", "type": "module", "doc": "<p>This package contains functionality for running the data pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>data_config: dataset configuration class.\ndata_config_parsing: parse dataset configuration.\ndata_event: event ids, event args and a print switch for the data pipeline.\ndata_pipeline: the data pipeline class.\ndata_run: run (multiple) data pipelines.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config", "modulename": "src.fairreckitlib.data.pipeline.data_config", "type": "module", "doc": "<p>This module contains the dataset configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetConfig: dataset configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig", "modulename": "src.fairreckitlib.data.pipeline.data_config", "qualname": "DataMatrixConfig", "type": "class", "doc": "<p>Data Matrix Configuration.</p>\n\n<p>dataset: the name of the dataset.\nmatrix: the name of the dataset matrix.\nfilter_passes: the subset of the dataset matrix as a list of filter passes.\nconverter: the rating converter of the dataset matrix.\nsplitting: the train/test splitter of the dataset matrix.</p>\n", "bases": "src.fairreckitlib.data.filter.filter_config.DataSubsetConfig"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_config", "qualname": "DataMatrixConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    dataset: str,\n    matrix: str,\n    filter_passes: List[src.fairreckitlib.data.filter.filter_config.FilterPassConfig],\n    converter: Optional[src.fairreckitlib.data.ratings.convert_config.ConvertConfig],\n    splitting: src.fairreckitlib.data.split.split_config.SplitConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig.get_data_matrix_name", "modulename": "src.fairreckitlib.data.pipeline.data_config", "qualname": "DataMatrixConfig.get_data_matrix_name", "type": "function", "doc": "<p>Get the combined dataset and matrix name of the configuration.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig.to_yml_format", "modulename": "src.fairreckitlib.data.pipeline.data_config", "qualname": "DataMatrixConfig.to_yml_format", "type": "function", "doc": "<p>Format data matrix configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config_parsing", "modulename": "src.fairreckitlib.data.pipeline.data_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the dataset configuration.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_data_config: parse dataset matrices from the experiment configuration.\nparse_data_matrix_config: parse dataset matrix configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config_parsing.parse_data_config", "modulename": "src.fairreckitlib.data.pipeline.data_config_parsing", "qualname": "parse_data_config", "type": "function", "doc": "<p>Parse all dataset configurations.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.\n    data_registry: the data registry containing the available datasets.\n    data_factory: factory with available data modifier factories.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a list of parsed DatasetConfig's or None when empty.</p>\n", "signature": "(\n    experiment_config: Dict[str, Any],\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    data_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[List[src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config_parsing.parse_data_matrix_config", "modulename": "src.fairreckitlib.data.pipeline.data_config_parsing", "qualname": "parse_data_matrix_config", "type": "function", "doc": "<p>Parse a data matrix configuration.</p>\n\n<p>Args:\n    data_matrix_config: the data matrix configuration.\n    data_registry: the data registry containing the available datasets.\n    data_factory: factory with available data modifier factories.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    parsed_config: the parsed configuration or None on failure.\n    dataset_name: the name of the parsed dataset or None on failure.</p>\n", "signature": "(\n    data_matrix_config: Any,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    data_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Union[Tuple[src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig, str], Tuple[NoneType, NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event", "modulename": "src.fairreckitlib.data.pipeline.data_event", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch for the data pipeline.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_BEGIN_DATA_PIPELINE: id of the event that is used when the data pipeline starts.\nON_BEGIN_FILTER_DATASET: id of the event that is used when dataset filtering starts.\nON_BEGIN_LOAD_DATASET: id of the event that is used when a dataset is being loaded.\nON_BEGIN_MODIFY_DATASET: id of the event that is used when dataset ratings are being modified.\nON_BEGIN_SAVE_SETS: id of the event that is used when the train and test sets are being saved.\nON_BEGIN_SPLIT_DATASET: id of the event that is used when a dataset is being split.\nON_END_DATA_PIPELINE: id of the event that is used when the data pipeline ends.\nON_END_FILTER_DATASET: id of the event that is used when dataset filtering finishes.\nON_END_LOAD_DATASET: id of the event that is used when a dataset has been loaded.\nON_END_MODIFY_DATASET: id of the event that is used when dataset ratings have been modified.\nON_END_SAVE_SETS: id of the event that is used when the train and test sets have been saved.\nON_END_SPLIT_DATASET: id of the event that is used when a dataset has been split.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>DatasetEventArgs: event args related to a dataset.\nDatasetMatrixEventArgs: event args related to a dataset matrix.\nSaveSetsEventArgs: event args related to saving a train and test set.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_data_events: list of data pipeline event IDs.\nget_data_event_print_switch: switch to print data pipeline event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.DatasetEventArgs", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "DatasetEventArgs", "type": "class", "doc": "<p>Dataset Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the dataset event.\ndataset_name: the name of the dataset.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.DatasetEventArgs.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "DatasetEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, dataset_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.DatasetMatrixEventArgs", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "DatasetMatrixEventArgs", "type": "class", "doc": "<p>Dataset Matrix Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the dataset matrix event.\ndataset_name: the name of the dataset.\nmatrix_name: the name of the dataset matrix.\nmatrix_file_path: the path to the file of the dataset matrix.</p>\n", "bases": "DatasetEventArgs"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.DatasetMatrixEventArgs.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "DatasetMatrixEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    dataset_name: str,\n    matrix_name: str,\n    matrix_file_path: str\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.SaveSetsEventArgs", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "SaveSetsEventArgs", "type": "class", "doc": "<p>Save Sets Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the save sets event.\ntrain_set_path: the path to the file of the train set.\ntest_set_path: the path to the file of the test set.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.SaveSetsEventArgs.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "SaveSetsEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, train_set_path: str, test_set_path: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.get_data_events", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "get_data_events", "type": "function", "doc": "<p>Get a list of data pipeline event IDs.</p>\n\n<p>Returns:\n    a list of unique data pipeline event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.get_data_event_print_switch", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "get_data_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints data pipeline event IDs.</p>\n\n<p>Returns:\n    the print data pipeline event switch.</p>\n", "signature": "(\n    elapsed_time: float = None\n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "type": "module", "doc": "<p>This module contains functionality of the complete data pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataPipeline: class that performs dataset operations in preparation for the model pipeline.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline", "type": "class", "doc": "<p>Data Pipeline to prepare a dataset for a transition to the ModelPipeline(s).</p>\n\n<p>The pipeline is intended to be reused multiple times depending on the specified\ndatasets. This is not limited to using a dataset only once as they are numbered\ninternally to distinguish them later.\nFor each dataset the following steps are performed in order:</p>\n\n<p>1) create output directory.\n2) load the dataset into a dataframe.\n3) filter rows based on 'user'/'item' columns. (optional)\n4) convert 'rating' column. (optional)\n5) split the dataframe into a train and test set.\n6) save the train and test set in the output directory.</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n", "bases": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.__init__", "type": "function", "doc": "<p>Construct the DataPipeline.</p>\n\n<p>Args:\n    data_factory: the factory with available data modifier factories.\n    event_dispatcher: used to dispatch data/IO events when running the pipeline.</p>\n", "signature": "(\n    self,\n    data_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.run", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.run", "type": "function", "doc": "<p>Run the entire data pipeline from beginning to end.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    dataset: the dataset to run the pipeline on.\n    data_config: the dataset matrix configurations.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Raises:\n    FileNotFoundError: when the dataset matrix file does not exist.\n    IOError: when the specified output directory does not exist.\n    RuntimeError: when any data modifiers are not found in their respective factories.</p>\n\n<p>Returns:\n    the data transition output of the pipeline.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    data_config: src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig,\n    is_running: Callable[[], bool]\n) -> Optional[src.fairreckitlib.data.data_transition.DataTransition]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.create_data_output_dir", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.create_data_output_dir", "type": "function", "doc": "<p>Create the data output directory for a dataset.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    data_config: the dataset matrix configuration to create a directory for.</p>\n\n<p>Returns:\n    the path of the directory where the output data can be stored.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_config: src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig\n) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.load_from_dataset", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.load_from_dataset", "type": "function", "doc": "<p>Load in the desired dataset matrix into a dataframe.</p>\n\n<p>The loaded dataframe contains at least three columns 'user', 'item', 'rating'.\nIn addition, the 'timestamp' column can be present when available in the specified dataset.</p>\n\n<p>Args:\n    dataset: the dataset to load a matrix dataframe from.\n    matrix_name: the name of the matrix to load from the dataset.</p>\n\n<p>Raises:\n    FileNotFoundError: when the dataset matrix file does not exist.</p>\n\n<p>Returns:\n    the dataframe belonging to the specified dataset.</p>\n", "signature": "(\n    self,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.filter_rows", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.filter_rows", "type": "function", "doc": "<p>Apply the specified subset filters to the dataframe.</p>\n\n<p>The subset is created by applying multiple filter passes to the dataframe individually.\nThese filter passes are then combined to form the resulting dataframe.</p>\n\n<p>Args:\n    dataframe: the dataframe to filter with at least two columns: 'user', 'item'.\n    subset: the subset to create of to the dataframe.</p>\n\n<p>Returns:\n    the dataframe with the specified subgroup filters applied to it.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    dataframe: pandas.core.frame.DataFrame,\n    subset: src.fairreckitlib.data.filter.filter_config.DataSubsetConfig\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.convert_ratings", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.convert_ratings", "type": "function", "doc": "<p>Convert the ratings in the dataframe with the specified rating modifier.</p>\n\n<p>Args:\n    dataset: the dataset to load the matrix and rating_type from.\n    matrix_name: the name of the dataset matrix.\n    dataframe: the dataframe to convert the ratings of.\n        At the least a 'rating' column is expected to be present.\n    convert_config: the configuration of the converter to apply to the 'rating' column.</p>\n\n<p>Raises:\n    RuntimeError: when the converter specified by the configuration is not available.</p>\n\n<p>Returns:\n    the converted dataframe or the input dataframe when no converter is specified.</p>\n", "signature": "(\n    self,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    dataframe: pandas.core.frame.DataFrame,\n    convert_config: src.fairreckitlib.data.ratings.convert_config.ConvertConfig\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.split", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.split", "type": "function", "doc": "<p>Split the dataframe into a train and test set.</p>\n\n<p>This will be split 80/20 (or a similar ratio), and be done either random, or timestamp-wise.\nThe dataframe is expected to have at least three columns: 'user', 'item', 'rating'.\nIn addition, the 'timestamp' column is required for temporal splits.</p>\n\n<p>Args:\n    dataframe: the dataframe to split into a train and test set.\n    split_config: the dataset splitting configuration.</p>\n\n<p>Raises:\n    RuntimeError: when the splitter specified by the configuration is not available.</p>\n\n<p>Returns:\n    the train and test set split of the specified dataframe.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame,\n    split_config: src.fairreckitlib.data.split.split_config.SplitConfig\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.save_sets", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.save_sets", "type": "function", "doc": "<p>Save the train and test sets to the desired output directory.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store both sets.\n    train_set: the train set to save with at least three columns: 'user', 'item', 'rating'.\n    test_set: the test set to save with at least three columns: 'user', 'item', 'rating'.</p>\n\n<p>Returns:\n    the paths where the train and test set are stored.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    train_set: pandas.core.frame.DataFrame,\n    test_set: pandas.core.frame.DataFrame\n) -> Tuple[str, str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_run", "modulename": "src.fairreckitlib.data.pipeline.data_run", "type": "module", "doc": "<p>This module contains functionality to run the data pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataPipelineConfig: configuration class to run the data pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>run_data_pipelines: run the pipeline using dataset configurations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_run.DataPipelineConfig", "modulename": "src.fairreckitlib.data.pipeline.data_run", "qualname": "DataPipelineConfig", "type": "class", "doc": "<p>Data Pipeline Configuration.</p>\n\n<p>output_dir: the directory to store the output.\ndata_registry: the registry with available datasets.\ndata_factory: the factory with available data modifier factories.\ndata_config_list: the dataset matrix configurations to compute.</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_run.DataPipelineConfig.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_run", "qualname": "DataPipelineConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    data_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    data_config_list: List[src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_run.run_data_pipelines", "modulename": "src.fairreckitlib.data.pipeline.data_run", "qualname": "run_data_pipelines", "type": "function", "doc": "<p>Run a Data Pipeline several times according to the specified data pipeline configuration.</p>\n\n<p>Args:\n    pipeline_config: the configuration on how to run the data pipelines.\n    event_dispatcher: used to dispatch data/IO events when running the pipeline.\n    is_running: function that returns whether the pipelines\n        are still running. Stops early when False is returned.</p>\n\n<p>Returns:\n    a list of DataTransition's.</p>\n", "signature": "(\n    pipeline_config: src.fairreckitlib.data.pipeline.data_run.DataPipelineConfig,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    is_running: Callable[[], bool]\n) -> List[src.fairreckitlib.data.data_transition.DataTransition]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings", "modulename": "src.fairreckitlib.data.ratings", "type": "module", "doc": "<p>This package contains functionality to convert ratings in a dataframe.</p>\n\n<p>Modules:</p>\n\n<pre><code>base_converter: base class for converting ratings.\nconvert_config: converter configuration class.\nconvert_config_parsing: parse converter configuration.\nconvert_constants: constants to be used in other modules.\nconvert_event: event args and a print function for a converter event.\ncount: count apc/alc.\nkl_converter: class for converting with kullback-leibler.\nrange_converter: class for converting with a scalar.\nrating_converter_factory: create converter factory with available rating converters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.base_converter", "modulename": "src.fairreckitlib.data.ratings.base_converter", "type": "module", "doc": "<p>This module contains the base class for converting ratings.</p>\n\n<p>Classes:</p>\n\n<pre><code>RatingConverter: the base class for converting ratings.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.base_converter.RatingConverter", "modulename": "src.fairreckitlib.data.ratings.base_converter", "qualname": "RatingConverter", "type": "class", "doc": "<p>Base class for FairRecKit rating converters.</p>\n\n<p>A converter is used to convert ratings of a dataframe.</p>\n", "bases": "src.fairreckitlib.data.data_modifier.DataModifier"}, {"fullname": "src.fairreckitlib.data.ratings.base_converter.RatingConverter.__init__", "modulename": "src.fairreckitlib.data.ratings.base_converter", "qualname": "RatingConverter.__init__", "type": "function", "doc": "<p>Construct the Rating Converter.</p>\n\n<p>Args:\n    name: the name of the converter.\n    params: the converter parameters.</p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.base_converter.RatingConverter.run", "modulename": "src.fairreckitlib.data.ratings.base_converter", "qualname": "RatingConverter.run", "type": "function", "doc": "<p>Run the converter on the specified dataframe.</p>\n\n<p>Args:\n    dataframe: with at least the 'rating' column.</p>\n\n<p>Returns:\n    the converted dataframe and the type of rating, either 'explicit' or 'implicit'.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config", "modulename": "src.fairreckitlib.data.ratings.convert_config", "type": "module", "doc": "<p>This module contains the convert configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConvertConfig: convert configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config.ConvertConfig", "modulename": "src.fairreckitlib.data.ratings.convert_config", "qualname": "ConvertConfig", "type": "class", "doc": "<p>Dataset rating conversion Configuration.</p>\n\n<p>name: the name of the rating converter.\nparams: the parameters of the rating converter.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config.ConvertConfig.__init__", "modulename": "src.fairreckitlib.data.ratings.convert_config", "qualname": "ConvertConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config_parsing", "modulename": "src.fairreckitlib.data.ratings.convert_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the dataset rating conversion configuration.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_data_convert_config: parse convert configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config_parsing.parse_data_convert_config", "modulename": "src.fairreckitlib.data.ratings.convert_config_parsing", "qualname": "parse_data_convert_config", "type": "function", "doc": "<p>Parse a dataset rating converter configuration.</p>\n\n<p>Args:\n    dataset_config: the dataset's total configuration.\n    dataset: the dataset related to the converter configuration.\n    matrix_name: the dataset's matrix name to use.\n    converter_factory: the converter factory containing available converters.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    dataset_config: Dict[str, Any],\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    converter_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[src.fairreckitlib.data.ratings.convert_config.ConvertConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.convert_constants", "modulename": "src.fairreckitlib.data.ratings.convert_constants", "type": "module", "doc": "<p>This module contains rating conversion constants that are used in other modules.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_RATING_CONVERTER: key that is used to identify rating converters.\nCONVERTER_RANGE: name of the range converter.\nCONVERTER_KL: name of the kl converter.\nRATING_TYPE_THRESHOLD: determines if the rating is assumed to be explicit or implicit.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.convert_event", "modulename": "src.fairreckitlib.data.ratings.convert_event", "type": "module", "doc": "<p>This module contains event args and a print function for a rating conversion event.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConvertRatingsEventArgs: event args related to converting dataframe ratings.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>print_convert_event_args: print rating conversion event arguments.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.convert_event.ConvertRatingsEventArgs", "modulename": "src.fairreckitlib.data.ratings.convert_event", "qualname": "ConvertRatingsEventArgs", "type": "class", "doc": "<p>Convert Ratings Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the rating conversion event.\nconvert_config: the rating conversion configuration that is used.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.ratings.convert_event.ConvertRatingsEventArgs.__init__", "modulename": "src.fairreckitlib.data.ratings.convert_event", "qualname": "ConvertRatingsEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    convert_config: src.fairreckitlib.data.ratings.convert_config.ConvertConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.convert_event.print_convert_event_args", "modulename": "src.fairreckitlib.data.ratings.convert_event", "qualname": "print_convert_event_args", "type": "function", "doc": "<p>Print convert ratings event arguments.</p>\n\n<p>It is assumed that the event started when elapsed_time is None and is finished otherwise.</p>\n\n<p>Args:\n    event_args: the arguments to print.\n    elapsed_time: the time that has passed since the conversion started, expressed in seconds.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.data.ratings.convert_event.ConvertRatingsEventArgs,\n    elapsed_time: float = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.count", "modulename": "src.fairreckitlib.data.ratings.count", "type": "module", "doc": "<p>This module contains counting functionality.</p>\n\n<p>Both APC and ALC can be used in the Kullback-Leibler formula,\nfor which the module is also in this package.\nAs of now, they don't specifically count the 'artist'\nplay and listen count, but just whatever is in the 'item' column.\nIf you pass a dataframe for which the 'item' column contains artists,\nit should work correctly, otherwise it will require changes to work properly.</p>\n\n<p>Functions:</p>\n\n<pre><code>get_item_dict: return dict with unique items.\ncalculate_apc: count the artist play count.\ncalculate_alc: count the artist listener count.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.count.get_item_dict", "modulename": "src.fairreckitlib.data.ratings.count", "qualname": "get_item_dict", "type": "function", "doc": "<p>Make a dict with all unique items from the dataframe and starting value 0.</p>\n\n<p>Args:\n    dataframe: the dataframe from which the items are taken.</p>\n\n<p>Returns:\n    a dictionary with unique items as keys and 0 as values.</p>\n", "signature": "(dataframe: pandas.core.frame.DataFrame) -> Dict[int, float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.count.calculate_apc", "modulename": "src.fairreckitlib.data.ratings.count", "qualname": "calculate_apc", "type": "function", "doc": "<p>Sum up the total artist play count (apc).</p>\n\n<p>Used in the Kullback-Leibler formula for converting ratings.</p>\n\n<p>Args:\n    dataframe with an item and rating header.</p>\n\n<p>Returns:\n    a dictionary with key:item, value:apc.</p>\n", "signature": "(dataframe: pandas.core.frame.DataFrame) -> Dict[int, float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.count.calculate_alc", "modulename": "src.fairreckitlib.data.ratings.count", "qualname": "calculate_alc", "type": "function", "doc": "<p>Sum up the total artist listener count (alc).</p>\n\n<p>Used in the Kullback-Leibler formula for converting ratings.</p>\n\n<p>Args:\n    dataframe with an item and rating header.</p>\n\n<p>Returns:\n    a dictionary with key:item, value:alc.</p>\n", "signature": "(dataframe: pandas.core.frame.DataFrame) -> Dict[int, float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "type": "module", "doc": "<p>This module contains the Kullback-Leibler converter.</p>\n\n<p>This way of converting is not implemented in the data pipeline.\nThe intended use of this stems from the following paper about mainstreaminess:</p>\n\n<p>https://www.christinebauer.eu/publications/bauer-2019-plosone-mainstreaminess/</p>\n\n<p>see pages 10-11.</p>\n\n<p>This paper describes an altered version of the Kullback-Leibler formla\nand converts implicit ratings to explicit ratings in the range [0,1].</p>\n\n<p>Classes:</p>\n\n<pre><code>KLConverter: can convert ratings using the Kullback-Leibler formula.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_kl_converter: create an instance of the class (factory creation compatible).\ncreate_kl_converter_params: create kl converter config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter.KLConverter", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "qualname": "KLConverter", "type": "class", "doc": "<p>Kullback-Leibler Converter on data ratings.</p>\n\n<p>Applies the Kullback-Leibler formula to the rating column of the dataframe.</p>\n", "bases": "src.fairreckitlib.data.ratings.base_converter.RatingConverter"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter.KLConverter.run", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "qualname": "KLConverter.run", "type": "function", "doc": "<p>Apply the Kullback-Leibler formula to convert ratings.</p>\n\n<p>Args:\n    dataframe: with 'user', 'item' and 'rating' columns.</p>\n\n<p>Returns:\n    the converted dataframe.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter.create_kl_converter", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "qualname": "create_kl_converter", "type": "function", "doc": "<p>Create the KL Converter.</p>\n\n<p>Args:\n    name: the name of the converter.\n    params: containing the following name-value pairs:\n        method(str): the method to apply, either 'APC' or 'ALC'.</p>\n\n<p>Returns:\n    the data kl converter.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.data.ratings.kl_converter.KLConverter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter.create_kl_converter_params", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "qualname": "create_kl_converter_params", "type": "function", "doc": "<p>Create the parameters of the kl converter.</p>\n\n<p>Returns:\n    the configuration parameters of the converter.</p>\n", "signature": "(**_) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter", "modulename": "src.fairreckitlib.data.ratings.range_converter", "type": "module", "doc": "<p>This module contains the range converting functionality.</p>\n\n<p>Classes:</p>\n\n<pre><code>RangeConverter: can convert ratings to be within in a specified range.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_range_converter: create an instance of the class (factory creation compatible).\ncreate_range_converter_params: create range converter config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter.RangeConverter", "modulename": "src.fairreckitlib.data.ratings.range_converter", "qualname": "RangeConverter", "type": "class", "doc": "<p>Range Converter on data ratings.</p>\n\n<p>Converts the rating column of the dataframe to a specified range.</p>\n", "bases": "src.fairreckitlib.data.ratings.base_converter.RatingConverter"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter.RangeConverter.run", "modulename": "src.fairreckitlib.data.ratings.range_converter", "qualname": "RangeConverter.run", "type": "function", "doc": "<p>Convert ratings in the dataframe.</p>\n\n<p>Takes the max value and divides all values so that\nthey all fall within a range of [0,1], unless another upper\nbound is given by the parameters on creation. The rating can then\nalso be multiplied by a scalar, e.g. when an implicit rating is needed.</p>\n\n<p>Args:\n    dataframe: a df that should contain a 'rating' column.</p>\n\n<p>Returns:\n    the converted dataframe.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter.create_range_converter", "modulename": "src.fairreckitlib.data.ratings.range_converter", "qualname": "create_range_converter", "type": "function", "doc": "<p>Create the Range Converter.</p>\n\n<p>Args:\n    name: the name of the converter.\n    params: containing the following name-value pairs:\n        upper_bound(float): the upper bound of the range restriction.</p>\n\n<p>Returns:\n    the data range converter.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.data.ratings.range_converter.RangeConverter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter.create_range_converter_params", "modulename": "src.fairreckitlib.data.ratings.range_converter", "qualname": "create_range_converter_params", "type": "function", "doc": "<p>Create the parameters of the range converter.</p>\n\n<p>Returns:\n    the configuration parameters of the converter.</p>\n", "signature": "(\n    **kwargs\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.rating_converter_factory", "modulename": "src.fairreckitlib.data.ratings.rating_converter_factory", "type": "module", "doc": "<p>This module contains functionality to create the rating converter factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_rating_converter_factory: create a factory with rating converters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.rating_converter_factory.create_rating_converter_factory", "modulename": "src.fairreckitlib.data.ratings.rating_converter_factory", "qualname": "create_rating_converter_factory", "type": "function", "doc": "<p>Create the rating converter factory.</p>\n\n<p>Args:</p>\n\n<pre><code>data_registry: the data registry with available datasets.\n</code></pre>\n\n<p>Returns:\n    the factory with all available converters.</p>\n", "signature": "(\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry\n) -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set", "modulename": "src.fairreckitlib.data.set", "type": "module", "doc": "<p>This package contains functionality for dataset definitions.</p>\n\n<p>Modules:</p>\n\n<pre><code>dataset: class wrapper for accessing a dataset and related data tables.\ndataset_config: configuration structs that define the matrix/tables.\ndataset_config_parser: parser for a dataset configuration and utility functions.\ndataset_constants: constants to be used in other modules.\ndataset_matrix: functionality to create matrices from dataset event tables.\ndataset_registry: registry for available datasets and processing them into a standard format.\ndataset_sampling: create a sample of an existing dataset.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>processor: dataset processors for various movie/music datasets.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset", "modulename": "src.fairreckitlib.data.set.dataset", "type": "module", "doc": "<p>This module contains a dataset definition for accessing a dataset and related data tables.</p>\n\n<p>Classes:</p>\n\n<pre><code>Dataset: class wrapper of the user events, user-item matrices and related tables.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>add_dataset_columns: add columns from the dataset matrix/user/item tables to a dataframe.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset", "type": "class", "doc": "<p>Wrapper class for a FairRecKit dataset.</p>\n\n<p>A dataset is used for carrying out recommender system experiments.\nEach dataset has a strong affinity with a database structure consisting of\nmultiple tables.\nThe standardized matrix is a pandas.DataFrame stored in a '.tsv' file.\nThe (derived sparse) matrix is used in experiments and needs to be\nin a CSR compatible format, meaning three fields:</p>\n\n<p>1) 'user': IDs range from 0 to the amount of unique users.\n2) 'item': IDs range from 0 to the amount of unique items. An item can be\n    various of things (e.g. an artist, an album, a track, a movie, etc.)\n3) 'rating': floating-point data describing the rating a user has given an item.\n    There are two types of ratings, namely explicit or implicit, and both\n    are expected to be greater than zero.</p>\n\n<p>The matrix has one optional field which is:</p>\n\n<p>4) 'timestamp': when present can be used to split the matrix on temporal basis.</p>\n\n<p>A dataset has two main tables that are connected to the 'user' and 'item' fields.\nIndirection arrays are available when user and/or item IDs do not match up in\ntheir corresponding tables. These two tables can be used in an experiment to\nfilter any rows based on various table header criteria.\nAny additional tables can be added for accessibility/compatibility with the FRK\nrecommender system.</p>\n\n<p>Public methods:</p>\n\n<p>get_available_columns\nget_available_event_tables\nget_available_matrices\nget_available_tables\nget_matrices_info\nget_matrix_config\nget_matrix_file_path\nget_name\nget_table_config\nget_table_info\nload_matrix\nread_matrix\nread_table\nresolve_item_ids\nresolve_user_ids</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.__init__", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.__init__", "type": "function", "doc": "<p>Construct the dataset.</p>\n\n<p>Args:\n    data_dir: directory where the dataset is stored.\n    config: the dataset configuration.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    config: src.fairreckitlib.data.set.dataset_config.DatasetConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_available_columns", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_available_columns", "type": "function", "doc": "<p>Get the available table column names of this dataset.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to get the available columns of.</p>\n\n<p>Returns:\n    a dictionary with table name as keys and column names as values.</p>\n", "signature": "(self, matrix_name: str) -> Dict[str, List[str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_available_event_tables", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_available_event_tables", "type": "function", "doc": "<p>Get the available event table names in the dataset.</p>\n\n<p>Returns:\n    a list of event table names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_available_matrices", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_available_matrices", "type": "function", "doc": "<p>Get the available matrix names in the dataset.</p>\n\n<p>Returns:\n    a list of matrix names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_available_tables", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_available_tables", "type": "function", "doc": "<p>Get the available table names in the dataset.</p>\n\n<p>Returns:\n    a list of table names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_matrices_info", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_matrices_info", "type": "function", "doc": "<p>Get the information on the dataset's available matrices.</p>\n\n<p>Returns:\n    a dictionary containing the matrices' information keyed by matrix name.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_matrix_config", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_matrix_config", "type": "function", "doc": "<p>Get the configuration of a dataset's matrix.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to get the configuration of.</p>\n\n<p>Returns:\n    the configuration of the matrix or None when not available.</p>\n", "signature": "(\n    self,\n    matrix_name: str\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_matrix_file_path", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_matrix_file_path", "type": "function", "doc": "<p>Get the file path where the matrix with the specified name is stored.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to get the file path of.</p>\n\n<p>Returns:\n    the path of the dataset's matrix file or None when not available.</p>\n", "signature": "(self, matrix_name: str) -> Optional[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_name", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_name", "type": "function", "doc": "<p>Get the name of the dataset.</p>\n\n<p>Returns:\n    the dataset name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_table_config", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_table_config", "type": "function", "doc": "<p>Get the configuration of the dataset table with the specified name.</p>\n\n<p>Args:\n    table_name: name of the table to retrieve the configuration of.</p>\n\n<p>Returns:\n    the table configuration or None when not available.</p>\n", "signature": "(\n    self,\n    table_name: str\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_table_info", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_table_info", "type": "function", "doc": "<p>Get the information on the dataset's available tables.</p>\n\n<p>Returns:\n    a dictionary containing the table information keyed by table name.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.load_matrix", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.load_matrix", "type": "function", "doc": "<p>Load the standardized user-item matrix of the dataset.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to load.</p>\n\n<p>Returns:\n    the loaded user-item matrix or None when not available.</p>\n", "signature": "(self, matrix_name: str) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.load_item_indices", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.load_item_indices", "type": "function", "doc": "<p>Load the item indices.</p>\n\n<p>Optional indirection array of the item IDs that do not match up in\nthe corresponding data table.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to load the item indices of.</p>\n\n<p>Raises:\n    KeyError: when the matrix with the specified name does not exist.</p>\n\n<p>Returns:\n    the indirection array or None when not needed.</p>\n", "signature": "(self, matrix_name: str) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.load_user_indices", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.load_user_indices", "type": "function", "doc": "<p>Load the user indices.</p>\n\n<p>Optional indirection array of the user IDs that do not match up in\nthe corresponding data table.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to load the user indices of.</p>\n\n<p>Raises:\n    KeyError: when the matrix with the specified name does not exist.</p>\n\n<p>Returns:\n    the indirection array or None when not needed.</p>\n", "signature": "(self, matrix_name: str) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.read_matrix", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.read_matrix", "type": "function", "doc": "<p>Read the matrix with the specified name from the dataset.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to load.\n    columns: subset list of columns to load or None to load all.\n        All elements must either be integer indices or\n        strings that correspond to the one of the available table columns.\n    chunk_size: reads the matrix in chunks as an iterator or\n        the entire table when None.</p>\n\n<p>Returns:\n    the resulting matrix dataframe (iterator) or None when not available.</p>\n", "signature": "(\n    self,\n    matrix_name: str,\n    columns: List[Union[str, int]] = None,\n    chunk_size: int = None\n) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.read_table", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.read_table", "type": "function", "doc": "<p>Read the table with the specified name from the dataset.</p>\n\n<p>Args:\n    table_name: name of the table to read.\n    columns: subset list of columns to load or None to load all.\n        All elements must either be integer indices or\n        strings that correspond to the one of the available table columns.\n    chunk_size: reads the table in chunks as an iterator or\n        the entire table when None.</p>\n\n<p>Returns:\n    the resulting table dataframe (iterator) or None when not available.</p>\n", "signature": "(\n    self,\n    table_name: str,\n    columns: List[Union[str, int]] = None,\n    chunk_size: int = None\n) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.resolve_item_ids", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.resolve_item_ids", "type": "function", "doc": "<p>Resolve the specified item ID(s).</p>\n\n<p>The item ID(s) of a dataset need to be resolved when it contains\nan indirection array, otherwise ID(s) are returned unchanged.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to resolve the item indices of.\n    items: source ID(s) to convert.</p>\n\n<p>Raises:\n    KeyError: when the matrix with the specified name does not exist.</p>\n\n<p>Returns:\n    the resolved item ID(s).</p>\n", "signature": "(\n    self,\n    matrix_name: str,\n    items: Union[int, List[int]]\n) -> Union[int, List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.resolve_user_ids", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.resolve_user_ids", "type": "function", "doc": "<p>Resolve the specified user ID(s).</p>\n\n<p>The user ID(s) of a dataset need to be resolved when it contains\nan indirection array, otherwise ID(s) are returned unchanged.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to resolve the user indices of.\n    users: source ID(s) to convert.</p>\n\n<p>Raises:\n    KeyError: when the matrix with the specified name does not exist.</p>\n\n<p>Returns:\n    the resolved user ID(s).</p>\n", "signature": "(\n    self,\n    matrix_name: str,\n    users: Union[int, List[int]]\n) -> Union[int, List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.add_dataset_columns", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "add_dataset_columns", "type": "function", "doc": "<p>Add the specified columns from the dataset to the dataframe.</p>\n\n<p>Args:\n    dataset: the set related to the dataframe.\n    matrix_name: the name of the dataset matrix.\n    dataframe: with at least the 'user' and/or 'item' columns.\n    column_names: a list of strings to indicate which\n        user and/or item columns need to be added. Any values that are not\n        present in the dataset tables are ignored.</p>\n\n<p>Returns:\n    the resulting dataframe with the added columns that exist in the dataset.</p>\n", "signature": "(\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    dataframe: pandas.core.frame.DataFrame,\n    column_names: List[str]\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config", "modulename": "src.fairreckitlib.data.set.dataset_config", "type": "module", "doc": "<p>This module contains the dataset configuration classes and creation functions.</p>\n\n<p>Constants:</p>\n\n<pre><code>DATASET_RATINGS_EXPLICIT: dataset matrix with explicit ratings.\nDATASET_RATINGS_IMPLICIT: dataset matrix with implicit ratings.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>DatasetFileConfig: the configuration of a dataset file.\nDatasetTableConfig: the configuration of a dataset table.\nDatasetIndexConfig: the configuration of a dataset matrix' user/item indices.\nDatasetMatrixConfig: the configuration of a dataset matrix.\nDatasetConfig: the configuration of a dataset.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_dataset_table_config: create configuration for a dataset table.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.FileOptionsConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "FileOptionsConfig", "type": "class", "doc": "<p>File Options Configuration.</p>\n\n<p>sep: the separator in the file or None for \\t.\ncompression: the (optional) compression of the file.\nencoding: the encoding of the file or None for 'utf-8'.\nheader: is there a header on the first line of the file.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.FileOptionsConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "FileOptionsConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    sep: Optional[str],\n    compression: Optional[str],\n    encoding: Optional[str],\n    header: bool\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.FileOptionsConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "FileOptionsConfig.to_yml_format", "type": "function", "doc": "<p>Format file settings configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset file configuration.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetFileConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetFileConfig", "type": "class", "doc": "<p>Dataset File Configuration.</p>\n\n<p>name: the file name.\noptions: the file options.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetFileConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetFileConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    options: src.fairreckitlib.data.set.dataset_config.FileOptionsConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetFileConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetFileConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset file configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset file configuration.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig", "type": "class", "doc": "<p>Dataset Table Configuration.</p>\n\n<p>The configuration expects the table to have the primary key as the first column(s) and in order\nin which they are specified. These are followed by the columns of relevant data and any foreign\nkeys should be in order as the last column(s). However, it is also allowed that the foreign\nkeys describe the primary key, but individually rather than the combination of.\nMoreover, both the values of the primary key and columns are expected to be splittable into two\nbased on the DATASET_SPLIT_DELIMITER. The left split is the prefix (in case of duplicate names\nacross tables) and the right split is the name of the key/column (e.g. user_id and item_id).</p>\n\n<p>primary_key: list of column names that form the primary key of the table.\nforeign_keys: (optional) list of column names that are foreign keys in other tables.\ncolumns: list of column names that contain the relevant table data.\nnum_records: the number of records in the table.\nfile: the dataset file configuration of the table.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    primary_key: List[str],\n    foreign_keys: Optional[List[str]],\n    columns: List[str],\n    num_records: int,\n    file: src.fairreckitlib.data.set.dataset_config.DatasetFileConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig.read_table", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig.read_table", "type": "function", "doc": "<p>Read the table from the specified directory.</p>\n\n<p>Args:\n    dataset_dir: the directory to read the table from.\n    columns: subset list of columns to load or None to load all.\n        All elements must either be integer indices or\n        strings that correspond to the 'names' argument.\n    chunk_size: loads the table in chunks as an iterator or\n        the entire table when None.</p>\n\n<p>Returns:\n    the resulting table (iterator).</p>\n", "signature": "(\n    self,\n    dataset_dir: str,\n    *,\n    columns: List[Union[str, int]] = None,\n    chunk_size=None\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig.save_table", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig.save_table", "type": "function", "doc": "<p>Save the table in the specified directory.</p>\n\n<p>Args:\n    dataset_table: the dataframe to save with this table configuration.\n    dataset_dir: the directory to save the table to.</p>\n", "signature": "(\n    self,\n    dataset_table: pandas.core.frame.DataFrame,\n    dataset_dir: str\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset table configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset table configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig", "type": "class", "doc": "<p>Dataset Matrix' Index Configuration.</p>\n\n<p>file_name: (optional) file name that contains the user/item indirection array.\nkey: the key that is associated with the user/item.\nnum_records: the number of user/item records</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, file_name: Optional[str], key: str, num_records: int)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig.load_indices", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig.load_indices", "type": "function", "doc": "<p>Load the indices from the specified directory.</p>\n\n<p>This function raises a FileNotFoundError when the file is not\nfound in the specified directory.</p>\n\n<p>Args:\n    dataset_dir: the directory to load the indices from.</p>\n\n<p>Returns:\n    the resulting indices or None when not available.</p>\n", "signature": "(self, dataset_dir: str) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig.save_indices", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig.save_indices", "type": "function", "doc": "<p>Save the indices to the specified directory.</p>\n\n<p>Args:\n    dataset_dir: the directory to save the indices to.\n    indices: the list of indices to save.</p>\n\n<p>Returns:\n    true when the indices are saved or false when the configuration has no file name.</p>\n", "signature": "(self, dataset_dir: str, indices: List[int]) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset index configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset index configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.RatingMatrixConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "RatingMatrixConfig", "type": "class", "doc": "<p>Rating Matrix Configuration.</p>\n\n<p>rating_min: the minimum rating in the matrix.\nrating_max: the maximum rating in the matrix.\nrating_type: the type of the rating in the matrix, either 'explicit' or 'implicit'.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.RatingMatrixConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "RatingMatrixConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, rating_min: float, rating_max: float, rating_type: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.RatingMatrixConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "RatingMatrixConfig.to_yml_format", "type": "function", "doc": "<p>Format rating matrix configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset matrix configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetMatrixConfig", "type": "class", "doc": "<p>Dataset Matrix Configuration.</p>\n\n<p>table: the table configuration of the matrix.\nrating_matrix: the ratings of the matrix.\nuser: the dataset index configuration for the users in the matrix.\nitem: the dataset index configuration for the items in the matrix.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetMatrixConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    table: src.fairreckitlib.data.set.dataset_config.DatasetTableConfig,\n    ratings: src.fairreckitlib.data.set.dataset_config.RatingMatrixConfig,\n    user: src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig,\n    item: src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig.load_matrix", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetMatrixConfig.load_matrix", "type": "function", "doc": "<p>Load the matrix from the specified directory.</p>\n\n<p>Args:\n    dataset_dir: directory path to where the dataset matrix is stored.</p>\n\n<p>Returns:\n    the resulting matrix (iterator).</p>\n", "signature": "(self, dataset_dir: str) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetMatrixConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset matrix configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset matrix configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetConfig", "type": "class", "doc": "<p>Dataset Configuration.</p>\n\n<p>dataset_name: the name of the dataset.\nevents: dictionary containing the available user event tables.\nmatrices: dictionary containing the available user-item matrices.\ntables: dictionary containing the (additionally) available tables.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    dataset_name: str,\n    events: Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig],\n    matrices: Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig],\n    tables: Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetConfig.get_available_columns", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetConfig.get_available_columns", "type": "function", "doc": "<p>Get the available columns of the specified matrix.</p>\n\n<p>Only the table names and columns that have a one-to-one relation will be returned.\nThis function does not raise errors and will return an empty dictionary when\nthe specified matrix is not present in the dataset.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to get the available columns of.</p>\n\n<p>Returns:\n    a dictionary containing the table names as key and the available columns as value.</p>\n", "signature": "(self, matrix_name: str) -> Dict[str, List[str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.create_dataset_table_config", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "create_dataset_table_config", "type": "function", "doc": "<p>Create a dataset table configuration.</p>\n\n<p>Args:\n    file_name: name of the dataset table file.\n    primary_key: a list of strings that are combined the primary key of the table.\n    columns: a list of strings with other available columns in the table.\n    compression:  the (optional) compression of the file, 'bz2' is recommended.\n    encoding: the encoding for reading/writing the table contents or None for 'utf-8'.\n    foreign_keys: (optional) list of column names that are foreign keys in other tables.\n    header: whether the table file contains a header on the first line.\n    num_records: the number of records in the table.\n    sep: the delimiter that is used in the table or None for a tab separator.</p>\n\n<p>Returns:\n    the resulting data table configuration.</p>\n", "signature": "(\n    file_name: str,\n    primary_key: List[str],\n    columns: List[str],\n    *,\n    compression: str = None,\n    encoding: str = None,\n    foreign_keys: List[str] = None,\n    header: bool = False,\n    num_records: int = 0,\n    sep: str = None\n) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "type": "module", "doc": "<p>This module contains the parser for the dataset configuration and parser utility functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetParser: dataset configuration parser.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>parse_file_name: parse a file name from a configuration and verify existence on disk.\nparse_float: parse floating-point value from a configuration.\nparse_int: parse integer value from a configuration.\nparse_optional_bool: parse optional boolean value from a configuration.\nparse_optional_string: parse optional string value from a configuration.\nparse_rating_matrix: parse rating matrix configuration.\nparse_string: parse a string value from a configuration.\nparse_string_list: parse a list of strings from a configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser", "type": "class", "doc": "<p>Dataset Configuration Parser.</p>\n\n<p>Public methods:</p>\n\n<p>parse_dataset_config\nparse_dataset_config_from_yml</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.__init__", "type": "function", "doc": "<p>Construct the DatasetConfigParser.</p>\n\n<p>Args:\n    verbose: whether the parser should give verbose output.</p>\n", "signature": "(self, verbose: bool)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_config", "type": "function", "doc": "<p>Parse a dataset configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the dataset is stored.\n    dataset_config: the dataset configuration.\n    available_datasets: a list of already available datasets.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    dataset_config: Dict[str, Any],\n    available_datasets: List[str]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_config_from_yml", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_config_from_yml", "type": "function", "doc": "<p>Parse a dataset configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the dataset is stored.\n    file_name: the name of the yml file with extension.\n    available_datasets: a list of already available datasets.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    file_name: str,\n    available_datasets: List[str]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_events", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_events", "type": "function", "doc": "<p>Parse dataset event tables from the configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the dataset is stored.\n    dataset_config: the dataset configuration.</p>\n\n<p>Returns:\n    a dictionary with parsed event table configurations.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    dataset_config: Dict[str, Any]\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_matrices", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_matrices", "type": "function", "doc": "<p>Parse dataset matrices from the configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the dataset is stored.\n    dataset_config: the dataset configuration.</p>\n\n<p>Returns:\n    a dictionary with parsed matrix configurations.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    dataset_config: Dict[str, Any]\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_tables", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_tables", "type": "function", "doc": "<p>Parse dataset tables from the configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the dataset is stored.\n    dataset_config: the dataset configuration.</p>\n\n<p>Returns:\n    a dictionary with parsed table configurations.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    dataset_config: Dict[str, Any]\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_file_options_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_file_options_config", "type": "function", "doc": "<p>Parse a dataset file configuration.</p>\n\n<p>Args:\n    file_config: the dataset file configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    file_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.FileOptionsConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_file_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_file_config", "type": "function", "doc": "<p>Parse a dataset file configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the file is stored.\n    file_config: the dataset file configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    file_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetFileConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_index_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_index_config", "type": "function", "doc": "<p>Parse a dataset matrix' user/item index configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the file is stored.\n    index_config: the dataset matrix index configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    index_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_matrix_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_matrix_config", "type": "function", "doc": "<p>Parse a dataset matrix configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the dataset matrix is stored.\n    matrix_config: the dataset matrix configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    matrix_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.DatasetConfigParser.parse_dataset_table_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "DatasetConfigParser.parse_dataset_table_config", "type": "function", "doc": "<p>Parse a dataset table configuration.</p>\n\n<p>Args:\n    data_dir: the directory where the table is stored.\n    table_config: the dataset table configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    table_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.parse_file_name", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "parse_file_name", "type": "function", "doc": "<p>Parse the file name from the configuration.</p>\n\n<p>In addition, when the file name is parsed correctly it is checked\nfor existence in the specified data directory.</p>\n\n<p>Args:\n    data_dir: the directory where the file is stored.\n    file_config: the configuration dictionary to parse from.\n    file_key: the key in the configuration that contains the file name.\n    event_dispatcher: to dispatch the parse event on failure.\n    required: whether the parsing is required to succeed.</p>\n\n<p>Returns:\n    whether the parsing succeeded and the parsed file name or None on failure.</p>\n", "signature": "(\n    data_dir: str,\n    file_config: Dict[str, Any],\n    file_key: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    required: bool = True\n) -> Tuple[bool, Optional[str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.parse_float", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "parse_float", "type": "function", "doc": "<p>Parse a float-point value from the configuration.</p>\n\n<p>Args:\n    config: the configuration dictionary to parse from.\n    float_key: the key in the configuration that contains the float-point value.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed float-point value or None on failure.</p>\n", "signature": "(\n    config: Dict[str, Any],\n    float_key: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.parse_int", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "parse_int", "type": "function", "doc": "<p>Parse an integer value from the configuration.</p>\n\n<p>The integer is expected to be greater than zero to be parsed successfully.</p>\n\n<p>Args:\n    config: the configuration dictionary to parse from.\n    int_key: the key in the configuration that contains the integer value.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed integer value or None on failure.</p>\n", "signature": "(\n    config: Dict[str, Any],\n    int_key: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[int]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.parse_optional_bool", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "parse_optional_bool", "type": "function", "doc": "<p>Parse an optional boolean from the configuration.</p>\n\n<p>Args:\n    config: the configuration dictionary to parse from.\n    bool_key: the key in the configuration that contains the boolean.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    whether the parsing succeeded and the optional boolean value.</p>\n", "signature": "(\n    config: Dict[str, Any],\n    bool_key: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Tuple[bool, Optional[bool]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.parse_optional_string", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "parse_optional_string", "type": "function", "doc": "<p>Parse an optional string from a list of valid values from the configuration.</p>\n\n<p>Args:\n    config: the configuration dictionary to parse from.\n    string_key: the key in the configuration that contains the string.\n    string_options: the options that are available for the string that is being parsed.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    whether the parsing succeeded and the optional string value.</p>\n", "signature": "(\n    config: Dict[str, Any],\n    string_key: str,\n    string_options: List[str],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Tuple[bool, Optional[str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.parse_rating_matrix", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "parse_rating_matrix", "type": "function", "doc": "<p>Parse a rating matrix from the configuration.</p>\n\n<p>Args:\n    matrix_config: the matrix configuration dictionary to parse from.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed string or None on failure.</p>\n", "signature": "(\n    matrix_config: Dict[str, Any],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[src.fairreckitlib.data.set.dataset_config.RatingMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.parse_string", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "parse_string", "type": "function", "doc": "<p>Parse a string from the configuration.</p>\n\n<p>Args:\n    config: the configuration dictionary to parse from.\n    string_key: the key in the configuration that contains the string.\n    event_dispatcher: to dispatch the parse event on failure.\n    one_of_list: when not None the string is to be expected one of the specified list.</p>\n\n<p>Returns:\n    the parsed string or None on failure.</p>\n", "signature": "(\n    config: Dict[str, Any],\n    string_key: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    one_of_list: List[str] = None\n) -> Optional[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parser.parse_string_list", "modulename": "src.fairreckitlib.data.set.dataset_config_parser", "qualname": "parse_string_list", "type": "function", "doc": "<p>Parse a list of strings from the configuration.</p>\n\n<p>Args:\n    config: the configuration dictionary to parse from.\n    string_list_key: the key in the configuration that contains the string list.\n    min_list_length: the minimum length of the list to succeed.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed string list or None on failure.</p>\n", "signature": "(\n    config: Dict[str, Any],\n    string_list_key: str,\n    min_list_length: int,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[List[str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_constants", "modulename": "src.fairreckitlib.data.set.dataset_constants", "type": "module", "doc": "<p>This module contains dataset (configuration) constants that are used in other modules.</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "type": "module", "doc": "<p>This module contains functionality to create matrices from dataset event tables.</p>\n\n<p>Classes:</p>\n\n<pre><code>MatrixProcessorConfig: the matrix processor configuration.\nDatasetMatrixProcessor: the dataset matrix processor that generates/adds user-item matrices.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_matrix_chunk: create a user-item matrix chunk by counting user-item occurrences.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.MatrixProcessorConfig", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "MatrixProcessorConfig", "type": "class", "doc": "<p>Matrix Processor Configuration.</p>\n\n<p>event_table_name: the name of the event table to use.\nitem_key: the item key name to create a user-item matrix for.\nrating_column: the name of the rating column to use in the user-item matrix.</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.MatrixProcessorConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "MatrixProcessorConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_table_name: str, item_key: str, rating_column: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.DatasetMatrixProcessor", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "DatasetMatrixProcessor", "type": "class", "doc": "<p>Dataset Matrix Processor.</p>\n\n<p>The intended use of this class is to utilize an existing dataset that has event tables present,\nin order to generate a new user-item matrix. The processor does the following steps in order:</p>\n\n<p>1) create a temporary directory to store user-item chunks.\n2) process the event table by creating and saving user-item chunks.\n3) process the matrix by merging chunks.\n4) save the matrix in the dataset directory.\n5) update the dataset configuration file with the new user-item matrix.\n6) remove the temporary directory with.</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.DatasetMatrixProcessor.__init__", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "DatasetMatrixProcessor.__init__", "type": "function", "doc": "<p>Construct the dataset matrix processor.</p>\n\n<p>Args:\n    dataset: the dataset to create a new user-item matrix for.\n    verbose: whether the processor should give verbose output.</p>\n", "signature": "(\n    self,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    verbose=True\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.DatasetMatrixProcessor.run", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "DatasetMatrixProcessor.run", "type": "function", "doc": "<p>Run the processor with the specified matrix configuration.</p>\n\n<p>The processor fails when the user-item matrix is already present in the\nexisting dataset configuration.</p>\n\n<p>Args:\n    processor_config: the configuration to use for creating a user-item matrix.\n    chunk_size: the size of the chunks to use during processing.</p>\n\n<p>Raises:\n    KeyError: when the event table does not exist in the dataset.\n    IndexError: when the item key name is not present in the event table.</p>\n\n<p>Returns:\n    whether the processing of the user-item matrix succeeded.</p>\n", "signature": "(\n    self,\n    processor_config: src.fairreckitlib.data.set.dataset_matrix.MatrixProcessorConfig,\n    *,\n    chunk_size: int = 10000000.0\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.DatasetMatrixProcessor.process_event_table", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "DatasetMatrixProcessor.process_event_table", "type": "function", "doc": "<p>Process the event table in chunks.</p>\n\n<p>Args:\n    output_dir: the output directory to store the chunks.\n    event_table: the event table to process into chunks.\n    item_key: the item key name to create a user-item chunk for.\n    rating_column: the name of the rating column to use in the user-item chunk.\n    chunk_size: the size of the chunks to use during processing.</p>\n\n<p>Returns:\n    the number of chunks that are generated.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    event_table: src.fairreckitlib.data.set.dataset_config.DatasetTableConfig,\n    item_key: str,\n    rating_column: str,\n    *,\n    chunk_size: int = 10000000.0\n) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.DatasetMatrixProcessor.process_matrix_from_chunks", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "DatasetMatrixProcessor.process_matrix_from_chunks", "type": "function", "doc": "<p>Process the user-item matrix from the stored chunks.</p>\n\n<p>Args:\n    output_dir: the output directory where the chunks are stored.\n    num_chunks: the number of chunks in the output directory.\n    item_key: the item key name that was used to create user-item chunks.\n    rating_column: the name of the rating column that was used to create user-item chunks.</p>\n\n<p>Returns:\n    the user-item matrix and the lists of unique user/item ids.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    num_chunks: int,\n    item_key: str,\n    rating_column: str\n) -> Tuple[pandas.core.frame.DataFrame, List[int], List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.DatasetMatrixProcessor.save_matrix", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "DatasetMatrixProcessor.save_matrix", "type": "function", "doc": "<p>Save the matrix in the dataset directory.</p>\n\n<p>Args:\n    matrix_name: the name that is used to save the matrix, user and item lists.\n    matrix_tuple: the user-item matrix and the lists of unique user/item ids.\n    item_key: the item key name that was used to create the user-item matrix.\n    rating_column: name of the rating column that was used to create the user-item matrix.</p>\n\n<p>Returns:\n    the dataset matrix configuration.</p>\n", "signature": "(\n    self,\n    matrix_name: str,\n    matrix_tuple: Tuple[pandas.core.frame.DataFrame, List[int], List[int]],\n    item_key: str,\n    rating_column: str\n) -> src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_matrix.create_matrix_chunk", "modulename": "src.fairreckitlib.data.set.dataset_matrix", "qualname": "create_matrix_chunk", "type": "function", "doc": "<p>Create a user-item matrix chunk by counting occurrences of user-item combinations.</p>\n\n<p>Args:\n    chunk: a dataframe chunk containing the user-item events.\n    item_key: the key of the item to use for counting occurrences.\n    rating_column: the name of the rating column to store the user-item counter in.</p>\n\n<p>Returns:\n    a dataframe with the columns ['user', item_key, rating_column].</p>\n", "signature": "(\n    chunk: pandas.core.frame.DataFrame,\n    item_key: str,\n    rating_column: str\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry", "modulename": "src.fairreckitlib.data.set.dataset_registry", "type": "module", "doc": "<p>This module contains the data registry class.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataRegistry: registry for available datasets after processing them into a standard format.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry", "type": "class", "doc": "<p>Data Registry with available datasets.</p>\n\n<p>The data directory is expected to exist or will raise an IOError.\nEach subdirectory is considered to store a single dataset. The name of\nthe subdirectory needs to be exactly the same as one of the available\nprocessors to trigger automatic data processing.</p>\n\n<p>Public methods:</p>\n\n<p>get_available_processors\nget_available_sets\nget_info\nget_set</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.__init__", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.__init__", "type": "function", "doc": "<p>Construct the data registry and scan for available datasets.</p>\n\n<p>Args:\n    data_dir: path to the directory that contains the datasets.\n    verbose: whether the dataset parser should give verbose output.</p>\n\n<p>Raises:\n    IOError: when the specified data directory does not exist.</p>\n", "signature": "(self, data_dir: str, verbose: bool = True)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.get_available_processors", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.get_available_processors", "type": "function", "doc": "<p>Get the names of the available processors in the registry.</p>\n\n<p>Returns:\n    a list of data processor names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.get_available_sets", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.get_available_sets", "type": "function", "doc": "<p>Get the names of the available datasets in the registry.</p>\n\n<p>Returns:\n    a list of dataset names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.get_info", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.get_info", "type": "function", "doc": "<p>Get the matrices' information for each available dataset.</p>\n\n<p>Returns:\n    a dictionary where the key corresponds to the dataset name and\n        the value corresponds to the matrices' information dictionary.</p>\n", "signature": "(self) -> Dict[str, Dict[str, Any]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.get_set", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.get_set", "type": "function", "doc": "<p>Get the dataset with the specified name.</p>\n\n<p>Args:\n    dataset_name: name of the dataset to retrieve.</p>\n\n<p>Returns:\n    the retrieved set or None when not present.</p>\n", "signature": "(\n    self,\n    dataset_name: str\n) -> Optional[src.fairreckitlib.data.set.dataset.Dataset]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "type": "module", "doc": "<p>This module contains functionality to create a sample of an existing dataset.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_dataset_sample: create a sample of a dataset.\ncreate_dataset_table_samples: create tables samples for a map of key indices.\ncreate_matrix_sample_config: create a sample matrix configuration.\ncreate_matrix_sample: create a sample of a dataset's matrix.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling.create_dataset_sample", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "qualname": "create_dataset_sample", "type": "function", "doc": "<p>Create a sample of the specified dataset.</p>\n\n<p>Look at the 'create_matrix_sample' function for specifics on how the\nmatrices of the dataset are sampled. All tables, except the events, that are related\nto the user/item keys that are present in the sample matrices are sampled as well.\nThe generated dataset sample is stored in the output directory before returning it.\nThis function raises an IOError when the specified output directory already exists.</p>\n\n<p>Args:\n    output_dir: the path to the directory where the dataset sample will be stored.\n    dataset: the dataset to create a sample of.\n    num_users: the number of users in the created sample matrices.\n    num_items: the number of items in the created sample matrices.</p>\n\n<p>Returns:\n    the resulting sample dataset.</p>\n", "signature": "(\n    output_dir: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    num_users: int,\n    num_items: int\n) -> src.fairreckitlib.data.set.dataset.Dataset", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling.create_dataset_table_samples", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "qualname": "create_dataset_table_samples", "type": "function", "doc": "<p>Create table samples for the specified dataset and key map.</p>\n\n<p>The key map is used to identify which tables of the dataset are sampled.\nA table is considered to be a candidate if the key in the map matches the\nprimary key of the table. Any rows that do not contain the needed indices\nin the key map are filtered.</p>\n\n<p>Args:\n    output_dir: the path to the directory where the sample tables will be stored.\n    dataset: the dataset to create a sample tables from.\n    key_id_map: a dictionary containing a table key paired with a list of indices\n        that are related to these table keys.</p>\n\n<p>Returns:\n    a dictionary with the resulting table sample configurations, keyed by table names.</p>\n", "signature": "(\n    output_dir: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    key_id_map: Dict[str, List[int]]\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling.create_matrix_sample_config", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "qualname": "create_matrix_sample_config", "type": "function", "doc": "<p>Create a dataset matrix sample configuration.</p>\n\n<p>Look at the 'create_matrix_sample' function for specifics on how the\nmatrix is sampled. The generated matrix and user/item indirection arrays are\nstored in the output directory and the corresponding configuration is returned.</p>\n\n<p>Args:\n    output_dir: the path to the directory where the sample matrix will be stored.\n    dataset: the dataset to create a sample matrix from.\n    matrix_name: the name of the matrix to create a sample of.\n    num_users: the number of users in the created sample matrix.\n    num_items: the number of items in the created sample matrix.</p>\n\n<p>Returns:\n    the sample matrix configuration or None when the specified matrix does not exist.</p>\n", "signature": "(\n    output_dir: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    num_users: int,\n    num_items: int\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling.create_matrix_sample", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "qualname": "create_matrix_sample", "type": "function", "doc": "<p>Create a sample for the specified matrix.</p>\n\n<p>Extracts a sample with the first occurring users and items until the\nspecified amounts are reached, and therefore are only used as an indication.\nNo additional users/items are generated when the dataset matrix has\nless available amounts than is specified. Moreover, due to the sparsity of the\nmatrix it can turn out that the resulting matrix is very close, but not\nexactly the specified amounts.</p>\n\n<p>Args:\n    dataset: the dataset to create a sample matrix from.\n    matrix_name: the name of the matrix to create a sample of.\n    num_users: the number of users in the created sample matrix.\n    num_items: the number of items in the created sample matrix.</p>\n\n<p>Returns:\n    the sample matrix, the unique user and unique item indices.</p>\n", "signature": "(\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    num_users: int,\n    num_items: int\n) -> Tuple[pandas.core.frame.DataFrame, List[int], List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor", "modulename": "src.fairreckitlib.data.set.processor", "type": "module", "doc": "<p>This package contains dataset processors for various movie/music datasets.</p>\n\n<p>Modules:</p>\n\n<pre><code>dataset_processor_base: base class for all dataset processors.\ndataset_processor_lfm: base class for LastFM dataset processors.\ndataset_processor_lfm_1b: class to process the LastFM-1B dataset.\ndataset_processor_lfm_2b: class to process the LastFM-2B dataset.\ndataset_processor_lfm_360k: class to process the LastFM-360K dataset.\ndataset_processor_ml: base class for MovieLens dataset processors.\ndataset_processor_ml_25m: class to process the MovieLens-25M dataset.\ndataset_processor_ml_100k: class to process the MovieLens-100K dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "type": "module", "doc": "<p>This module contains the base functionality shared by all dataset processors.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorBase: the base class for dataset processors.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase", "type": "class", "doc": "<p>DataProcessor base class for all FairRecKit datasets.</p>\n\n<p>Datasets are preprocessed so that they will be of a recognized standard format\non the other side. A configuration file is produced in the resulting dataset\ndirectory that stores the metadata for achieving this. For further information\nit is advised to take a look at the Dataset(Config) class.</p>\n\n<p>The dataset configuration mainly consists of:</p>\n\n<p>1) event tables: contain user event tables that can be used to construct a matrix of.\n2) matrix tables: contain available matrices associated with the dataset.\n3) (other) tables: contain the shared tables associated with the dataset.</p>\n\n<p>For each of these three categories an abstract function is exposed in order to retrieve\n(table name, table configuration processor) tuples. The tables names are expected to be\nunique across all categories. The table configuration processors are allowed to return\nNone on failure and will be excluded from the final configuration. Moreover, tables that\ndo not contain any records are excluded as well.\nThe base dataset processor handles the processing logic. It needs to produce at least\none valid event table or one valid matrix configuration to be successful, concluding\nthat remaining tables are optional.</p>\n\n<p>Abstract methods:</p>\n\n<p>get_event_configs\nget_matrix_configs\nget_table_configs</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.__init__", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.__init__", "type": "function", "doc": "<p>Construct the base DatasetProcessor.</p>\n\n<p>Args:\n    dataset_dir: path of the dataset directory.\n    dataset_name: name of the dataset (processor).</p>\n", "signature": "(self, dataset_dir: str, dataset_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.get_event_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.get_event_configs", "type": "function", "doc": "<p>Get event table configuration processors.</p>\n\n<p>Returns:\n    a list of tuples consisting of the event table name and the event table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list of tuples consisting of the matrix name and the matrix processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list of tuples consisting of the table name and the table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.run_event_table_processors", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.run_event_table_processors", "type": "function", "doc": "<p>Run the dataset's event table processors.</p>\n\n<p>Returns:\n    a dictionary with valid event table name-configuration pairs.</p>\n", "signature": "(\n    self\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.run_matrix_table_processors", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.run_matrix_table_processors", "type": "function", "doc": "<p>Run the dataset's matrix processors.</p>\n\n<p>Returns:\n    a dictionary with valid matrix name-configuration pairs.</p>\n", "signature": "(\n    self\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.run_table_processors", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.run_table_processors", "type": "function", "doc": "<p>Run the dataset's additional table processors.</p>\n\n<p>Returns:\n    a dictionary with valid table name-configuration pairs.</p>\n", "signature": "(\n    self\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.run", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.run", "type": "function", "doc": "<p>Run the dataset configuration processor.</p>\n\n<p>Returns:\n    the dataset configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "type": "module", "doc": "<p>This module contains the base processor for LastFM datasets.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorLFM: the base class for LastFM dataset processors.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM", "type": "class", "doc": "<p>DataProcessor base class for LastFM datasets.</p>\n\n<p>Provides an abstraction for processing the listening event table,\nand also for generalizing the user table data. An iterative matrix\nprocessor function is exposed for derived subclasses as the LastFM\ndataset matrices tend to be very big.</p>\n\n<p>Abstract methods:</p>\n\n<p>create_listening_events_config\ncreate_user_table_config</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.create_listening_events_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.create_listening_events_config", "type": "function", "doc": "<p>Create the listening event table configuration.</p>\n\n<p>Returns:\n    the configuration of the listening event table or None when not available.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.create_user_table_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.create_user_table_config", "type": "function", "doc": "<p>Create the user table configuration.</p>\n\n<p>Returns:\n    the configuration of the user table.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.get_event_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.get_event_configs", "type": "function", "doc": "<p>Get event table configuration processors.</p>\n\n<p>Returns:\n    a list containing the listening event table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Derived implementations are expected to call the super implementation in\norder to include the user table in the configuration.</p>\n\n<p>Returns:\n    a list containing the user table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.process_listening_events", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.process_listening_events", "type": "function", "doc": "<p>Process the listening event table.</p>\n\n<p>Returns:\n    the listening event table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.process_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.process_matrix", "type": "function", "doc": "<p>Process the matrix with the specified configuration.</p>\n\n<p>Args:\n    matrix_table_config: the configuration of the matrix to process.\n    user_idx_file: the file name of the user indices or None when not present.\n    item_idx_file: the file name of the item indices or None when not present.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self,\n    matrix_table_config: src.fairreckitlib.data.set.dataset_config.DatasetTableConfig,\n    user_idx_file: str = None,\n    item_idx_file: str = None\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.process_user_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.process_user_table", "type": "function", "doc": "<p>Process the user table.</p>\n\n<p>Changes the contents of the gender column to be more user-friendly,\nand the contents of the age column to -1 when above 100.</p>\n\n<p>Returns:\n    the user table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "type": "module", "doc": "<p>This modules contains the class to process the LastFM-1B dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorLFM1B: data processor implementation for the LFM-1B dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B", "type": "class", "doc": "<p>DatasetProcessor for the LastFM-1B dataset.</p>\n\n<p>The dataset and UGP (user genre profile) can be downloaded from the website below.\nhttp://www.cp.jku.at/datasets/LFM-1b/</p>\n\n<p>The enriched artist gender information can be retrieved from:\nhttps://zenodo.org/record/3748787#.YowEBqhByUk</p>\n\n<p>The processor handles the following files:</p>\n\n<p>LFM-1b_albums.txt (optional)\nLFM-1b_artist_genres_allmusic.txt (optional)\nLFM-1b_artists.txt (optional)\nLFM-1b_LEs.mat (required)\nLFM-1b_LEs.txt (required)\nLFM-1b_tracks.txt (optional)\nLFM-1b_UGP_noPC_allmusic.txt (optional)\nLFM-1b_UGP_weightedPC_allmusic.txt (optional)\nLFM-1b_users.txt (optional)\nLFM-1b_users_additional.txt (optional)\nlfm-gender.json (optional)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.create_listening_events_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.create_listening_events_config", "type": "function", "doc": "<p>Create the listening event table configuration.</p>\n\n<p>Returns:\n    the configuration of the listening event table.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.create_user_table_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.create_user_table_config", "type": "function", "doc": "<p>Create the user table configuration.</p>\n\n<p>Returns:\n    the configuration of the user table.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list containing the user-artist-count matrix processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the album, allmusic genre, artist, track and user table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.load_artist_gender_json", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.load_artist_gender_json", "type": "function", "doc": "<p>Load the artist gender json file.</p>\n\n<p>Returns:\n    the loaded artist id/gender table or None on failure.</p>\n", "signature": "(self) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.load_artist_genres_allmusic", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.load_artist_genres_allmusic", "type": "function", "doc": "<p>Load the artist allmusic genres file.</p>\n\n<p>Returns:\n    the loaded artist name/genre table or None on failure.</p>\n", "signature": "(self) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_album_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_album_table", "type": "function", "doc": "<p>Process the album table.</p>\n\n<p>Returns:\n    the album table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_artist_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_artist_table", "type": "function", "doc": "<p>Process the artist table.</p>\n\n<p>Extends the table with artist gender and genres information when available.</p>\n\n<p>Returns:\n    the artist table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_genres_allmusic", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_genres_allmusic", "type": "function", "doc": "<p>Process the allmusic genres table.</p>\n\n<p>Returns:\n    the allmusic genres table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_track_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_track_table", "type": "function", "doc": "<p>Process the track table.</p>\n\n<p>Returns:\n    the track table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_user_artist_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_user_artist_matrix", "type": "function", "doc": "<p>Process the user-artist-count matrix.</p>\n\n<p>The user-item matrix is stored in a matlab file in CSR compatible format,\ntogether with the user and item indices. The matrix is converted\nto a dataframe and the indices for the indirection arrays are flattened.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_user_additional_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_user_additional_table", "type": "function", "doc": "<p>Process the user additional table.</p>\n\n<p>Returns:\n    the user additional table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_user_genre_allmusic_no_pc", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_user_genre_allmusic_no_pc", "type": "function", "doc": "<p>Process the user allmusic genre table.</p>\n\n<p>Returns:\n    the user allmusic genre table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_user_genre_allmusic_weighted_pc", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_user_genre_allmusic_weighted_pc", "type": "function", "doc": "<p>Process the user allmusic genre table with weighted play count.</p>\n\n<p>Returns:\n    the user allmusic genre table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "type": "module", "doc": "<p>This modules contains the class to process the LastFM-2B dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorLFM2B: data processor implementation for the LFM-2B dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B", "type": "class", "doc": "<p>DatasetProcessor for the LastFM-2B dataset.</p>\n\n<p>The dataset can be downloaded from the website below.\nhttp://www.cp.jku.at/datasets/LFM-2b/</p>\n\n<p>Note that the compressed bz2 files can be used directly.\nThe processor handles the following files:</p>\n\n<p>albums.tsv.bz2 (optional)\nartists.tsv.bz2 (optional)\nlistening-counts.tsv.bz2 (required)\nlistening-events.tsv.bz2 (required)\nspotify-uris.tsv.bz2 (optional)\ntracks.tsv.bz2 (optional)\nusers.tsv.bz2 (optional)\nuser_artist_playcount.tsv (required)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.create_listening_events_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.create_listening_events_config", "type": "function", "doc": "<p>Create the listening event table configuration.</p>\n\n<p>Returns:\n    the configuration of the listening event table.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.create_user_table_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.create_user_table_config", "type": "function", "doc": "<p>Create the user table configuration.</p>\n\n<p>Returns:\n    the configuration of the user table.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list containing the user-artist-count and user-track-count matrix processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the album, artist, spotify, track and user table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_album_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_album_table", "type": "function", "doc": "<p>Process the album table.</p>\n\n<p>The original file does not load correctly with pandas when splitting on\nnewlines \\n and \\t tabs.</p>\n\n<p>Returns:\n    the album table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_artist_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_artist_table", "type": "function", "doc": "<p>Process the artist table.</p>\n\n<p>Returns:\n    the artist table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_corrupt_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_corrupt_table", "type": "function", "doc": "<p>Process a corrupt table that does not load correctly with pandas.</p>\n\n<p>Loading with the 'python-fwf' engine does not have issues, however the\nrow values need to be manually split.</p>\n", "signature": "(self, table_name: str) -> Tuple[str, int]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_spotify_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_spotify_table", "type": "function", "doc": "<p>Process the spotify table.</p>\n\n<p>Returns:\n    the spotify table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_track_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_track_table", "type": "function", "doc": "<p>Process the track table.</p>\n\n<p>The original file does not load correctly with pandas when splitting on\nnewlines \\n and \\t tabs.</p>\n\n<p>Returns:\n    the track table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_user_artist_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_user_artist_matrix", "type": "function", "doc": "<p>Process the user-artist-count matrix.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_user_track_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_user_track_matrix", "type": "function", "doc": "<p>Process the user-track-count matrix.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "type": "module", "doc": "<p>This modules contains the class to process the LastFM-360K dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorLFM360K: data processor implementation for the LFM-360K dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K", "type": "class", "doc": "<p>DatasetProcessor for the LastFM-360K dataset.</p>\n\n<p>The dataset can be downloaded from the website below.\nhttps://www.upf.edu/web/mtg/lastfm360k</p>\n\n<p>The enriched artist gender information can be retrieved from:\nhttps://zenodo.org/record/3748787#.YowEBqhByUk</p>\n\n<p>The processor handles the following files:</p>\n\n<p>usersha1-artmbid-artname-plays.tsv (required)\nusersha1-profile.tsv (optional)\nlfm-360-gender.json (optional)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.__init__", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.__init__", "type": "function", "doc": "<p>Construct the DatasetProcessorLFM360K.</p>\n\n<p>Args:\n    dataset_name: path of the dataset directory.\n    dataset_name: name of the dataset (processor).</p>\n", "signature": "(self, dataset_dir: str, dataset_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.create_listening_events_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.create_listening_events_config", "type": "function", "doc": "<p>Create the listening event table configuration.</p>\n\n<p>No listening events are available for this dataset.</p>\n\n<p>Returns:\n    None.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.create_user_table_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.create_user_table_config", "type": "function", "doc": "<p>Create the user table configuration.</p>\n\n<p>The base user configuration that contains the generated user ids\nand corresponding user sha.</p>\n\n<p>Returns:\n    the configuration of the user table.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list containing the user-artist-count matrix processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the artist and user table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.load_artist_gender_json", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.load_artist_gender_json", "type": "function", "doc": "<p>Load the artist gender json file.</p>\n\n<p>Returns:\n    the loaded artist musicbrainzID/gender table or None on failure.</p>\n", "signature": "(self) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.load_user_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.load_user_table", "type": "function", "doc": "<p>Load the original user table.</p>\n\n<p>Changes the contents of the age and gender columns to be more user-friendly,\nand the contents of the country column to ISO 3166 Alpha-2 country codes.</p>\n\n<p>Returns:\n    the loaded user table on None on failure.</p>\n", "signature": "(self) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.process_artist_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.process_artist_table", "type": "function", "doc": "<p>Process the artist table.</p>\n\n<p>Creates the artist table with the musicbrainzID and gender information when available.</p>\n\n<p>Returns:\n    the artist table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.process_user_artist_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.process_user_artist_matrix", "type": "function", "doc": "<p>Process the user-artist-count matrix.</p>\n\n<p>The user-item matrix is stored in a file that also contains a musicbrainzID.\nThe users are hashes and the items are names, both are converted to integers\nto comply to the CSR compatible format. In addition, any rows that contain\ncorrupt data are removed in the process.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.process_user_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.process_user_table", "type": "function", "doc": "<p>Process the user table.</p>\n\n<p>Extends the original user table with unique user ids.</p>\n\n<p>Returns:\n    the user table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "type": "module", "doc": "<p>This module contains the base processor for MovieLens datasets.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorML: the base class for MovieLens dataset processors.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML", "type": "class", "doc": "<p>DataProcessor base class for MovieLens datasets.</p>\n\n<p>Provides an abstraction for processing the user-movie-rating matrix.\nMoreover, it is assumed that the datasets do not have any event tables.</p>\n\n<p>Abstract methods:</p>\n\n<p>create_user_movie_matrix_config</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML.create_user_movie_matrix_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML.create_user_movie_matrix_config", "type": "function", "doc": "<p>Create the user-movie matrix configuration.</p>\n\n<p>Returns:\n    the table configuration of the matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML.get_event_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML.get_event_configs", "type": "function", "doc": "<p>Get event table configuration processors.</p>\n\n<p>Returns:\n    an empty list.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list with the user-movie-rating matrix processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML.process_user_movie_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML.process_user_movie_matrix", "type": "function", "doc": "<p>Process the user-movie-rating matrix.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "type": "module", "doc": "<p>This modules contains the class to process the MovieLens-100K dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorML100K: data processor implementation for the ML-100K dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K", "type": "class", "doc": "<p>DatasetProcessor for the MovieLens-100K dataset.</p>\n\n<p>The dataset can be downloaded from the link below.\nhttps://files.grouplens.org/datasets/movielens/ml-100k.zip</p>\n\n<p>The processor handles the following files:</p>\n\n<p>u.data (required)\nu.user (optional)\nu.item (optional)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K.create_user_movie_matrix_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K.create_user_movie_matrix_config", "type": "function", "doc": "<p>Create the user-movie matrix configuration.</p>\n\n<p>Returns:\n    the table configuration of the ML-100K matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the user and movie table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K.process_movie_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K.process_movie_table", "type": "function", "doc": "<p>Process the movie table.</p>\n\n<p>Removes an empty release date column that is included in the movie title.\nSimplifies the binary genre columns by concatenating the names using pipes.</p>\n\n<p>Returns:\n    the movie table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K.process_user_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K.process_user_table", "type": "function", "doc": "<p>Process the user table.</p>\n\n<p>Changes the contents of the gender and occupation columns to be more user-friendly.</p>\n\n<p>Returns:\n    the user table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "type": "module", "doc": "<p>This modules contains the class to process the MovieLens-25M dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorML25M: data processor implementation for the ML-25M dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M", "type": "class", "doc": "<p>DatasetProcessor for the MovieLens-25M dataset.</p>\n\n<p>The dataset can be downloaded from the link below.\nhttps://files.grouplens.org/datasets/movielens/ml-25m.zip</p>\n\n<p>The processor handles the following files:</p>\n\n<p>genome-scores.csv (optional)\ngenome-tags.csv (optional)\nlinks.csv (optional)\nmovies.csv (optional)\nratings.csv (required)\ntags.csv (optional)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.create_user_movie_matrix_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.create_user_movie_matrix_config", "type": "function", "doc": "<p>Create the user-movie matrix configuration.</p>\n\n<p>Returns:\n    the table configuration of the ML-25M matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.get_event_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.get_event_configs", "type": "function", "doc": "<p>Get event table configuration processors.</p>\n\n<p>Returns:\n    a list containing the tag event table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the genome score, genome tag, movie and tag table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.process_genome_score_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.process_genome_score_table", "type": "function", "doc": "<p>Process the genome score table.</p>\n\n<p>Returns:\n    the genome score table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.process_genome_tag_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.process_genome_tag_table", "type": "function", "doc": "<p>Process the genome tag table.</p>\n\n<p>Returns:\n    the genome tag table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.process_movie_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.process_movie_table", "type": "function", "doc": "<p>Process the movie table.</p>\n\n<p>The movie and link tables are joined together for simplification.</p>\n\n<p>Returns:\n    the movie table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.process_tag_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.process_tag_table", "type": "function", "doc": "<p>Process the tag (event) table.</p>\n\n<p>Returns:\n    the tag table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split", "modulename": "src.fairreckitlib.data.split", "type": "module", "doc": "<p>This package contains functionality for splitting dataframes into a train and test set.</p>\n\n<p>Modules:</p>\n\n<pre><code>base_splitter: base class for data splitters.\nrandom_splitter: class for splitting randomly.\nsplit_config: splitter configuration class.\nsplit_config_parsing: parse splitter configuration.\nsplit_constants: constants to be used in other modules.\nsplit_event: event args and a print function for a splitting event.\nsplit_factory: create splitter factory with available data splitters.\ntemporal_splitter: class for splitting on time.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.base_splitter", "modulename": "src.fairreckitlib.data.split.base_splitter", "type": "module", "doc": "<p>This module contains the base class for data splitting.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataSplitter: the base class for data splitting.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.base_splitter.DataSplitter", "modulename": "src.fairreckitlib.data.split.base_splitter", "qualname": "DataSplitter", "type": "class", "doc": "<p>Base class for FairRecKit data splitters.</p>\n\n<p>A splitter is used to split a dataframe into a train and test set.</p>\n\n<p>Public methods:</p>\n\n<p>get_test_ratio</p>\n", "bases": "src.fairreckitlib.data.data_modifier.DataModifier"}, {"fullname": "src.fairreckitlib.data.split.base_splitter.DataSplitter.__init__", "modulename": "src.fairreckitlib.data.split.base_splitter", "qualname": "DataSplitter.__init__", "type": "function", "doc": "<p>Construct the base splitter.</p>\n\n<p>Args:\n    name: the name of the splitter.\n    params: a dictionary containing the parameters for the splitter.\n    test_ratio: the fraction of users to use for testing.</p>\n\n<p>Raises:\n    RuntimeError: when the test ratio is not within the accepted min and max range.</p>\n", "signature": "(self, name: str, params: Dict[str, Any], test_ratio: float)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.base_splitter.DataSplitter.get_test_ratio", "modulename": "src.fairreckitlib.data.split.base_splitter", "qualname": "DataSplitter.get_test_ratio", "type": "function", "doc": "<p>Get the test ratio used by the splitter when run.</p>\n\n<p>Returns:\n    the test ratio</p>\n", "signature": "(self) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.base_splitter.DataSplitter.run", "modulename": "src.fairreckitlib.data.split.base_splitter", "qualname": "DataSplitter.run", "type": "function", "doc": "<p>Run the splitter on the specified dataframe.</p>\n\n<p>Args:\n    dataframe: with at least the 'user' column.</p>\n\n<p>Returns:\n    the train and test set dataframes of the split.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.random_splitter", "modulename": "src.fairreckitlib.data.split.random_splitter", "type": "module", "doc": "<p>This module contains random splitting functionality.</p>\n\n<p>Classes:</p>\n\n<pre><code>RandomSplitter: can split randomly.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_random_splitter: create an instance of the class (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.random_splitter.RandomSplitter", "modulename": "src.fairreckitlib.data.split.random_splitter", "qualname": "RandomSplitter", "type": "class", "doc": "<p>Random Splitter.</p>\n\n<p>Splits the dataframe into a train and test set randomly user-by-user.</p>\n", "bases": "src.fairreckitlib.data.split.base_splitter.DataSplitter"}, {"fullname": "src.fairreckitlib.data.split.random_splitter.RandomSplitter.run", "modulename": "src.fairreckitlib.data.split.random_splitter", "qualname": "RandomSplitter.run", "type": "function", "doc": "<p>Split the dataframe into a train and test set.</p>\n\n<p>Args:\n    dataframe: with at least the 'user' column.</p>\n\n<p>Returns:\n    the train and test set dataframes of the split.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.random_splitter.create_random_splitter", "modulename": "src.fairreckitlib.data.split.random_splitter", "qualname": "create_random_splitter", "type": "function", "doc": "<p>Create the Random Splitter.</p>\n\n<p>Returns:\n    the random data splitter.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.data.split.random_splitter.RandomSplitter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config", "modulename": "src.fairreckitlib.data.split.split_config", "type": "module", "doc": "<p>This module contains the split configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>SplitConfig: split configuration.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_default_split_config: create the default split configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_config.SplitConfig", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "SplitConfig", "type": "class", "doc": "<p>Dataset Splitting Configuration.</p>\n\n<p>name: the name of the splitter.\nparams: the parameters of the splitter.\ntest_ratio: the test ratio used by the splitter.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.data.split.split_config.SplitConfig.__init__", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "SplitConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any], test_ratio: float)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config.SplitConfig.get_split_ratio_string", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "SplitConfig.get_split_ratio_string", "type": "function", "doc": "<p>Get the split ratio percentages formatted as a string.</p>\n\n<p>Returns:\n    a string containing the split ratio in percentages.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config.SplitConfig.to_yml_format", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "SplitConfig.to_yml_format", "type": "function", "doc": "<p>Format splitting configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the splitting configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config.create_default_split_config", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "create_default_split_config", "type": "function", "doc": "<p>Create the default split configuration.</p>\n\n<p>Returns:\n    the default configuration of splitting.</p>\n", "signature": "() -> src.fairreckitlib.data.split.split_config.SplitConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config_parsing", "modulename": "src.fairreckitlib.data.split.split_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the dataset splitting configuration.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_data_split_config: parse split configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_config_parsing.parse_data_split_config", "modulename": "src.fairreckitlib.data.split.split_config_parsing", "qualname": "parse_data_split_config", "type": "function", "doc": "<p>Parse a dataset splitting configuration.</p>\n\n<p>Args:\n    dataset_config: the dataset's total configuration.\n    dataset: the dataset related to the splitting configuration.\n    matrix_name: the dataset's matrix name that is used.\n    split_factory: the split factory containing available splitters.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    dataset_config: Dict[str, Any],\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    split_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> src.fairreckitlib.data.split.split_config.SplitConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_constants", "modulename": "src.fairreckitlib.data.split.split_constants", "type": "module", "doc": "<p>This module contains splitting constants that are used in other modules.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_SPLITTING: key that is used to identify splitters.\nKEY_SPLIT_TEST_RATIO: key that is used to identify the splitter test ratio.\nSPLIT_RANDOM: name of the random splitter.\nSPLIT_TEMPORAL: name of the temporal splitter.\nDEFAULT_SPLIT_NAME: the name of the default splitter.\nDEFAULT_SPLIT_TEST_RATIO: the default split test ratio.\nMIN_TEST_RATIO: the minimum allowed split test ratio.\nMAX_TEST_RATIO: the maximum allowed split test ratio.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_event", "modulename": "src.fairreckitlib.data.split.split_event", "type": "module", "doc": "<p>This module contains event args and a print function for a rating conversion event.</p>\n\n<p>Classes:</p>\n\n<pre><code>SplitDataframeEventArgs: event args related to splitting dataframes.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>print_split_event_args: print dataframe split event arguments.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_event.SplitDataframeEventArgs", "modulename": "src.fairreckitlib.data.split.split_event", "qualname": "SplitDataframeEventArgs", "type": "class", "doc": "<p>Split dataframe Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the splitting event.\nsplit_config: the splitting configuration that is used.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.split.split_event.SplitDataframeEventArgs.__init__", "modulename": "src.fairreckitlib.data.split.split_event", "qualname": "SplitDataframeEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    split_config: src.fairreckitlib.data.split.split_config.SplitConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_event.print_split_event_args", "modulename": "src.fairreckitlib.data.split.split_event", "qualname": "print_split_event_args", "type": "function", "doc": "<p>Print split dataframe event arguments.</p>\n\n<p>It is assumed that the event started when elapsed_time is None and is finished otherwise.</p>\n\n<p>Args:\n    event_args: the arguments to print.\n    elapsed_time: the time that has passed since the splitting started, expressed in seconds.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.data.split.split_event.SplitDataframeEventArgs,\n    elapsed_time: float = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_factory", "modulename": "src.fairreckitlib.data.split.split_factory", "type": "module", "doc": "<p>This module contains functionality to create a splitters factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_split_factory: create a factory with data splitters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_factory.create_split_factory", "modulename": "src.fairreckitlib.data.split.split_factory", "qualname": "create_split_factory", "type": "function", "doc": "<p>Create a Factory with all data splitters.</p>\n\n<p>Returns:\n    the factory with all available splitters.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.temporal_splitter", "modulename": "src.fairreckitlib.data.split.temporal_splitter", "type": "module", "doc": "<p>This module contains time splitting functionality.</p>\n\n<p>Classes:</p>\n\n<pre><code>TemporalSplitter: can split on timestamp.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_temporal_splitter: create an instance of the class (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.temporal_splitter.TemporalSplitter", "modulename": "src.fairreckitlib.data.split.temporal_splitter", "qualname": "TemporalSplitter", "type": "class", "doc": "<p>Temporal Splitter.</p>\n\n<p>Splits the dataframe into a train and test set based on time user-by-user.</p>\n", "bases": "src.fairreckitlib.data.split.base_splitter.DataSplitter"}, {"fullname": "src.fairreckitlib.data.split.temporal_splitter.TemporalSplitter.run", "modulename": "src.fairreckitlib.data.split.temporal_splitter", "qualname": "TemporalSplitter.run", "type": "function", "doc": "<p>Split the dataframe into a train and test set.</p>\n\n<p>For this function to work, it needs a 'user' and 'timestamp' column.</p>\n\n<p>Args:\n    dataframe: with at least the 'user' column.</p>\n\n<p>Returns:\n    the train and test set dataframes of the split.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.temporal_splitter.create_temporal_splitter", "modulename": "src.fairreckitlib.data.split.temporal_splitter", "qualname": "create_temporal_splitter", "type": "function", "doc": "<p>Create the Temporal Splitter.</p>\n\n<p>Returns:\n    the temporal data splitter.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.data.split.temporal_splitter.TemporalSplitter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation", "modulename": "src.fairreckitlib.evaluation", "type": "module", "doc": "<p>This package contains functionality for evaluation/metric computations.</p>\n\n<p>Modules:</p>\n\n<pre><code>evaluation_factory: create evaluation factory with available predictor/recommender factories.\nevaluation_sets: evaluation sets file paths and dataframes definition.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>metrics: functionality to evaluate performance of computed ratings using metrics.\npipeline: run various metric computations for multiple computed rating sets.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_factory", "modulename": "src.fairreckitlib.evaluation.evaluation_factory", "type": "module", "doc": "<p>This module contains functionality to create an evaluation factory.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_EVALUATION: key that is used to identify evaluation.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_evaluation_factory: create factory with prediction/recommendation factories.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_factory.create_evaluation_factory", "modulename": "src.fairreckitlib.evaluation.evaluation_factory", "qualname": "create_evaluation_factory", "type": "function", "doc": "<p>Create a factory with all predictor and recommender metric category factories.</p>\n\n<p>All the metric category factories are shared between prediction and recommendation,\nexcept for ths accuracy category which only applies to recommendation evaluation.</p>\n\n<p>Returns:\n    the group factory with available predictor and recommender factories.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_sets", "modulename": "src.fairreckitlib.evaluation.evaluation_sets", "type": "module", "doc": "<p>This module contains evaluation sets file paths and dataframes definition.</p>\n\n<p>Classes:</p>\n\n<pre><code>EvaluationSetPaths: the file paths of the evaluation sets.\nEvaluationSets: the dataframes of the evaluation sets.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_sets.EvaluationSetPaths", "modulename": "src.fairreckitlib.evaluation.evaluation_sets", "qualname": "EvaluationSetPaths", "type": "class", "doc": "<p>Evaluation set file paths.</p>\n\n<p>ratings_path: the computed rating set file path.\ntrain_path: the train set file path.\ntest_path: the test set file path.</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_sets.EvaluationSetPaths.__init__", "modulename": "src.fairreckitlib.evaluation.evaluation_sets", "qualname": "EvaluationSetPaths.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, ratings_path: str, train_path: str, test_path: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets", "modulename": "src.fairreckitlib.evaluation.evaluation_sets", "qualname": "EvaluationSets", "type": "class", "doc": "<p>Evaluation set dataframes.</p>\n\n<p>ratings: the computed ratings set.\ntrain: the train set or None when not needed for evaluation.\ntest: the test set or None when not needed for evaluation.</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets.__init__", "modulename": "src.fairreckitlib.evaluation.evaluation_sets", "qualname": "EvaluationSets.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    ratings: pandas.core.frame.DataFrame,\n    train: Optional[pandas.core.frame.DataFrame],\n    test: Optional[pandas.core.frame.DataFrame]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics", "modulename": "src.fairreckitlib.evaluation.metrics", "type": "module", "doc": "<p>This package contains functionality to evaluate performance of computed ratings using metrics.</p>\n\n<p>Modules:</p>\n\n<pre><code>base_metric: base class for all metrics.\nmetric_constants: constants that are used in other modules.\nmetric_factory: create and resolve metric factories for various metric categories.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>lenskit: accuracy and rating metric implementations.\nrexmex: coverage and rating metric implementations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit", "type": "module", "doc": "<p>This package contains functionality for metrics of the LensKit package.</p>\n\n<p>Modules:</p>\n\n<pre><code>lenskit_accuracy_metric: class for accuracy metric implementation and creation functions.\nlenskit_rating_metric: class for rating metric implementation and creation functions.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "type": "module", "doc": "<p>This module contains the lenskit accuracy metric and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>LensKitAccuracyMetric: accuracy metric implementation for lenskit.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_ndcg: create the NDCG@K accuracy metric (factory creation compatible).\ncreate_hit_ratio: create the HR@K accuracy metric (factory creation compatible).\ncreate_precision: create the P@K accuracy metric (factory creation compatible).\ncreate_recall: create the R@K accuracy metric (factory creation compatible).\ncreate_mean_recip_rank: create the MRR accuracy metric (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.LensKitAccuracyMetric", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "qualname": "LensKitAccuracyMetric", "type": "class", "doc": "<p>Accuracy metric implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.evaluation.metrics.metric_base.BaseMetric"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.LensKitAccuracyMetric.__init__", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "qualname": "LensKitAccuracyMetric.__init__", "type": "function", "doc": "<p>Construct the lenskit accuracy metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: the parameters of the metric.\n    eval_func: the lenskit evaluation function.\n    group: the group name of the lenskit evaluation function.</p>\n", "signature": "(\n    self,\n    name: str,\n    params: Dict[str, Any],\n    eval_func: Callable[[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame], pandas.core.frame.DataFrame],\n    group: str\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.LensKitAccuracyMetric.on_evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "qualname": "LensKitAccuracyMetric.on_evaluate", "type": "function", "doc": "<p>Evaluate the sets for the performance of the metric.</p>\n\n<p>Args:\n    eval_sets: the sets to use for computing the performance of the metric.</p>\n\n<p>Returns:\n    the evaluated performance.</p>\n", "signature": "(\n    self,\n    eval_sets: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets\n) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.create_ndcg", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "qualname": "create_ndcg", "type": "function", "doc": "<p>Create the NDCG@K accuracy metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: containing the following name-value pairs:\n        K(int): the number of item recommendations to test on.</p>\n\n<p>Returns:\n    the LensKitAccuracyMetric wrapper of NDCG@K.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.LensKitAccuracyMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.create_hit_ratio", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "qualname": "create_hit_ratio", "type": "function", "doc": "<p>Create the HR@K accuracy metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: containing the following name-value pairs:\n        K(int): the number of item recommendations to test on.</p>\n\n<p>Returns:\n    the LensKitAccuracyMetric wrapper of HR@K.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.LensKitAccuracyMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.create_precision", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "qualname": "create_precision", "type": "function", "doc": "<p>Create the P@K accuracy metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: containing the following name-value pairs:\n        K(int): the number of item recommendations to test on.</p>\n\n<p>Returns:\n    the LensKitAccuracyMetric wrapper of P@K.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.LensKitAccuracyMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.create_recall", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "qualname": "create_recall", "type": "function", "doc": "<p>Create the R@K accuracy metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: containing the following name-value pairs:\n        K(int): the number of item recommendations to test on.</p>\n\n<p>Returns:\n    the LensKitAccuracyMetric wrapper of R@K.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.LensKitAccuracyMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.create_mean_recip_rank", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric", "qualname": "create_mean_recip_rank", "type": "function", "doc": "<p>Create the MRR accuracy metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: there are no parameters for this metric.</p>\n\n<p>Returns:\n    the LensKitAccuracyMetric wrapper of MRR.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.lenskit.lenskit_accuracy_metric.LensKitAccuracyMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric", "type": "module", "doc": "<p>This module contains the lenskit rating metric and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>LensKitRatingMetric: rating metric implementation for lenskit.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_mae: create the MAE rating metric (factory creation compatible).\ncreate_rmse: create the RMSE rating metric (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric.LensKitRatingMetric", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric", "qualname": "LensKitRatingMetric", "type": "class", "doc": "<p>Rating metric implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.evaluation.metrics.metric_base.ColumnMetric"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric.LensKitRatingMetric.on_evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric", "qualname": "LensKitRatingMetric.on_evaluate", "type": "function", "doc": "<p>Evaluate the sets for the performance of the metric.</p>\n\n<p>Args:\n    eval_sets: the sets to use for computing the performance of the metric.</p>\n\n<p>Returns:\n    the evaluated performance.</p>\n", "signature": "(\n    self,\n    eval_sets: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets\n) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric.create_mae", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric", "qualname": "create_mae", "type": "function", "doc": "<p>Create the MAE rating metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: there are no parameters for this metric.</p>\n\n<p>Returns:\n    the LensKitAccuracyMetric wrapper of MAE.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric.LensKitRatingMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric.create_rmse", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric", "qualname": "create_rmse", "type": "function", "doc": "<p>Create the RMSE rating metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: there are no parameters for this metric.</p>\n\n<p>Returns:\n    the LensKitAccuracyMetric wrapper of RMSE.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.lenskit.lenskit_rating_metric.LensKitRatingMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "type": "module", "doc": "<p>This module contains the base class for all metrics.</p>\n\n<p>Classes:</p>\n\n<pre><code>BaseMetric: the base class for metrics.\nColumnMetric: metric that uses two columns to compute the evaluation.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base.BaseMetric", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "qualname": "BaseMetric", "type": "class", "doc": "<p>Base class for FairRecKit metrics.</p>\n\n<p>A metric is used for evaluating the performance of recommender system experiments.\nDerived metrics are expected to implement the abstract interface.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_evaluate</p>\n\n<p>Public methods:</p>\n\n<p>evaluate\nget_name\nget_params</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base.BaseMetric.__init__", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "qualname": "BaseMetric.__init__", "type": "function", "doc": "<p>Construct the metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: the parameters of the metric.\n    requires_test_set: whether the metric requires the test set for evaluation.\n    requires_train_set: whether the metric requires the train set for evaluation.</p>\n", "signature": "(\n    self,\n    name: str,\n    params: Dict[str, Any],\n    *,\n    requires_test_set: bool = True,\n    requires_train_set: bool = False\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base.BaseMetric.on_evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "qualname": "BaseMetric.on_evaluate", "type": "function", "doc": "<p>Evaluate the sets for the performance of the metric.</p>\n\n<p>Derived classes should implement the evaluation logic of the metric.</p>\n\n<p>Args:\n    eval_sets: the sets to use for computing the performance of the metric.</p>\n\n<p>Returns:\n    the evaluated performance.</p>\n", "signature": "(\n    self,\n    eval_sets: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets\n) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base.BaseMetric.evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "qualname": "BaseMetric.evaluate", "type": "function", "doc": "<p>Evaluate the sets for the performance of the metric.</p>\n\n<p>Args:\n    eval_sets: the sets to use for computing the performance of the metric.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a metric on evaluation.\n    MemoryError: possibly raised by a metric on evaluation.\n    RuntimeError: when one of the required evaluation sets is None.</p>\n\n<p>Returns:\n    the evaluated performance.</p>\n", "signature": "(\n    self,\n    eval_sets: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets\n) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base.BaseMetric.get_name", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "qualname": "BaseMetric.get_name", "type": "function", "doc": "<p>Get the name of the metric.</p>\n\n<p>Returns:\n    the metric name.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base.BaseMetric.get_params", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "qualname": "BaseMetric.get_params", "type": "function", "doc": "<p>Get the parameters of the metric.</p>\n\n<p>Returns:\n    the metric parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base.ColumnMetric", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "qualname": "ColumnMetric", "type": "class", "doc": "<p>Metric that uses two columns to produce the performance evaluation.</p>\n\n<p>The intended use of this class is to provide a base implementation for\ncomputing the evaluation using two pandas Series columns. The actual data\nthat is provided in these columns can be anything depending on the derived class.</p>\n", "bases": "BaseMetric"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_base.ColumnMetric.__init__", "modulename": "src.fairreckitlib.evaluation.metrics.metric_base", "qualname": "ColumnMetric.__init__", "type": "function", "doc": "<p>Construct the column metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: the parameters of the metric.\n    eval_func: the evaluation function that uses two columns to compute the evaluation.\n    requires_test_set: whether the metric requires the test set for evaluation.\n    requires_train_set: whether the metric requires the train set for evaluation.</p>\n", "signature": "(\n    self,\n    name: str,\n    params: Dict[str, Any],\n    eval_func: Callable[[pandas.core.series.Series, pandas.core.series.Series], float],\n    *,\n    requires_test_set: bool = True,\n    requires_train_set: bool = False\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "type": "module", "doc": "<p>This module contains metric constants that are used in other modules.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_METRIC_PARAM_K: the key that is used for the metric parameter K.\nKEY_METRIC_EVALUATION: the key that is used to identify a metric evaluation.\nKEY_METRIC_SUBGROUP: the key that is used to identify a metric subgroup.\n</code></pre>\n\n<p>Enumerations:</p>\n\n<pre><code>MetricCategory: the category of evaluation for a metric.\nMetric: the names of various metrics.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.MetricCategory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "MetricCategory", "type": "class", "doc": "<p>Metric category of evaluation.</p>\n", "bases": "enum.Enum"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.MetricCategory.ACCURACY", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "MetricCategory.ACCURACY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.ACCURACY: 'Accuracy'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.MetricCategory.RATING", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "MetricCategory.RATING", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.RATING: 'Rating'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.MetricCategory.COVERAGE", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "MetricCategory.COVERAGE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.COVERAGE: 'Coverage'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.MetricCategory.DIVERSITY", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "MetricCategory.DIVERSITY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.DIVERSITY: 'Diversity'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.MetricCategory.NOVELTY", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "MetricCategory.NOVELTY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.NOVELTY: 'Novelty'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric", "type": "class", "doc": "<p>Known metrics (names).</p>\n", "bases": "enum.Enum"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.HIT_RATIO", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.HIT_RATIO", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.HIT_RATIO: 'HR@K'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.NDCG", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.NDCG", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.NDCG: 'NDCG@K'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.PRECISION", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.PRECISION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.PRECISION: 'P@K'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.RECALL", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.RECALL", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.RECALL: 'R@K'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.MRR", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.MRR", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.MRR: 'MRR'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.ITEM_COVERAGE", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.ITEM_COVERAGE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.ITEM_COVERAGE: 'Item Coverage'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.USER_COVERAGE", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.USER_COVERAGE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.USER_COVERAGE: 'User Coverage'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.GINI", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.GINI", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.GINI: 'Gini Index'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.INTRA_LIST_SIMILARITY", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.INTRA_LIST_SIMILARITY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.INTRA_LIST_SIMILARITY: 'Intra-List Similarity'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.SIMILARITY_COS", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.SIMILARITY_COS", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.SIMILARITY_COS: 'Similarity Cosine'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.SIMILARITY_EUCLID", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.SIMILARITY_EUCLID", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.SIMILARITY_EUCLID: 'Similarity Euclidean'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.RMSE", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.RMSE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.RMSE: 'RMSE'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.MAE", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.MAE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.MAE: 'MAE'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.MAPE", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.MAPE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.MAPE: 'MAPE'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_constants.Metric.MSE", "modulename": "src.fairreckitlib.evaluation.metrics.metric_constants", "qualname": "Metric.MSE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.MSE: 'MSE'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "type": "module", "doc": "<p>This module contains functionality to create and resolve metric factories.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_metric_params_k: create metric config parameters with a K param.\ncreate_accuracy_metric_factory: create metric category factory for accuracy metrics.\ncreate_coverage_metric_factory: create metric category factory for coverage metrics.\ncreate_rating_metric_factory: create metric category factory for rating metrics.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_metric_params_k", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_metric_params_k", "type": "function", "doc": "<p>Create the parameters of a metric that utilizes the K param.</p>\n\n<p>Returns:\n    the configuration parameters of the metric.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_accuracy_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_accuracy_metric_factory", "type": "function", "doc": "<p>Create the factory with Accuracy metrics.</p>\n\n<p>Returns:\n    the factory with all available metrics.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_coverage_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_coverage_metric_factory", "type": "function", "doc": "<p>Create the factory with Coverage metrics.</p>\n\n<p>Returns:\n    the factory with all available metrics.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_rating_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_rating_metric_factory", "type": "function", "doc": "<p>Create the factory with Rating metrics.</p>\n\n<p>Returns:\n    the factory with all available metrics.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex", "type": "module", "doc": "<p>This package contains functionality for metrics of the Rexmex package.</p>\n\n<p>Modules:</p>\n\n<pre><code>rexmex_coverage_metric: class for coverage metric implementation and creation functions.\nrexmex_rating_metric: class for rating metric implementation and creation functions.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric", "type": "module", "doc": "<p>This module contains the rexmex coverage metric and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>RexmexCoverageMetric: coverage metric implementation for rexmex.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_item_coverage: create the Item coverage metric (factory creation compatible).\ncreate_user_coverage: create the User coverage metric (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric.RexmexCoverageMetric", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric", "qualname": "RexmexCoverageMetric", "type": "class", "doc": "<p>Coverage metric implementation for the Rexmex framework.</p>\n", "bases": "src.fairreckitlib.evaluation.metrics.metric_base.ColumnMetric"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric.RexmexCoverageMetric.__init__", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric", "qualname": "RexmexCoverageMetric.__init__", "type": "function", "doc": "<p>Construct the Rexmex coverage metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: the parameters of the metric.\n    eval_func: the function that uses the user and item columns to compute the evaluation.</p>\n", "signature": "(\n    self,\n    name: str,\n    params: Dict[str, Any],\n    eval_func: Callable[[pandas.core.series.Series, pandas.core.series.Series], float]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric.RexmexCoverageMetric.on_evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric", "qualname": "RexmexCoverageMetric.on_evaluate", "type": "function", "doc": "<p>Evaluate the sets for the performance of the metric.</p>\n\n<p>Args:\n    eval_sets: the sets to use for computing the performance of the metric.</p>\n\n<p>Returns:\n    the evaluated performance.</p>\n", "signature": "(\n    self,\n    eval_sets: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets\n) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric.create_item_coverage", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric", "qualname": "create_item_coverage", "type": "function", "doc": "<p>Create the Item coverage metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: there are no parameters for this metric.</p>\n\n<p>Returns:\n    the RexmexCoverageMetric wrapper of Item coverage.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric.RexmexCoverageMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric.create_user_coverage", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric", "qualname": "create_user_coverage", "type": "function", "doc": "<p>Create the User coverage metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: there are no parameters for this metric.</p>\n\n<p>Returns:\n    the RexmexCoverageMetric wrapper of User coverage.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.rexmex.rexmex_coverage_metric.RexmexCoverageMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric", "type": "module", "doc": "<p>This module contains the rexmex rating metric and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>RexmexRatingMetric: rating metric implementation for rexmex.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_mape: create the MAPE rating metric (factory creation compatible).\ncreate_mse: create the MSE rating metric (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric.RexmexRatingMetric", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric", "qualname": "RexmexRatingMetric", "type": "class", "doc": "<p>Rating metric implementation for the Rexmex framework.</p>\n", "bases": "src.fairreckitlib.evaluation.metrics.metric_base.ColumnMetric"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric.RexmexRatingMetric.on_evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric", "qualname": "RexmexRatingMetric.on_evaluate", "type": "function", "doc": "<p>Evaluate the sets for the performance of the metric.</p>\n\n<p>Args:\n    eval_sets: the sets to use for computing the performance of the metric.</p>\n\n<p>Raises:\n    ArithmeticError: when the merged test and rating set does not contain truth values.</p>\n\n<p>Returns:\n    the evaluated performance.</p>\n", "signature": "(\n    self,\n    eval_sets: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets\n) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric.create_mape", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric", "qualname": "create_mape", "type": "function", "doc": "<p>Create the MAPE rating metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: there are no parameters for this metric.</p>\n\n<p>Returns:\n    the RexmexRatingMetric wrapper of MAPE.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric.RexmexRatingMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric.create_mse", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric", "qualname": "create_mse", "type": "function", "doc": "<p>Create the MSE rating metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: there are no parameters for this metric.</p>\n\n<p>Returns:\n    the RexmexRatingMetric wrapper of MSE.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **_\n) -> src.fairreckitlib.evaluation.metrics.rexmex.rexmex_rating_metric.RexmexRatingMetric", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline", "modulename": "src.fairreckitlib.evaluation.pipeline", "type": "module", "doc": "<p>This package contains functionality for running the evaluation pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>evaluation_config: evaluation configuration class.\nevaluation_config_parsing: parse metric configuration(s).\nevaluation_event: event ids, event args and a print switch for the evaluation pipeline.\nevaluation_pipeline: the evaluation pipeline class.\nevaluation_run: run (multiple) evaluation pipelines for each computed ratings set.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "type": "module", "doc": "<p>This module contains the metric configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>MetricConfig: metric configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "qualname": "MetricConfig", "type": "class", "doc": "<p>Metric Configuration.</p>\n\n<p>name: the name of the metric.\nparams: the parameters of the metric.\nsubgroup: the subgroup of the metric.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "qualname": "MetricConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    params: Dict[str, Any],\n    subgroup: Optional[src.fairreckitlib.data.filter.filter_config.DataSubsetConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig.to_yml_format", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "qualname": "MetricConfig.to_yml_format", "type": "function", "doc": "<p>Format metric configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the metric configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the evaluation and metric configuration(s).</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_evaluation_config: parse all metric configurations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing.parse_evaluation_config", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing", "qualname": "parse_evaluation_config", "type": "function", "doc": "<p>Parse all metric configurations.</p>\n\n<p>Args:\n    data_registry: the data registry with available dataset matrices.\n    data_filter_factory: the dataset filter group factory.\n    experiment_config: the experiment's total configuration.\n    metric_category_factory: the metric factory containing grouped available metrics.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a list of parsed MetricConfig's which is possibly empty.</p>\n", "signature": "(\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    data_filter_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    experiment_config: Dict[str, Any],\n    metric_category_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch for the evaluation pipeline.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_BEGIN_EVAL_PIPELINE: id of the event that is used when the evaluation pipeline starts.\nON_BEGIN_FILTER_RECS: id of the event that is used when recs filtering starts.\nON_BEGIN_LOAD_RATING_SET: id of the event that is used when a rating set is being loaded.\nON_BEGIN_LOAD_TEST_SET: id of the event that is used when a test set is being loaded.\nON_BEGIN_LOAD_TRAIN_SET: id of the event that is used when a train set is being loaded.\nON_BEGIN_METRIC: id of the event that is used when a metric computation started.\nON_END_EVAL_PIPELINE: id of the event that is used when the evaluation pipeline ends.\nON_END_FILTER_RECS: id of the event that is used when recs filtering finishes.\nON_END_LOAD_RATING_SET: id of the event that is used when a rating set has been loaded.\nON_END_LOAD_TEST_SET: id of the event that is used when a test set has been loaded.\nON_END_LOAD_TRAIN_SET: id of the event that is used when a train set has been loaded.\nON_END_METRIC: id of the event that is used when a metric computation finishes.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>EvaluationPipelineEventArgs: event args related to the evaluation pipeline.\nMetricEventArgs: event args related to a metric.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_eval_events: list of evaluation pipeline event IDs.\nget_eval_event_print_switch: switch to print evaluation pipeline event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.EvaluationPipelineEventArgs", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "EvaluationPipelineEventArgs", "type": "class", "doc": "<p>Evaluation Pipeline Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the evaluation pipeline event.\nmetrics_config: list of metric configurations that is used in the evaluation pipeline.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.EvaluationPipelineEventArgs.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "EvaluationPipelineEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    metrics_config: List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.MetricEventArgs", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "MetricEventArgs", "type": "class", "doc": "<p>Evaluation Pipeline Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the metric event.\nmetric_config: the metric configuration that is used.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.MetricEventArgs.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "MetricEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    metric_config: src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.get_eval_events", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "get_eval_events", "type": "function", "doc": "<p>Get a list of evaluation pipeline event IDs.</p>\n\n<p>Returns:\n    a list of unique evaluation pipeline event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.get_eval_event_print_switch", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "get_eval_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints evaluation pipeline event IDs.</p>\n\n<p>Returns:\n    the print evaluation pipeline event switch.</p>\n", "signature": "(\n    elapsed_time: float = None\n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "type": "module", "doc": "<p>This module contains base functionality of the complete evaluation pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>EvaluationPipeline: class that runs multiple metric computations for a specific evaluation set.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>add_evaluation_to_file: append computed evaluation to a result file.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline", "type": "class", "doc": "<p>Evaluation Pipeline to run metric computations for ratings related to a dataset.</p>\n\n<p>The pipeline is intended to be used multiple times on different computed rating files\nthat are all associated to a specific dataset.\nLoading the evaluation sets is done each time for every metric configuration, so that\nthey can be filtered individually on subgroups before computing the actual evaluation.\nFor each metric it executes the following steps:</p>\n\n<p>1) create the metric.\n2) load the evaluation sets.\n3) filter the evaluation sets (optional).\n4) compute the evaluation of the metric.\n5) store evaluations in an overview file.</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n", "bases": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.__init__", "type": "function", "doc": "<p>Construct the evaluation pipeline.</p>\n\n<p>Args:\n    dataset: the dataset that is associated with the evaluation of the rating sets.\n    data_filter_factory: the factory with available filters for all dataset-matrix pairs.\n    metric_category_factory: the metric category factory with available metric factories.\n    event_dispatcher: used to dispatch model/IO events when running the pipeline.</p>\n", "signature": "(\n    self,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    data_filter_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    metric_category_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.run", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.run", "type": "function", "doc": "<p>Run the entire pipeline from beginning to end.</p>\n\n<p>Effectively running all computations of the specified metrics.\nAll the specified metric configurations that have a subgroup are expected\nto be related to the dataset that was used to construct the pipeline.</p>\n\n<p>Args:\n    output_path: the path of the json file to store the output.\n    eval_set_paths: the file paths of the evaluation sets.\n    metric_config_list: list of MetricConfig objects to compute.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    reserved for future use</p>\n", "signature": "(\n    self,\n    output_path: str,\n    eval_set_paths: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSetPaths,\n    metric_config_list: List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig],\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.run_metric", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.run_metric", "type": "function", "doc": "<p>Run the evaluation computation for the specified metric configuration.</p>\n\n<p>Args:\n    output_path: the path of the json file to store the output.\n    metric_factory: the factory that contains the specified metric.\n    eval_set_paths: the file paths of the evaluation sets.\n    metric_config: the metric evaluation configuration.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a metric on construction or evaluation.\n    MemoryError: possibly raised by a metric on construction or evaluation.\n    RuntimeError: possibly raised by a metric on construction or evaluation.\n    FileNotFoundError: when the file of one of the evaluation sets does not exist.</p>\n\n<p>Keyword Args:\n    reserved for future use</p>\n", "signature": "(\n    self,\n    output_path: str,\n    metric_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    eval_set_paths: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSetPaths,\n    metric_config: src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.load_evaluation_sets", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.load_evaluation_sets", "type": "function", "doc": "<p>Load the required evaluation sets.</p>\n\n<p>Args:\n    eval_set_paths: the file paths of the evaluation sets.\n    train_set_required: whether the train set is required for the evaluation.\n    test_set_required: whether the test set is required for the evaluation.</p>\n\n<p>Raises:\n    FileNotFoundError: when the file of one of the evaluation sets does not exist.</p>\n\n<p>Returns:\n    the loaded evaluation sets.</p>\n", "signature": "(\n    self,\n    eval_set_paths: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSetPaths,\n    train_set_required: bool,\n    test_set_required: bool\n) -> src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.filter_set_rows", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.filter_set_rows", "type": "function", "doc": "<p>Filter the evaluation set rows for the specified subgroup.</p>\n\n<p>The subset is created by applying multiple filter passes to the evaluation sets\nindividually. These filter passes are then combined to form the resulting sets.</p>\n\n<p>Args:\n    eval_sets: the evaluation sets to filter.\n    subgroup: the subgroup to create of the evaluation sets.</p>\n\n<p>Returns:\n    the filtered evaluation sets.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    eval_sets: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets,\n    subgroup: Optional[src.fairreckitlib.data.filter.filter_config.DataSubsetConfig]\n) -> src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.compute_metric_evaluation", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.compute_metric_evaluation", "type": "function", "doc": "<p>Compute the evaluation for the specified metric on the specified sets.</p>\n\n<p>Args:\n    metric: the metric to use for computing the evaluation.\n    eval_sets: the evaluation sets to compute the performance of.\n    metric_config: the metric configuration that is associated with the metric.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a metric on evaluation.\n    MemoryError: possibly raised by a metric on evaluation.\n    RuntimeError: possibly raised by a metric on evaluation.</p>\n\n<p>Returns:\n    the computed evaluation of the metric.</p>\n", "signature": "(\n    self,\n    metric: src.fairreckitlib.evaluation.metrics.metric_base.BaseMetric,\n    eval_sets: src.fairreckitlib.evaluation.evaluation_sets.EvaluationSets,\n    metric_config: src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig\n) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.add_evaluation_to_file", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "add_evaluation_to_file", "type": "function", "doc": "<p>Add an evaluation result to the list in the overview file.</p>\n\n<p>Args:\n    file_path: the path to the evaluations overview file.\n    evaluation_value: the evaluation result.\n    metric_config: the metric configuration used for the evaluation.</p>\n", "signature": "(\n    file_path: str,\n    evaluation_value: float,\n    metric_config: src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "type": "module", "doc": "<p>This module contains functionality that wraps running the evaluation pipeline multiple times.</p>\n\n<p>Classes:</p>\n\n<pre><code>EvaluationPipelineConfig: configuration class to run the evaluation pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>run_evaluation_pipelines: run (multiple) pipelines for specified metric configurations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_run.EvaluationPipelineConfig", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "qualname": "EvaluationPipelineConfig", "type": "class", "doc": "<p>Evaluation Pipeline Configuration.</p>\n\n<p>output_dir: the directory to store the output.\ndata_transition: data input.\ndata_filter_factory: the factory with available filters for all dataset-matrix pairs.\neval_type_factory: the factory with available metric category factories.\nmetric_config_list: list of metric configurations to compute.</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_run.EvaluationPipelineConfig.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "qualname": "EvaluationPipelineConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    model_dirs: List[str],\n    data_transition: src.fairreckitlib.data.data_transition.DataTransition,\n    data_filter_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    eval_type_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    metric_config_list: List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_run.run_evaluation_pipelines", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "qualname": "run_evaluation_pipelines", "type": "function", "doc": "<p>Run several evaluation pipelines according to the specified eval pipeline configuration.</p>\n\n<p>Args:\n    pipeline_config: the configuration on how to run the evaluation pipelines.\n    event_dispatcher: used to dispatch eval/IO events when running the evaluation pipelines.\n    is_running: function that returns whether the pipelines\n        are still running. Stops early when False is returned.</p>\n", "signature": "(\n    pipeline_config: src.fairreckitlib.evaluation.pipeline.evaluation_run.EvaluationPipelineConfig,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    is_running: Callable[[], bool]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment", "modulename": "src.fairreckitlib.experiment", "type": "module", "doc": "<p>This package contains functionality for running the experiment pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>experiment_config: experiment configuration classes.\nexperiment_config_parser: parser for an experiment configuration.\nexperiment_event: event ids, event args and a print switch for the experiment pipeline/thread.\nexperiment_pipeline: the experiment pipeline class.\nexperiment_run: run (multiple) experiment pipelines.\nexperiment_thread: execute the experiment pipelines on a thread.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config", "modulename": "src.fairreckitlib.experiment.experiment_config", "type": "module", "doc": "<p>This module contains the experiment configurations.</p>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentConfig: base experiment configuration.\nPredictorExperimentConfig: a prediction experiment configuration.\nRecommenderExperimentConfig: a recommender experiment configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.ExperimentConfig", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "ExperimentConfig", "type": "class", "doc": "<p>Base Experiment Configuration.</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.ExperimentConfig.get_type", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "ExperimentConfig.get_type", "type": "function", "doc": "<p>Get the type of the experiment configuration.</p>\n\n<p>Returns:\n    the experiment type.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.ExperimentConfig.to_yml_format", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "ExperimentConfig.to_yml_format", "type": "function", "doc": "<p>Format experiment configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the experiment configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "PredictorExperimentConfig", "type": "class", "doc": "<p>Prediction Experiment Configuration.</p>\n", "bases": "ExperimentConfig"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig.__init__", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "PredictorExperimentConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    datasets: List[src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig],\n    models: Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]],\n    evaluation: List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig],\n    name: str\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig.get_type", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "PredictorExperimentConfig.get_type", "type": "function", "doc": "<p>Get the predictor experiment type.</p>\n\n<p>Returns:\n    TYPE_PREDICTION.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "RecommenderExperimentConfig", "type": "class", "doc": "<p>Recommender Experiment Configuration.</p>\n", "bases": "ExperimentConfig"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig.__init__", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "RecommenderExperimentConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    datasets: List[src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig],\n    models: Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]],\n    evaluation: List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig],\n    name: str,\n    top_k: int,\n    rated_items_filter: bool\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig.get_type", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "RecommenderExperimentConfig.get_type", "type": "function", "doc": "<p>Get the recommender experiment type.</p>\n\n<p>Returns:\n    TYPE_RECOMMENDATION.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig.to_yml_format", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "RecommenderExperimentConfig.to_yml_format", "type": "function", "doc": "<p>Format recommender experiment configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the experiment configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "type": "module", "doc": "<p>This module contains a parser for the experiment configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentConfigParser: parse an experiment configuration from a dictionary or yml.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser.ExperimentConfigParser", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "qualname": "ExperimentConfigParser", "type": "class", "doc": "<p>Experiment Configuration Parser.</p>\n\n<p>Public methods:</p>\n\n<p>parse_experiment_config\nparse_experiment_config_from_yml</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser.ExperimentConfigParser.__init__", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "qualname": "ExperimentConfigParser.__init__", "type": "function", "doc": "<p>Construct the ExperimentConfigParser.</p>\n\n<p>Args:\n    verbose: whether the parser should give verbose output.</p>\n", "signature": "(self, verbose: bool)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser.ExperimentConfigParser.parse_experiment_config", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "qualname": "ExperimentConfigParser.parse_experiment_config", "type": "function", "doc": "<p>Parse an experiment configuration.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.\n    data_registry: the data registry containing the available datasets.\n    experiment_factory: the factory containing all three pipeline factories.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    experiment_config: Any,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    experiment_factory: src.fairreckitlib.core.config.config_factories.GroupFactory\n) -> Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig, NoneType]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser.ExperimentConfigParser.parse_experiment_config_from_yml", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "qualname": "ExperimentConfigParser.parse_experiment_config_from_yml", "type": "function", "doc": "<p>Parse an experiment configuration from a yml file.</p>\n\n<p>Args:\n    file_path: path to the yml file without extension.\n    data_registry: the data registry containing the available datasets.\n    experiment_factory: the factory containing all three pipeline factories.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    file_path: str,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    experiment_factory: src.fairreckitlib.core.config.config_factories.GroupFactory\n) -> Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig, NoneType]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser.ExperimentConfigParser.parse_experiment_name", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "qualname": "ExperimentConfigParser.parse_experiment_name", "type": "function", "doc": "<p>Parse the name of the experiment.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.</p>\n\n<p>Returns:\n    the name of the experiment or None on failure.</p>\n", "signature": "(self, experiment_config: Dict[str, Any]) -> Optional[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser.ExperimentConfigParser.parse_experiment_rated_items_filter", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "qualname": "ExperimentConfigParser.parse_experiment_rated_items_filter", "type": "function", "doc": "<p>Parse the rated items filter of the recommender experiment.</p>\n\n<p>Args:\n    recommender_experiment_config: the experiment's total configuration.</p>\n\n<p>Returns:\n    the rated items filter of the experiment or True on failure.</p>\n", "signature": "(self, recommender_experiment_config: Dict[str, Any]) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser.ExperimentConfigParser.parse_experiment_top_k", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "qualname": "ExperimentConfigParser.parse_experiment_top_k", "type": "function", "doc": "<p>Parse the top K of the recommender experiment.</p>\n\n<p>Args:\n    recommender_experiment_config: the experiment's total configuration.</p>\n\n<p>Returns:\n    the topK of the experiment or default_top_k on failure.</p>\n", "signature": "(self, recommender_experiment_config: Dict[str, Any]) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parser.ExperimentConfigParser.parse_experiment_type", "modulename": "src.fairreckitlib.experiment.experiment_config_parser", "qualname": "ExperimentConfigParser.parse_experiment_type", "type": "function", "doc": "<p>Parse the type of the experiment.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.</p>\n\n<p>Returns:\n    the type of the experiment or None on failure.</p>\n", "signature": "(self, experiment_config: Dict[str, Any]) -> Optional[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_event", "modulename": "src.fairreckitlib.experiment.experiment_event", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch for the experiment pipeline.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_BEGIN_EXPERIMENT_PIPELINE: id of the event that is used when the experiment pipeline starts.\nON_END_EXPERIMENT_PIPELINE: id of the event that is used when the experiment pipeline ends.\nON_BEGIN_THREAD_EXPERIMENT: id of the event that is used when the experiment thread starts.\nON_END_THREAD_EXPERIMENT: id of the event that is used when the experiment thread ends.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentEventArgs: event args related to an experiment.\nExperimentThreadEventArgs: event args related to an experiment thread.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_experiment_events: list of experiment pipeline event IDs.\nget_experiment_event_print_switch: switch to print experiment pipeline event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentEventArgs", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentEventArgs", "type": "class", "doc": "<p>Experiment Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the experiment event.\nexperiment_name: the name of the experiment.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentEventArgs.__init__", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, experiment_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentThreadEventArgs", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentThreadEventArgs", "type": "class", "doc": "<p>Experiment Thread Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the experiment event.\nexperiment_name: the name of the experiment.\nnum_runs: the amount of times the experiment will run.\nis_running: whether the experiment thread is running or aborted.</p>\n", "bases": "ExperimentEventArgs"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentThreadEventArgs.__init__", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentThreadEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    experiment_name: str,\n    num_runs: int,\n    is_running: bool = True\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentThreadEventArgs.is_running", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentThreadEventArgs.is_running", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.get_experiment_events", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "get_experiment_events", "type": "function", "doc": "<p>Get a list of experiment pipeline event IDs.</p>\n\n<p>Returns:\n    a list of unique experiment pipeline event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.get_experiment_print_switch", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "get_experiment_print_switch", "type": "function", "doc": "<p>Get a switch that prints experiment pipeline event IDs.</p>\n\n<p>Returns:\n    the print experiment pipeline event switch.</p>\n", "signature": "(\n    elapsed_time: float = None\n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_factory", "modulename": "src.fairreckitlib.experiment.experiment_factory", "type": "module", "doc": "<p>This module contains functionality to create an experiment factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_experiment_factory: create factory with pipeline factories.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_factory.create_experiment_factory", "modulename": "src.fairreckitlib.experiment.experiment_factory", "qualname": "create_experiment_factory", "type": "function", "doc": "<p>Create a group factory with all three pipeline factories.</p>\n\n<p>Consists of three factories:\n    1) data factory.\n    2) model factory.\n    3) evaluation factory.</p>\n\n<p>Returns:\n    the group factory containing the pipeline factories.</p>\n", "signature": "(\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry\n) -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "type": "module", "doc": "<p>This module contains functionality of the complete experiment pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentPipeline: class that connects the data, model and evaluation pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>add_result_to_overview: add a computed result to the experiment result overview.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline", "type": "class", "doc": "<p>ExperimentPipeline that consists of the data, model and evaluation pipelines.</p>\n\n<p>The experiment pipeline connects the three pipelines, by first running the data\npipeline for all the specified dataset configurations. Each of the\nresulting data transitions is forwarded through the model pipelines where all the\nspecified model configurations will compute rating results. These in turn are\nforwarded to the evaluation pipelines to compute the specified metric configurations\nof the performance of the models.</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.__init__", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.__init__", "type": "function", "doc": "<p>Construct the ExperimentPipeline.</p>\n\n<p>Args:\n    data_registry: the registry with available datasets.\n    experiment_factory: the factory containing all three pipeline factories.\n    event_dispatcher: to dispatch the experiment events.</p>\n", "signature": "(\n    self,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    experiment_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.run", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.run", "type": "function", "doc": "<p>Run the experiment with the specified configuration.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    experiment_config: the configuration of the experiment.\n    num_threads: the max number of threads the experiment can use.\n    is_running: function that returns whether the experiment\n        is still running. Stops early when False is returned.</p>\n\n<p>Raises:\n    IOError: when the specified output directory already exists.\n    RuntimeError: when no data transitions are generated by the data or model pipelines.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    experiment_config: Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig],\n    num_threads: int,\n    is_running: Callable[[], bool]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.start_run", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.start_run", "type": "function", "doc": "<p>Start the run, making the output dir and initializing the results' storage list.</p>\n\n<p>Args:\n    output_dir: directory in which to store the run storage output.\n    experiment_config: the configuration of the experiment.</p>\n\n<p>Returns:\n    the initial results list and the time the experiment started.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    experiment_config: src.fairreckitlib.experiment.experiment_config.ExperimentConfig\n) -> Tuple[List[Dict[str, str]], float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.end_run", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.end_run", "type": "function", "doc": "<p>End the run, writing the storage file and storing the results.</p>\n\n<p>Args:\n    start_time: time the experiment started.\n    output_dir: directory in which to store the run storage output.\n    experiment_config: the configuration of the experiment.\n    results: the current results list.</p>\n", "signature": "(\n    self,\n    start_time: float,\n    output_dir: str,\n    experiment_config: src.fairreckitlib.experiment.experiment_config.ExperimentConfig,\n    results: List[Dict[str, str]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.write_storage_file", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.write_storage_file", "type": "function", "doc": "<p>Write a JSON file with overview of the results file paths.</p>\n\n<p>Args:\n    output_dir: path to the directory to store the result overview.\n    results: the result overview containing completed computations.</p>\n", "signature": "(self, output_dir: str, results: List[Dict[str, str]]) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.add_result_to_overview", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "add_result_to_overview", "type": "function", "doc": "<p>Add result to overview of results file paths.</p>\n\n<p>Args:\n    results: the accumulated result overview.\n    model_dirs: the completed computations to add to the overview.</p>\n\n<p>Returns:\n    the result overview appended with the completed computations.</p>\n", "signature": "(\n    results: List[Dict[str, str]],\n    model_dirs: List[str]\n) -> List[Dict[str, str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_run", "modulename": "src.fairreckitlib.experiment.experiment_run", "type": "module", "doc": "<p>This module contains functionality to run the experiment pipelines.</p>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentPipelineConfig: configuration class to run the experiment pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>run_experiment_pipelines: run the pipeline one or more runs.\nresolve_experiment_start_run: resolve the start run of an existing result directory.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_run.ExperimentPipelineConfig", "modulename": "src.fairreckitlib.experiment.experiment_run", "qualname": "ExperimentPipelineConfig", "type": "class", "doc": "<p>Experiment Pipeline Configuration.</p>\n\n<p>output_dir: the directory to store the output.\ndata_registry: the registry with available datasets.\nexperiment_factory: the factory with data/model/evaluation pipeline factories.\nexperiment_config: the experiment configuration to compute.\nstart_run: the experiment run to start with.\nnum_runs: the number of runs of the experiment.\nnum_threads: the max number of threads the experiment can use.</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_run.ExperimentPipelineConfig.__init__", "modulename": "src.fairreckitlib.experiment.experiment_run", "qualname": "ExperimentPipelineConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    experiment_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    experiment_config: Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig],\n    start_run: int,\n    num_runs: int,\n    num_threads: int\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_run.run_experiment_pipelines", "modulename": "src.fairreckitlib.experiment.experiment_run", "qualname": "run_experiment_pipelines", "type": "function", "doc": "<p>Run the experiment pipeline several runs according to the specified pipeline configuration.</p>\n\n<p>Args:\n    pipeline_config: the configuration on how to run the experiment pipelines.\n    event_dispatcher: used to dispatch model/IO events when running the experiment pipelines.\n    is_running: function that returns whether the pipelines\n        are still running. Stops early when False is returned.</p>\n\n<p>Returns:\n    whether running the experiment pipelines succeeded.</p>\n", "signature": "(\n    pipeline_config: src.fairreckitlib.experiment.experiment_run.ExperimentPipelineConfig,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    is_running: Callable[[], bool]\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_run.resolve_experiment_start_run", "modulename": "src.fairreckitlib.experiment.experiment_run", "qualname": "resolve_experiment_start_run", "type": "function", "doc": "<p>Resolve which run will be next in the specified result directory.</p>\n\n<p>Args:\n    result_dir: path to the result directory to look into.</p>\n\n<p>Raises:\n    IOError: when the specified result directory does not exist.</p>\n\n<p>Returns:\n    the next run index for this result directory.</p>\n", "signature": "(result_dir: str) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread", "modulename": "src.fairreckitlib.experiment.experiment_thread", "type": "module", "doc": "<p>This module contains functionality to execute the experiment pipelines on a thread.</p>\n\n<p>Classes:</p>\n\n<pre><code>ThreadExperiment: class that runs the experiment pipelines on a (closable) thread.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>handle_experiment_event: handles incoming experiment events.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread.ThreadExperiment", "modulename": "src.fairreckitlib.experiment.experiment_thread", "qualname": "ThreadExperiment", "type": "class", "doc": "<p>Thread that runs the same experiment one or more times.</p>\n", "bases": "src.fairreckitlib.core.threading.thread_base.ThreadBase"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread.ThreadExperiment.__init__", "modulename": "src.fairreckitlib.experiment.experiment_thread", "qualname": "ThreadExperiment.__init__", "type": "function", "doc": "<p>Construct the ExperimentThread.</p>\n\n<p>Args:\n    name the name of the thread.\n    events: events to dispatch for this thread.\n    verbose: whether the thread should give verbose output.</p>\n\n<p>Keyword Args:\n    pipeline_config(ExperimentPipelineConfig): configuration of the experiment pipeline.</p>\n", "signature": "(\n    self,\n    name: str,\n    events: Dict[Any, Callable[[Any], NoneType]] = None,\n    verbose: bool = False,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread.ThreadExperiment.on_run", "modulename": "src.fairreckitlib.experiment.experiment_thread", "qualname": "ThreadExperiment.on_run", "type": "function", "doc": "<p>Run the experiment pipeline.</p>\n\n<p>Keyword Args:\n    pipeline_config(ExperimentPipelineConfig): configuration of the experiment pipeline.</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread.handle_experiment_event", "modulename": "src.fairreckitlib.experiment.experiment_thread", "qualname": "handle_experiment_event", "type": "function", "doc": "<p>Handle incoming experiment events.</p>\n\n<p>It is assumed that the event finished when the elapsed_time keyword argument is available.</p>\n\n<p>Args:\n    experiment_thread: the listening experiment thread.\n    event_args: the event arguments to handle.</p>\n\n<p>Keyword Args:\n    elapsed_time(float): time that has passed since the event started, expressed in seconds.</p>\n", "signature": "(\n    experiment_thread: src.fairreckitlib.experiment.experiment_thread.ThreadExperiment,\n    event_args: src.fairreckitlib.core.events.event_args.EventArgs,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model", "modulename": "src.fairreckitlib.model", "type": "module", "doc": "<p>This package contains functionality for algorithm/model computations.</p>\n\n<p>Modules:</p>\n\n<pre><code>model_factory: create model factory with available predictor/recommender factories.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>algorithms: prediction/recommender algorithms and implementations.\npipeline: run various model computations with batching.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms", "modulename": "src.fairreckitlib.model.algorithms", "type": "module", "doc": "<p>This package contains functionality for item predictions/recommendations using algorithms.</p>\n\n<p>Modules:</p>\n\n<pre><code>base_algorithm: base class for all algorithms.\nbase_predictor: (base) class for prediction algorithms.\nbase_recommender: (base) class for recommender algorithms.\nmatrix: matrix classes that can be used for algorithm training.\ntop_k_recommender: class to wrap a predictor as a recommender.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>elliot: recommender implementations.\nimplicit: recommender implementations.\nlenskit: predictor/recommender implementations.\nsurprise: predictor/recommender implementations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "type": "module", "doc": "<p>This module contains the base class for all algorithms.</p>\n\n<p>Classes:</p>\n\n<pre><code>BaseAlgorithm: the base class for algorithms.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm", "type": "class", "doc": "<p>Base class for FairRecKit algorithms.</p>\n\n<p>An algorithm is used for carrying out recommender system experiments.\nDerived algorithms are expected to implement the abstract interface.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_train</p>\n\n<p>Public methods:</p>\n\n<p>get_name\nget_num_threads\nget_params\nget_train_set\ntrain</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.__init__", "type": "function", "doc": "<p>Construct the algorithm.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_name", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_name", "type": "function", "doc": "<p>Get the name of the algorithm.</p>\n\n<p>Returns:\n    the algorithm name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_num_threads", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_num_threads", "type": "function", "doc": "<p>Get the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_params", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_params", "type": "function", "doc": "<p>Get the parameters of the algorithm.</p>\n\n<p>Returns:\n    the algorithm parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_train_set", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_train_set", "type": "function", "doc": "<p>Get the train set that the algorithm was trained on.</p>\n\n<p>Returns:\n    the train set matrix or None if the algorithm is not trained yet.</p>\n", "signature": "(self) -> Optional[src.fairreckitlib.model.algorithms.matrix.Matrix]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.train", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.train", "type": "function", "doc": "<p>Train the algorithm on the specified train set.</p>\n\n<p>Args:\n    train_set: the matrix train set.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by an algorithm on training.\n    MemoryError: possibly raised by an algorithm on training.\n    RuntimeError: possibly raised by an algorithm on training.\n    TypeError: when the specified train set does not have the correct matrix format.</p>\n", "signature": "(\n    self,\n    train_set: src.fairreckitlib.model.algorithms.matrix.Matrix\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.on_train", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.on_train", "type": "function", "doc": "<p>Train the algorithm on the train set.</p>\n\n<p>Derived classes should implement the training logic\nof the algorithm. The train set can be anything depending\non the matrix that is used.</p>\n\n<p>Args:\n    train_set: the set to train the algorithm with.</p>\n", "signature": "(self, train_set: Any) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "type": "module", "doc": "<p>This module contains the base class for predictors.</p>\n\n<p>Classes:</p>\n\n<pre><code>BasePredictor: base class for predictors.\nPredictor: implements basic shared functionality.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor", "type": "class", "doc": "<p>Base class for FairRecKit predictors.</p>\n\n<p>A predictor is used for prediction experiments. It computes predictions\nfor any user and item that it was trained on.\nDerived predictors are expected to implement the abstract interface.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_predict\non_predict_batch (optional)</p>\n\n<p>Public methods:</p>\n\n<p>predict\npredict_batch</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.__init__", "type": "function", "doc": "<p>Construct the predictor.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.predict", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.predict", "type": "function", "doc": "<p>Compute a prediction for the specified user and item.</p>\n\n<p>A prediction is impossible when the user and/or item is not\npresent in the unique users and/or items it was trained on.\nMoreover, the prediction could also fail in the derived\nimplementation of the predictor.</p>\n\n<p>Args:\n    user: the user ID.\n    item: the item ID.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a predictor on testing.\n    MemoryError: possibly raised by a predictor on testing.\n    RuntimeError: when the predictor is not trained yet.</p>\n\n<p>Returns:\n    the predicted rating or NaN when impossible.</p>\n", "signature": "(self, user: int, item: int) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.on_predict", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.on_predict", "type": "function", "doc": "<p>Compute a prediction for the specified user and item.</p>\n\n<p>The user and item are assumed to be present in the train\nset that the predictor was trained on.\nDerived implementations are allowed to return NaN when the\nprediction is impossible to compute.</p>\n\n<p>Args:\n    user: the user ID.\n    item: the item ID.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a predictor on testing.\n    MemoryError: possibly raised by a predictor on testing.\n    RuntimeError: when the predictor is not trained yet.</p>\n\n<p>Returns:\n    the predicted rating or NaN when impossible.</p>\n", "signature": "(self, user: int, item: int) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.predict_batch", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.predict_batch", "type": "function", "doc": "<p>Compute the predictions for each of the specified user and item pairs.</p>\n\n<p>All the users and items in the pairs that are not present in the train set that\nthe predictor was trained on are set to NaN after predictions are made.</p>\n\n<p>Args:\n    user_item_pairs: with at least two columns: 'user' and 'item'.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a predictor on testing.\n    MemoryError: possibly raised by a predictor on testing.\n    RuntimeError: when the predictor is not trained yet.</p>\n\n<p>Returns:\n    a dataFrame with the columns: 'user', 'item', 'prediction'.</p>\n", "signature": "(\n    self,\n    user_item_pairs: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.on_predict_batch", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.on_predict_batch", "type": "function", "doc": "<p>Compute the predictions for each of the specified user and item pairs.</p>\n\n<p>A standard batch implementation is provided, but derived classes are\nallowed to override batching with their own logic.</p>\n\n<p>Args:\n    user_item_pairs: with two columns: 'user' and 'item'.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a predictor on testing.\n    MemoryError: possibly raised by a predictor on testing.\n    RuntimeError: when the predictor is not trained yet.</p>\n\n<p>Returns:\n    a dataFrame with the columns: 'user', 'item', 'prediction'.</p>\n", "signature": "(\n    self,\n    user_item_pairs: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor", "type": "class", "doc": "<p>Predictor that implements basic shared functionality.</p>\n", "bases": "BasePredictor"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor.__init__", "type": "function", "doc": "<p>Construct the predictor.</p>\n\n<p>Args:\n    name: the name of the predictor.\n    params: the parameters of the predictor.\n    num_threads: the max number of threads the predictor can use.</p>\n", "signature": "(self, name: str, params: Dict[str, Any], num_threads: int)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor.get_name", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor.get_name", "type": "function", "doc": "<p>Get the name of the predictor.</p>\n\n<p>Returns:\n    the predictor name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor.get_num_threads", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor.get_num_threads", "type": "function", "doc": "<p>Get the max number of threads the predictor can use.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor.get_params", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor.get_params", "type": "function", "doc": "<p>Get the parameters of the predictor.</p>\n\n<p>Returns:\n    the predictor parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "type": "module", "doc": "<p>This module contains the base class for recommenders.</p>\n\n<p>Classes:</p>\n\n<pre><code>BaseRecommender: base class for recommenders.\nRecommender: implements basic shared functionality.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender", "type": "class", "doc": "<p>Base class for FairRecKit recommenders.</p>\n\n<p>A recommender is used for recommender experiments. It computes a number of\nitem recommendations for any user that it was trained on.\nDerived recommenders are expected to implement the abstract interface.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_recommend\non_recommend_batch (optional)</p>\n\n<p>Public methods:</p>\n\n<p>has_rated_items_filter\nrecommend\nrecommend_batch</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.__init__", "type": "function", "doc": "<p>Construct the recommender.</p>\n\n<p>Args:\n    rated_items_filter: whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(self, rated_items_filter: bool)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.has_rated_items_filter", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.has_rated_items_filter", "type": "function", "doc": "<p>Get if the recommender filters already rated items when producing recommendations.</p>\n\n<p>Returns:\n    whether the recommender filters already rated items.</p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.recommend", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.recommend", "type": "function", "doc": "<p>Compute item recommendations for the specified user.</p>\n\n<p>A recommendation is impossible when the user is not present in\nthe unique users it was trained on and will return an empty dataframe.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender on testing.\n    MemoryError: possibly raised by a recommender on testing.\n    RuntimeError: when the recommender is not trained yet.</p>\n\n<p>Returns:\n    a dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int = 10) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.on_recommend", "type": "function", "doc": "<p>Compute item recommendations for the specified user.</p>\n\n<p>The user is assumed to be present in the train set that the\nrecommender was trained on.\nDerived implementations are expected to return a dataframe\nwith the 'score' column in descending order.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender on testing.\n    MemoryError: possibly raised by a recommender on testing.\n    RuntimeError: when the recommender is not trained yet.</p>\n\n<p>Returns:\n    a dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.recommend_batch", "type": "function", "doc": "<p>Compute the items recommendations for each of the specified users.</p>\n\n<p>All the users that are not present in the train set that the recommender\nwas trained on are filtered before recommendations are made.</p>\n\n<p>Args:\n    users: the user ID's to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender on testing.\n    MemoryError: possibly raised by a recommender on testing.\n    RuntimeError: when the recommender is not trained yet.</p>\n\n<p>Returns:\n    a dataframe with the columns: 'rank', 'user', 'item', 'score'.</p>\n", "signature": "(\n    self,\n    users: List[int],\n    num_items: int = 10\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.on_recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.on_recommend_batch", "type": "function", "doc": "<p>Compute the items recommendations for each of the specified users.</p>\n\n<p>All the users are assumed to be present in the train set that\nthe recommender was trained on.\nA standard batch implementation is provided, but derived classes are\nallowed to override batching with their own logic.</p>\n\n<p>Args:\n    users: the user ID's to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender on testing.\n    MemoryError: possibly raised by a recommender on testing.\n    RuntimeError: when the recommender is not trained yet.</p>\n\n<p>Returns:\n    a dataframe with the columns: 'rank', 'user', 'item', 'score'.</p>\n", "signature": "(self, users: List[int], num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender", "type": "class", "doc": "<p>Recommender that implements basic shared functionality.</p>\n", "bases": "BaseRecommender"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender.__init__", "type": "function", "doc": "<p>Construct the recommender.</p>\n\n<p>Args:\n    name: the name of the recommender.\n    params: the parameters of the recommender.\n    num_threads: the max number of threads the recommender can use.\n    rated_items_filter: whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(\n    self,\n    name: str,\n    params: Dict[str, Any],\n    num_threads: int,\n    rated_items_filter: bool\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender.get_name", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender.get_name", "type": "function", "doc": "<p>Get the name of the recommender.</p>\n\n<p>Returns:\n    the recommender name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender.get_num_threads", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender.get_num_threads", "type": "function", "doc": "<p>Get the max number of threads the recommender can use.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender.get_params", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender.get_params", "type": "function", "doc": "<p>Get the parameters of the recommender.</p>\n\n<p>Returns:\n    the recommender parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot", "modulename": "src.fairreckitlib.model.algorithms.elliot", "type": "module", "doc": "<p>This package contains functionality for recommenders of the Elliot framework.</p>\n\n<p>Modules:</p>\n\n<pre><code>elliot_algorithms: name constants for implemented algorithms.\nelliot_factory: create recommender factory.\nelliot_params: create config parameters for implemented algorithms.\nelliot_recommender: class for recommender implementation and creation functions.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_algorithms", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_algorithms", "type": "module", "doc": "<p>This module contains name constants for implemented elliot algorithms.</p>\n\n<p>Constants:</p>\n\n<pre><code>FUNK_SVD: name of the FunkSVD recommender.\nITEM_KNN: name of the ItemKNN recommender.\nMULTI_VAE: name of the MultiVAE recommender.\nMOST_POP: name of the MostPop recommender.\nRANDOM: name of the Random recommender.\nPURE_SVD: name of the PureSVD recommender.\nSVD_PP: name of the SVDpp recommender.\nUSER_KNN: name of the UserKNN recommender.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_factory", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_factory", "type": "module", "doc": "<p>This module contains functionality to create the elliot recommender factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_recommender_factory: create factory with elliot recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_factory.create_recommender_factory", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_factory", "qualname": "create_recommender_factory", "type": "function", "doc": "<p>Create the factory with Elliot recommenders.</p>\n\n<p>Returns:\n    the factory with all available recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for elliot recommenders.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_params_funk_svd: create FunkSVD config parameters.\ncreate_params_knn: create ItemKNN/UserKNN config parameters.\ncreate_params_multi_vae: create MultiVAE config parameters.\ncreate_params_pure_svd: create PureSVD config parameters.\ncreate_params_svd_pp: create SVDpp config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_funk_svd", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_funk_svd", "type": "function", "doc": "<p>Create the parameters of the FunkSVD algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_knn", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_knn", "type": "function", "doc": "<p>Create the parameters of the ItemKNN/UserKNN algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_multi_vae", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_multi_vae", "type": "function", "doc": "<p>Create the parameters of the MultiVAE algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_pure_svd", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_pure_svd", "type": "function", "doc": "<p>Create the parameters of the PureSVD algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_svd_pp", "type": "function", "doc": "<p>Create the parameters of the SVDpp algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "type": "module", "doc": "<p>This module contains the elliot recommender and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>ElliotRecommender: recommender implementation for elliot.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_funk_svd: create FunkSVD recommender (factory creation compatible).\ncreate_item_knn: create ItemKNN recommender (factory creation compatible).\ncreate_most_pop: create MostPop recommender (factory creation compatible).\ncreate_multi_vae: create MultiVAE recommender (factory creation compatible).\ncreate_pure_svd: create PureSVD recommender (factory creation compatible).\ncreate_random: create Random recommender (factory creation compatible).\ncreate_user_knn: create UserKNN recommender (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender", "type": "class", "doc": "<p>Recommender implementation for the Elliot framework.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_recommender.Recommender"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender.__init__", "type": "function", "doc": "<p>Construct the elliot recommender.</p>\n\n<p>The recommender is not procedural, instead it serves as a wrapper\nthat holds the correct parameters used by the framework which are\nused in the model pipeline.</p>\n\n<p>Args:\n    name: the name of the recommender.\n    params: the parameters of the recommender.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the recommender can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(self, name: str, params: Dict[str, Any], **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender.on_train", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender.on_train", "type": "function", "doc": "<p>Train the elliot model not supported.</p>\n", "signature": "(self, train_set: Any) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender.on_recommend", "type": "function", "doc": "<p>Recommend with the elliot model not supported.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender.on_recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender.on_recommend_batch", "type": "function", "doc": "<p>Recommend batching with the elliot model not supported.</p>\n", "signature": "(self, users: List[int], num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_funk_svd", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_funk_svd", "type": "function", "doc": "<p>Create the FunkSVD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): number of iterations.\n        factors(int): number of factors of feature embeddings.\n        learning_rate(float): the learning rate.\n        regularization_factors(float): regularization coefficient for latent factors.\n        regularization_bias(flot): regularization coefficient for bias.\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of FunkSVD.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_item_knn", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_item_knn", "type": "function", "doc": "<p>Create the ItemKNN recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        neighbors(int): number of item neighbors.\n        similarity(str): similarity function to use.\n        implementation(str): implementation type (\u2018aiolli\u2019 or \u2018classical\u2019).</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of ItemKNN.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_most_pop", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_most_pop", "type": "function", "doc": "<p>Create the MostPop recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of MostPop.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_multi_vae", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_multi_vae", "type": "function", "doc": "<p>Create the MultiVAE recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        iterations(int): number of iterations.\n        factors(int): number of latent factors.\n        learning_rate(float): the learning rate.\n        intermediate_dimensions(int): number of intermediate dimension.\n        regularization_factors(float): regularization coefficient.\n        dropout_probability(float): the dropout probability.\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of MultiVAE.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_pure_svd", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_pure_svd", "type": "function", "doc": "<p>Create the PureSVD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): number of latent factors.\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of PureSVD.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_random", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_random", "type": "function", "doc": "<p>Create the Random recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of Random.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_svd_pp", "type": "function", "doc": "<p>Create the SVDpp recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        iterations(int): number of iterations.\n        factors(int): number of latent factors.\n        learning_rate(float): the learning rate.\n        regularization_factors(float): regularization coefficient for latent factors.\n        regularization_bias(float): regularization coefficient for bias.\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of SVDpp.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_user_knn", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_user_knn", "type": "function", "doc": "<p>Create the UserKNN recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        neighbors(int): number of user neighbors.\n        similarity(str): similarity function to use.\n        implementation(str): implementation type (\u2018aiolli\u2019 or \u2018classical\u2019).</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of UserKNN.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit", "modulename": "src.fairreckitlib.model.algorithms.implicit", "type": "module", "doc": "<p>This package contains functionality for recommenders of the Implicit package.</p>\n\n<p>Modules:</p>\n\n<pre><code>implicit_algorithms: name constants for implemented algorithms.\nimplicit_factory: create recommender factory.\nimplicit_params: create config parameters for implemented algorithms.\nimplicit_recommender: class for recommender implementation and creation functions.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_algorithms", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_algorithms", "type": "module", "doc": "<p>This module contains name constants for implemented implicit algorithms.</p>\n\n<p>Constants:</p>\n\n<pre><code>ALTERNATING_LEAST_SQUARES: name of the AlternatingLeastSquares recommender.\nBAYESIAN_PERSONALIZED_RANKING: name of the BayesianPersonalizedRanking recommender.\nLOGISTIC_MATRIX_FACTORIZATION: name of the LogisticMatrixFactorization recommender.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_factory", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_factory", "type": "module", "doc": "<p>This module contains functionality to create the implicit recommender factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_recommender_factory: create factory with implicit recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_factory.create_recommender_factory", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_factory", "qualname": "create_recommender_factory", "type": "function", "doc": "<p>Create the factory with Implicit recommenders.</p>\n\n<p>Returns:\n    the factory with all available recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for implicit recommenders.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_params_als: create AlternatingLeastSquares config parameters.\ncreate_params_bpr: create BayesianPersonalizedRanking config parameters.\ncreate_params_lmf: create LogisticMatrixFactorization config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_params.create_params_als", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "qualname": "create_params_als", "type": "function", "doc": "<p>Create the parameters of the AlternatingLeastSquares algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_params.create_params_bpr", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "qualname": "create_params_bpr", "type": "function", "doc": "<p>Create the parameters of the BayesianPersonalizedRanking algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_params.create_params_lmf", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "qualname": "create_params_lmf", "type": "function", "doc": "<p>Create the parameters of the LogisticMatrixFactorization algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "type": "module", "doc": "<p>This module contains the implicit recommender and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>ImplicitRecommender: recommender implementation for implicit.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_als: create AlternatingLeastSquares recommender (factory creation compatible).\ncreate_bpr: create BayesianPersonalizedRanking recommender (factory creation compatible).\ncreate_lmf: create LogisticMatrixFactorization recommender (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender", "type": "class", "doc": "<p>Recommender implementation for the Implicit package.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_recommender.Recommender"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender.__init__", "type": "function", "doc": "<p>Construct the implicit recommender.</p>\n\n<p>Args:\n    algo: the implicit recommender algorithm.\n    name: the name of the recommender.\n    params: the parameters of the recommender.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the recommender can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(\n    self,\n    algo: implicit.recommender_base.RecommenderBase,\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender.on_train", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender.on_train", "type": "function", "doc": "<p>Train the algorithm on the train set.</p>\n\n<p>The recommender should be trained with a csr matrix.</p>\n\n<p>Args:\n    train_set: the set to train the recommender with.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by an algorithm on training.\n    MemoryError: possibly raised by an algorithm on training.\n    RuntimeError: possibly raised by an algorithm on training.\n    TypeError: when the train set is not a csr matrix.</p>\n", "signature": "(self, train_set: scipy.sparse._csr.csr_matrix) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender.on_recommend", "type": "function", "doc": "<p>Compute item recommendations for the specified user.</p>\n\n<p>Implicit recommenders use the stored CSR train set to produce item recommendations.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender on testing.\n    MemoryError: possibly raised by a recommender on testing.\n    RuntimeError: when the recommender is not trained yet.</p>\n\n<p>Returns:\n    dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender.on_recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender.on_recommend_batch", "type": "function", "doc": "<p>Compute the items recommendations for each of the specified users.</p>\n\n<p>Implicit recommenders use the stored CSR train set to produce item recommendations.\nMoreover, they allow for batching multiple users at the same time using multiple threads.</p>\n\n<p>Args:\n    users: the user ID's to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender on testing.\n    MemoryError: possibly raised by a recommender on testing.\n    RuntimeError: when the recommender is not trained yet.</p>\n\n<p>Returns:\n    dataframe with the columns: 'rank', 'user', 'item', 'score'.</p>\n", "signature": "(self, users: List[int], num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.create_als", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "create_als", "type": "function", "doc": "<p>Create the AlternatingLeastSquares recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of latent factors to compute.\n        regularization(float): the regularization factor to use.\n        use_native(bool): use native extensions to speed up model fitting.\n        use_cg(bool): use a faster Conjugate Gradient solver to calculate factors.\n        iterations(int): the number of ALS iterations to use when fitting data.\n        calculate_training_loss(bool): whether to log out the training loss at each iteration.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the ImplicitRecommender wrapper of AlternatingLeastSquares.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.create_bpr", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "create_bpr", "type": "function", "doc": "<p>Create the BayesianPersonalizedRanking recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of latent factors to compute.\n        learning_rate(float): the learning rate to apply for SGD updates during training.\n        regularization(float): the regularization factor to use.\n        iterations(int): the number of training epochs to use when fitting the data.\n        verify_negative_samples(bool): when sampling negative items, check if the randomly\n            picked negative item has actually been liked by the user. This check increases\n            the time needed to train but usually leads to better predictions.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the ImplicitRecommender wrapper of BayesianPersonalizedRanking.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.create_lmf", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "create_lmf", "type": "function", "doc": "<p>Create the LogisticMatrixFactorization recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of latent factors to compute.\n        learning_rate(float): the learning rate to apply for updates during training.\n        regularization(float): the regularization factor to use.\n        iterations(int): the number of training epochs to use when fitting the data.\n        neg_prop(int): the proportion of negative samples.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the ImplicitRecommender wrapper of LogisticMatrixFactorization.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit", "modulename": "src.fairreckitlib.model.algorithms.lenskit", "type": "module", "doc": "<p>This package contains functionality for predictors/recommenders of the LensKit package.</p>\n\n<p>Modules:</p>\n\n<pre><code>lenskit_algorithms: name constants and creation wrappers for implemented algorithms.\nlenskit_factory: create predictor/recommender factory.\nlenskit_params: create config parameters for implemented algorithms.\nlenskit_predictor: class for predictor implementation and creation functions.\nlenskit_recommender: class for recommender implementation and creation functions.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "type": "module", "doc": "<p>This module contains name constants and creation wrappers for implemented lenskit algorithms.</p>\n\n<p>Constants:</p>\n\n<pre><code>BIASED_MF: name of the BiasedMF algorithm.\nIMPLICIT_MF: name of the ImplicitMF algorithm.\nITEM_ITEM: name of the ItemItem algorithm.\nPOP_SCORE: name of the PopScore algorithm.\nRANDOM: name of the Random recommender.\nUSER_USER: name of the UserUser algorithm.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_biased_mf: create lenskit BiasedMF algorithm.\ncreate_implicit_mf: create lenskit ImplicitMF algorithm.\ncreate_item_item: create lenskit ItemItem algorithm.\ncreate_pop_score: create lenskit PopScore algorithm.\ncreate_random: create lenskit Random algorithm.\ncreate_user_user: create lenskit UserUser algorithm.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_biased_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_biased_mf", "type": "function", "doc": "<p>Create the lenskit BiasedMF algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        user_reg(float): the regularization factor for users.\n        item_reg(float): the regularization factor for items.\n        damping(float): damping factor for the underlying bias.\n        method(str): the solver to use ('cd' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the lenskit BiasedMF algorithm.</p>\n", "signature": "(params: Dict[str, Any]) -> lenskit.algorithms.als.BiasedMF", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_implicit_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_implicit_mf", "type": "function", "doc": "<p>Create the lenskit ImplicitMF algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        reg(float): the regularization factor.\n        weight(flot): the scaling weight for positive samples.\n        use_ratings(bool): whether to use the rating column or treat\n            every rated user-item pair as having a rating of 1.\n        method(str): the training method ('cg' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the lenskit ImplicitMF algorithm.</p>\n", "signature": "(params: Dict[str, Any]) -> lenskit.algorithms.als.ImplicitMF", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_item_item", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_item_item", "type": "function", "doc": "<p>Create the lenskit ItemItem algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.\n    feedback: control how feedback should be interpreted ('explicit' or 'implicit').</p>\n\n<p>Returns:\n    the lenskit ItemItem algorithm.</p>\n", "signature": "(\n    params: Dict[str, Any],\n    feedback: str\n) -> lenskit.algorithms.item_knn.ItemItem", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_pop_score", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_pop_score", "type": "function", "doc": "<p>Create the lenskit PopScore algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        score_method(str): for computing popularity scores ('quantile', 'rank' or 'count').</p>\n\n<p>Returns:\n    the lenskit PopScore algorithm.</p>\n", "signature": "(params: Dict[str, Any]) -> lenskit.algorithms.basic.PopScore", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_random", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_random", "type": "function", "doc": "<p>Create the lenskit Random algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        random_seed(int): the random seed or None for the current time as seed.\n    selector: that selects candidate items for recommendations.</p>\n\n<p>Returns:\n    the lenskit Random algorithm.</p>\n", "signature": "(\n    params: Dict[str, Any],\n    selector: lenskit.algorithms.CandidateSelector\n) -> lenskit.algorithms.basic.Random", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_user_user", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_user_user", "type": "function", "doc": "<p>Create the lenskit UserUser algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.\n    feedback: control how feedback should be interpreted ('explicit' or 'implicit').</p>\n\n<p>Returns:\n    the lenskit UserUser algorithm.</p>\n", "signature": "(\n    params: Dict[str, Any],\n    feedback: str\n) -> lenskit.algorithms.user_knn.UserUser", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory", "type": "module", "doc": "<p>This module contains functionality to create the lenskit predictor/recommender factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_predictor_factory: create factory with lenskit predictors.\ncreate_recommender_factory: create factory with lenskit recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory.create_predictor_factory", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory", "qualname": "create_predictor_factory", "type": "function", "doc": "<p>Create the factory with LensKit predictors.</p>\n\n<p>Returns:\n    the factory with all available predictors.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory.create_recommender_factory", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory", "qualname": "create_recommender_factory", "type": "function", "doc": "<p>Create the factory with LensKit recommenders.</p>\n\n<p>Returns:\n    the factory with all available recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for lenskit predictors/recommenders.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_params_biased_mf: create BiasedMF config parameters.\ncreate_params_implicit_mf: create ImplicitMF config parameters.\ncreate_params_knn: create ItemItem/UserUser config parameters.\ncreate_params_pop_score: create PopScore config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params.create_params_biased_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "qualname": "create_params_biased_mf", "type": "function", "doc": "<p>Create the parameters of the BiasedMF algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params.create_params_implicit_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "qualname": "create_params_implicit_mf", "type": "function", "doc": "<p>Create the parameters of the ImplicitMF algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params.create_params_knn", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "qualname": "create_params_knn", "type": "function", "doc": "<p>Create the parameters of the k-NN algorithms.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params.create_params_pop_score", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "qualname": "create_params_pop_score", "type": "function", "doc": "<p>Create the parameters of the PopScore algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "type": "module", "doc": "<p>This module contains the lenskit predictor and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>LensKitPredictor: predictor implementation for lenskit.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_biased_mf: create BiasedMF predictor (factory creation compatible).\ncreate_implicit_mf: create ImplicitMF predictor (factory creation compatible).\ncreate_item_item: create ItemItem predictor (factory creation compatible).\ncreate_pop_score: create PopScore predictor (factory creation compatible).\ncreate_user_user: create UserUser predictor (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor", "type": "class", "doc": "<p>Predictor implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_predictor.Predictor"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor.__init__", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor.__init__", "type": "function", "doc": "<p>Construct the lenskit predictor.</p>\n\n<p>Args:\n    algo: the lenskit prediction algorithm.\n    name: the name of the predictor.\n    params: the parameters of the predictor.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the predictor can use.</p>\n", "signature": "(\n    self,\n    algo: lenskit.algorithms.Predictor,\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor.on_train", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor.on_train", "type": "function", "doc": "<p>Fit the lenskit algorithm on the train set.</p>\n\n<p>The predictor should be trained with a dataframe matrix.</p>\n\n<p>Args:\n    train_set: the set to train the predictor with.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by an algorithm on training.\n    MemoryError: possibly raised by an algorithm on training.\n    RuntimeError: possibly raised by an algorithm on training.\n    TypeError: when the train set is not a pandas dataframe.</p>\n", "signature": "(self, train_set: pandas.core.frame.DataFrame) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor.on_predict", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor.on_predict", "type": "function", "doc": "<p>Compute a prediction for the specified user and item.</p>\n\n<p>Lenskit predictors allow for predicting multiple items at the same time.\nTo conform with the interface only one item needs to be predicted and all\nthe extra data that it generates needs to be excluded.</p>\n\n<p>Args:\n    user: the user ID.\n    item: the item ID.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a predictor on testing.\n    MemoryError: possibly raised by a predictor on testing.\n    RuntimeError: when the predictor is not trained yet.</p>\n\n<p>Returns:\n    the predicted rating.</p>\n", "signature": "(self, user: int, item: int) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor.on_predict_batch", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor.on_predict_batch", "type": "function", "doc": "<p>Compute the predictions for each of the specified user and item pairs.</p>\n\n<p>Lenskit predictors have a batch implementation available that allows for\npredicting ratings using multiple 'jobs'.</p>\n\n<p>Args:\n    user_item_pairs: with at least two columns: 'user', 'item'.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a predictor on testing.\n    MemoryError: possibly raised by a predictor on testing.\n    RuntimeError: when the predictor is not trained yet.</p>\n\n<p>Returns:\n    dataFrame with the columns: 'user', 'item', 'prediction'.</p>\n", "signature": "(\n    self,\n    user_item_pairs: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_biased_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_biased_mf", "type": "function", "doc": "<p>Create the BiasedMF predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        user_reg(float): the regularization factor for users.\n        item_reg(float): the regularization factor for items.\n        damping(float): damping factor for the underlying bias.\n        method(str): the solver to use ('cd' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of BiasedMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_implicit_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_implicit_mf", "type": "function", "doc": "<p>Create the ImplicitMF predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        reg(float): the regularization factor.\n        weight(flot): the scaling weight for positive samples.\n        use_ratings(bool): whether to use the rating column or treat\n            every rated user-item pair as having a rating of 1.\n        method(str): the training method ('cg' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of ImplicitMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_item_item", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_item_item", "type": "function", "doc": "<p>Create the ItemItem predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rating_type(str): the rating type on how feedback should be interpreted.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of ItemItem.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_pop_score", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_pop_score", "type": "function", "doc": "<p>Create the PopScore predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        score_method(str): for computing popularity scores ('quantile', 'rank' or 'count').</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of PopScore.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_user_user", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_user_user", "type": "function", "doc": "<p>Create the UserUser predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rating_type(str): the rating type on how feedback should be interpreted.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of UserUser.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "type": "module", "doc": "<p>This module contains the lenskit recommender and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>LensKitRecommender: recommender implementation for lenskit.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_candidate_selector: create CandidateSelector for a rated items filter.\ncreate_biased_mf: create BiasedMF recommender (factory creation compatible).\ncreate_implicit_mf: create ImplicitMF recommender (factory creation compatible).\ncreate_item_item: create ItemItem recommender (factory creation compatible).\ncreate_pop_score: create PopScore recommender (factory creation compatible).\ncreate_random: create Random recommender (factory creation compatible).\ncreate_user_user: create UserUser recommender (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender", "type": "class", "doc": "<p>Recommender implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_recommender.Recommender"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender.__init__", "type": "function", "doc": "<p>Construct the lenskit recommender.</p>\n\n<p>Args:\n    algo: the lenskit recommender algorithm.\n    name: the name of the recommender.\n    params: the parameters of the recommender.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the recommender can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(\n    self,\n    algo: lenskit.algorithms.Recommender,\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender.on_train", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender.on_train", "type": "function", "doc": "<p>Fit the lenskit algorithm on the train set.</p>\n\n<p>The recommender should be trained with a dataframe matrix.</p>\n\n<p>Args:\n    train_set: the set to train the recommender with.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by an algorithm on training.\n    MemoryError: possibly raised by an algorithm on training.\n    RuntimeError: possibly raised by an algorithm on training.\n    TypeError: when the train set is not a pandas dataframe.</p>\n", "signature": "(self, train_set: pandas.core.frame.DataFrame) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender.on_recommend", "type": "function", "doc": "<p>Compute item recommendations for the specified user.</p>\n\n<p>Lenskit recommenders have an implementation that is exactly the\nsame as the required interface.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender on testing.\n    MemoryError: possibly raised by a recommender on testing.\n    RuntimeError: when the recommender is not trained yet.</p>\n\n<p>Returns:\n    dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender.on_recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender.on_recommend_batch", "type": "function", "doc": "<p>Compute the items recommendations for each of the specified users.</p>\n\n<p>Lenskit recommenders have a batch implementation available that allows for\nrecommending items using multiple 'jobs'.</p>\n\n<p>Args:\n    users: the user ID's to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender on testing.\n    MemoryError: possibly raised by a recommender on testing.\n    RuntimeError: when the recommender is not trained yet.</p>\n\n<p>Returns:\n    dataframe with the columns: 'rank', 'user', 'item', 'score'.</p>\n", "signature": "(self, users: List[int], num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_candidate_selector", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_candidate_selector", "type": "function", "doc": "<p>Create a candidate selector for the specified filter.</p>\n\n<p>Args:\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the corresponding lenskit candidate selector.</p>\n", "signature": "(rated_items_filter: bool) -> lenskit.algorithms.CandidateSelector", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_biased_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_biased_mf", "type": "function", "doc": "<p>Create the BiasedMF recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        user_reg(float): the regularization factor for users.\n        item_reg(float): the regularization factor for items.\n        damping(float): damping factor for the underlying bias.\n        method(str): the solver to use ('cd' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of BiasedMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_implicit_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_implicit_mf", "type": "function", "doc": "<p>Create the ImplicitMF recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        reg(float): the regularization factor.\n        weight(flot): the scaling weight for positive samples.\n        use_ratings(bool): whether to use the rating column or treat\n            every rated user-item pair as having a rating of 1.\n        method(str): the training method ('cg' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of ImplicitMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_item_item", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_item_item", "type": "function", "doc": "<p>Create the ItemItem recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.\n    rating_type(str): the rating type on how feedback should be interpreted.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of ItemItem.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_pop_score", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_pop_score", "type": "function", "doc": "<p>Create the PopScore recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        score_method(str): for computing popularity scores ('quantile', 'rank' or 'count').</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of PopScore.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_random", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_random", "type": "function", "doc": "<p>Create the Random recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of Random.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_user_user", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_user_user", "type": "function", "doc": "<p>Create the UserUser recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.\n    rating_type(str): the rating type on how feedback should be interpreted.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of UserUser.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix", "modulename": "src.fairreckitlib.model.algorithms.matrix", "type": "module", "doc": "<p>This module contains the matrix classes that can be used for algorithm training.</p>\n\n<p>Classes:</p>\n\n<pre><code>MatrixDataFrame: (base) matrix implementation for a pandas dataframe matrix.\nMatrixCSR: matrix implementation that uses a sparse CSR matrix.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix", "type": "class", "doc": "<p>Base class for all train set matrices using a pandas dataframe.</p>\n\n<p>The intended use of the matrix class is to add an extra layer of\nabstraction to load a matrix into a specific format depending on\nthe algorithm implementation that is used. Effectively this will\nreduce the memory usage of algorithms by loading the matrix directly\ninto the expected format.</p>\n\n<p>Public methods:</p>\n\n<p>get_matrix\nget_items\nget_users\nget_user_rated_items\nknows_item\nknows_item_list\nknows_user\nknows_user_list</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.__init__", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.__init__", "type": "function", "doc": "<p>Construct the Matrix.</p>\n\n<p>The matrix is expected to be stored in a tab separated file without header,\nwith the 'user', 'item', 'rating' columns in this order.</p>\n\n<p>Args:\n    file_path: the file path to where the matrix is stored.</p>\n\n<p>Raises:\n    FileNotFoundError: when the matrix file is not found.</p>\n", "signature": "(self, file_path: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.get_matrix", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.get_matrix", "type": "function", "doc": "<p>Get the matrix.</p>\n\n<p>Returns:\n    the matrix dataframe.</p>\n", "signature": "(self) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.get_items", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.get_items", "type": "function", "doc": "<p>Get the (unique) items of the matrix.</p>\n\n<p>Returns:\n    a list of unique item IDs.</p>\n", "signature": "(self) -> numpy.ndarray", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.get_users", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.get_users", "type": "function", "doc": "<p>Get the (unique) users of the matrix.</p>\n\n<p>Returns:\n    a list of unique user IDs.</p>\n", "signature": "(self) -> numpy.ndarray", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.get_user_rated_items", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.get_user_rated_items", "type": "function", "doc": "<p>Get the rated items for the specified user.</p>\n\n<p>Args:\n    user: the user to get the rated items of.</p>\n\n<p>Raises:\n    KeyError: when the user is not part of the matrix.</p>\n\n<p>Returns:\n    a list of item IDs that are rated by the user.</p>\n", "signature": "(self, user: int) -> numpy.ndarray", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.knows_item", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.knows_item", "type": "function", "doc": "<p>Get if the specified item is known in the matrix.</p>\n\n<p>Args:\n    item: the item ID to evaluate.</p>\n\n<p>Returns:\n    whether the item ID is known.</p>\n", "signature": "(self, item: int) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.knows_item_list", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.knows_item_list", "type": "function", "doc": "<p>Get if the specified items are known in the matrix.</p>\n\n<p>Args:\n    items: the item IDs to evaluate.</p>\n\n<p>Returns:\n    a boolean series of the input showing whether each item is a known item ID.</p>\n", "signature": "(self, items: pandas.core.series.Series) -> pandas.core.series.Series", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.knows_user", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.knows_user", "type": "function", "doc": "<p>Get if the specified user is known in the matrix.</p>\n\n<p>Args:\n    user: the user ID to evaluate.</p>\n\n<p>Returns:\n    whether the user ID is known.</p>\n", "signature": "(self, user: int) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.Matrix.knows_user_list", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "Matrix.knows_user_list", "type": "function", "doc": "<p>Get if the specified users are known in the matrix.</p>\n\n<p>Args:\n    users: the user IDs to evaluate.</p>\n\n<p>Returns:\n    a boolean series of the input showing whether each user is a known user ID.</p>\n", "signature": "(self, users: pandas.core.series.Series) -> pandas.core.series.Series", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.MatrixCSR", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "MatrixCSR", "type": "class", "doc": "<p>Matrix implementation with a sparse CSR matrix.</p>\n", "bases": "Matrix"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.MatrixCSR.__init__", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "MatrixCSR.__init__", "type": "function", "doc": "<p>Construct the CSR Matrix.</p>\n\n<p>The csr matrix is expected to be stored in a tab separated file without header,\nwith the 'user', 'item', 'rating' columns in this order.\nThe matrix is loaded into a dataframe and converted to a CSR matrix.</p>\n\n<p>Args:\n    file_path: the file path to where the matrix is stored.</p>\n", "signature": "(self, file_path: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.matrix.MatrixCSR.get_matrix", "modulename": "src.fairreckitlib.model.algorithms.matrix", "qualname": "MatrixCSR.get_matrix", "type": "function", "doc": "<p>Get the matrix.</p>\n\n<p>Returns:\n    the csr matrix.</p>\n", "signature": "(self) -> scipy.sparse._csr.csr_matrix", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise", "modulename": "src.fairreckitlib.model.algorithms.surprise", "type": "module", "doc": "<p>This package contains functionality for predictors/recommenders of the Surprise package.</p>\n\n<p>Modules:</p>\n\n<pre><code>surprise_algorithms: name constants for implemented algorithms.\nsurprise_factory: create predictor/recommender factory.\nsurprise_params: create config parameters for implemented algorithms.\nsurprise_predictor: class for predictor implementation and creation functions.\nsurprise_recommender: top k predictor wrappers to be used as recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_algorithms", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_algorithms", "type": "module", "doc": "<p>This module contains name constants for implemented surprise algorithms.</p>\n\n<p>Constants:</p>\n\n<pre><code>BASELINE_ONLY_ALS: name of the BaselineOnlyALS algorithm.\nBASELINE_ONLY_SGD: name of the BaselineOnlySGD algorithm.\nCO_CLUSTERING: name of the CoClustering algorithm.\nKNN_BASIC: name of the KNNBasic algorithm.\nKNN_BASELINE_ALS: name of the KNNBaselineALS algorithm.\nKNN_BASELINE_SGD: name of the KNNBaselineSGD algorithm.\nKNN_WITH_MEANS: name of the KNNWithMeans algorithm.\nKNN_WITH_ZSCORE: name of the KNNWithZScore algorithm.\nNMF: name of the NMF algorithm.\nNORMAL_PREDICTOR: name of the NormalPredictor algorithm.\nSLOPE_ONE: name of the SlopeOne algorithm.\nSVD: name of the SVD algorithm.\nSVD_PP: name of the SVDpp algorithm.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_factory", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_factory", "type": "module", "doc": "<p>This module contains functionality to create the surprise predictor/recommender factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_predictor_factory: create factory with surprise predictors.\ncreate_recommender_factory: create factory with surprise recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_factory.create_predictor_factory", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_factory", "qualname": "create_predictor_factory", "type": "function", "doc": "<p>Create the factory with Surprise predictors.</p>\n\n<p>Returns:\n    the factory with all available predictors.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_factory.create_recommender_factory", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_factory", "qualname": "create_recommender_factory", "type": "function", "doc": "<p>Create the factory with Surprise recommenders.</p>\n\n<p>Returns:\n    the factory with all available recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_matrix", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_matrix", "type": "module", "doc": "<p>This module contains a matrix implementation for the surprise package.</p>\n\n<p>Classes:</p>\n\n<pre><code>MatrixSurprise: the surprise matrix class.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_matrix.MatrixSurprise", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_matrix", "qualname": "MatrixSurprise", "type": "class", "doc": "<p>Matrix implementation with a surprise.Trainset.</p>\n", "bases": "src.fairreckitlib.model.algorithms.matrix.Matrix"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_matrix.MatrixSurprise.__init__", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_matrix", "qualname": "MatrixSurprise.__init__", "type": "function", "doc": "<p>Construct the CSR Matrix.</p>\n\n<p>The surprise matrix is expected to be stored in a tab separated file without header,\nwith the 'user', 'item', 'rating' columns in this order.\nThe matrix is loaded into a surprise dataset and converted to a full train set.</p>\n\n<p>Args:\n    file_path: the file path to where the matrix is stored.\n    rating_scale: the minimum and maximum rating in the loaded set.</p>\n\n<p>Raises:\n    RuntimeError: when the max of the rating scale is larger than the RATING_TYPE_THRESHOLD.</p>\n", "signature": "(self, file_path: str, rating_scale: Tuple[float, float])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_matrix.MatrixSurprise.get_matrix", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_matrix", "qualname": "MatrixSurprise.get_matrix", "type": "function", "doc": "<p>Get the matrix.</p>\n\n<p>Returns:\n    the surprise.Trainset matrix.</p>\n", "signature": "(self) -> surprise.trainset.Trainset", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for surprise predictors/recommenders.</p>\n\n<p>Functions:</p>\n\n<pre><code>add_baseline_als_params_to: add baseline config parameters that use ALS.\nadd_baseline_sgd_params_to: add baseline config parameters that use SGD.\ncreate_params_baseline_only_als: create BaselineOnly config parameters with ALS.\ncreate_params_baseline_only_sgd: create BaselineOnly config parameters with SGD.\ncreate_params_co_clustering: create CoClustering config parameters.\ncreate_params_knn: create KNN base config parameters.\ncreate_params_knn_baseline: create KNNBaseline base config parameters.\ncreate_params_knn_baseline_als: create KNNBaseline config parameters with ALS.\ncreate_params_knn_baseline_sgd: create KNNBaseline config parameters with SGD.\ncreate_params_knn_similarities: create KNN config parameters with similarities.\ncreate_params_nmf: create NMF config parameters.\ncreate_params_svd: create SVD config parameters.\ncreate_params_svd_pp: create SVDpp config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.add_baseline_als_params_to", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "add_baseline_als_params_to", "type": "function", "doc": "<p>Add the parameters of the Baseline options with ALS.</p>\n\n<p>Args:\n    params: the parameters to add the baseline options to.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "(\n    params: src.fairreckitlib.core.config.config_parameters.ConfigParameters\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.add_baseline_sgd_params_to", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "add_baseline_sgd_params_to", "type": "function", "doc": "<p>Add the parameters of the Baseline options with SGD.</p>\n\n<p>Args:\n    params: the parameters to add the baseline options to.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "(\n    params: src.fairreckitlib.core.config.config_parameters.ConfigParameters\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_baseline_only_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_baseline_only_als", "type": "function", "doc": "<p>Create the parameters of the BaselineOnly ALS algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_baseline_only_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_baseline_only_sgd", "type": "function", "doc": "<p>Create the parameters of the BaselineOnly SGD algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_co_clustering", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_co_clustering", "type": "function", "doc": "<p>Create the parameters of the CoClustering algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn", "type": "function", "doc": "<p>Create the base parameters of all KNN algorithms.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn_baseline", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn_baseline", "type": "function", "doc": "<p>Create the base parameters of both KNN Baseline algorithms.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn_baseline_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn_baseline_als", "type": "function", "doc": "<p>Create the parameters of the KNN Baseline algorithm with ALS.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn_baseline_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn_baseline_sgd", "type": "function", "doc": "<p>Create the parameters of the KNN Baseline algorithm with SGD.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn_similarities", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn_similarities", "type": "function", "doc": "<p>Create the parameters of the KNN algorithm with similarities.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_nmf", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_nmf", "type": "function", "doc": "<p>Create the parameters of the NMF algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_svd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_svd", "type": "function", "doc": "<p>Create the parameters of the SVD algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_svd_pp", "type": "function", "doc": "<p>Create the parameters of the SVDpp algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "type": "module", "doc": "<p>This module contains the surprise predictor and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>SurprisePredictor: predictor implementation for surprise.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_baseline_only_als: create BaselineOnly ALS predictor (factory creation compatible).\ncreate_baseline_only_sgd: create BaselineOnly SGD predictor (factory creation compatible).\ncreate_co_clustering: create CoClustering predictor (factory creation compatible).\ncreate_knn_basic: create KNNBasic predictor (factory creation compatible).\ncreate_knn_baseline_als: create KNNBaseline ALS predictor (factory creation compatible).\ncreate_knn_baseline_sgd: create KNNBaseline SGD predictor (factory creation compatible).\ncreate_knn_with_means: create KNNWithMeans predictor (factory creation compatible).\ncreate_knn_with_zscore: create KNNWithZScore predictor (factory creation compatible).\ncreate_nmf: create NMF predictor (factory creation compatible).\ncreate_normal_predictor: create NormalPredictor predictor (factory creation compatible).\ncreate_slope_one: create SlopeOne predictor (factory creation compatible).\ncreate_svd: create SVD predictor (factory creation compatible).\ncreate_svd_pp: create SVDpp predictor (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "SurprisePredictor", "type": "class", "doc": "<p>Predictor implementation for the Surprise package.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_predictor.Predictor"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor.__init__", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "SurprisePredictor.__init__", "type": "function", "doc": "<p>Construct the surprise predictor.</p>\n\n<p>Args:\n    algo: the surprise prediction algorithm.\n    name: the name of the predictor.\n    params: the parameters of the predictor.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the predictor can use.</p>\n", "signature": "(\n    self,\n    algo: surprise.prediction_algorithms.algo_base.AlgoBase,\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor.on_train", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "SurprisePredictor.on_train", "type": "function", "doc": "<p>Train the algorithm on the train set.</p>\n\n<p>The predictor should be trained with a matrix that is\ncompatible with the surprise package.</p>\n\n<p>Args:\n    train_set: the set to train the predictor with.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by an algorithm on training.\n    MemoryError: possibly raised by an algorithm on training.\n    RuntimeError: possibly raised by an algorithm on training.\n    TypeError: when the train set is not a surprise.Trainset.</p>\n", "signature": "(self, train_set: surprise.trainset.Trainset) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor.on_predict", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "SurprisePredictor.on_predict", "type": "function", "doc": "<p>Compute a prediction for the specified user and item.</p>\n\n<p>Surprise predictors clip the predicted ratings by default to the original rating scale\nthat is provided during training. It is turned off to conform with the expected interface.</p>\n\n<p>Args:\n    user: the user ID.\n    item: the item ID.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a predictor on testing.\n    MemoryError: possibly raised by a predictor on testing.\n    RuntimeError: when the predictor is not trained yet.</p>\n\n<p>Returns:\n    the predicted rating.</p>\n", "signature": "(self, user: int, item: int) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_baseline_only_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_baseline_only_als", "type": "function", "doc": "<p>Create the BaselineOnly ALS predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): The number of iteration of the ALS procedure.\n        reg_i(int): the regularization parameter for items.\n        reg_u(int): The regularization parameter for items.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of BaselineOnly with method 'als'.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_baseline_only_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_baseline_only_sgd", "type": "function", "doc": "<p>Create the BaselineOnly SGD predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): the number of iteration of the SGD procedure.\n        regularization(float): the regularization parameter\n            of the cost function that is optimized.\n        learning_rate(float): the learning rate of SGD.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of BaselineOnly with method 'sgd'.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_co_clustering", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_co_clustering", "type": "function", "doc": "<p>Create the CoClustering predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): number of iteration of the optimization loop.\n        user_clusters(int): number of user clusters.\n        item_clusters(int): number of item clusters.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of CoClustering.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_basic", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_basic", "type": "function", "doc": "<p>Create the KNNBasic predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBasic.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_baseline_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_baseline_als", "type": "function", "doc": "<p>Create the KNNBaseline ALS predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        epochs(int): The number of iteration of the ALS procedure.\n        reg_i(int): the regularization parameter for items.\n        reg_u(int): The regularization parameter for items.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBaseline with method 'als'.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_baseline_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_baseline_sgd", "type": "function", "doc": "<p>Create the KNNBaseline SGD predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        shrinkage(int): shrinkage parameter to apply.\n        epochs(int): the number of iteration of the SGD procedure.\n        regularization(float): the regularization parameter\n            of the cost function that is optimized.\n        learning_rate(float): the learning rate of SGD.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBaseline with method 'sgd'.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_with_means", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_with_means", "type": "function", "doc": "<p>Create the KNNWithMeans predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNWithMeans.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_with_zscore", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_with_zscore", "type": "function", "doc": "<p>Create the KNNWithZScore predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNWithZScore.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_nmf", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_nmf", "type": "function", "doc": "<p>Create the NMF predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        reg_pu(float): the regularization term for users.\n        reg_qi(float): the regularization term for items.\n        init_low(int): lower bound for random initialization of factors.\n        init_high(int): higher bound for random initialization of factors.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of NMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_normal_predictor", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_normal_predictor", "type": "function", "doc": "<p>Create the NormalPredictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of NormalPredictor.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_slope_one", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_slope_one", "type": "function", "doc": "<p>Create the SlopeOne predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SlopeOne.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_svd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_svd", "type": "function", "doc": "<p>Create the SVD predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        biased(bool): whether to use baselines (or biases).\n        init_mean(int): the mean of the normal distribution for factor vectors initialization.\n        init_std_dev(float): the standard deviation of the normal distribution for\n            factor vectors initialization.\n        learning_rate(float): the learning rate for users and items.\n        regularization(float): the regularization term for users and items.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SVD.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_svd_pp", "type": "function", "doc": "<p>Create the SVDpp predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        init_mean(int): the mean of the normal distribution for factor vectors initialization.\n        init_std_dev(float): the standard deviation of the normal distribution for\n            factor vectors initialization.\n        learning_rate(float): the learning rate for users and items.\n        regularization(float): the regularization term for users and items.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SVDpp.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "type": "module", "doc": "<p>This module contains the surprise top k predictor creation functions.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_baseline_only_als: create BaselineOnly ALS recommender (factory creation compatible).\ncreate_baseline_only_sgd: create BaselineOnly SGD recommender (factory creation compatible).\ncreate_co_clustering: create CoClustering recommender (factory creation compatible).\ncreate_knn_basic: create KNNBasic recommender (factory creation compatible).\ncreate_knn_baseline_als: create KNNBaseline ALS recommender (factory creation compatible).\ncreate_knn_baseline_sgd: create KNNBaseline SGD recommender (factory creation compatible).\ncreate_knn_with_means: create KNNWithMeans recommender (factory creation compatible).\ncreate_knn_with_zscore: create KNNWithZScore recommender (factory creation compatible).\ncreate_nmf: create NMF recommender (factory creation compatible).\ncreate_normal_predictor: create NormalPredictor recommender (factory creation compatible).\ncreate_slope_one: create SlopeOne recommender (factory creation compatible).\ncreate_svd: create SVD recommender (factory creation compatible).\ncreate_svd_pp: create SVDpp recommender (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_baseline_only_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_baseline_only_als", "type": "function", "doc": "<p>Create the BaselineOnly ALS recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): The number of iteration of the ALS procedure.\n        reg_i(int): the regularization parameter for items.\n        reg_u(int): The regularization parameter for items.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of BaselineOnly with method 'als' as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_baseline_only_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_baseline_only_sgd", "type": "function", "doc": "<p>Create the BaselineOnly SGD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): the number of iteration of the SGD procedure.\n        regularization(float): the regularization parameter\n            of the cost function that is optimized.\n        learning_rate(float): the learning rate of SGD.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of BaselineOnly with method 'sgd' as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_co_clustering", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_co_clustering", "type": "function", "doc": "<p>Create the CoClustering recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): number of iteration of the optimization loop.\n        user_clusters(int): number of user clusters.\n        item_clusters(int): number of item clusters.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of CoClustering as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_basic", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_basic", "type": "function", "doc": "<p>Create the KNNBasic recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBasic as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_baseline_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_baseline_als", "type": "function", "doc": "<p>Create the KNNBaseline ALS recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        epochs(int): The number of iteration of the ALS procedure.\n        reg_i(int): the regularization parameter for items.\n        reg_u(int): The regularization parameter for items.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBaseline with method 'als' as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_baseline_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_baseline_sgd", "type": "function", "doc": "<p>Create the KNNBaseline SGD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        shrinkage(int): shrinkage parameter to apply.\n        epochs(int): the number of iteration of the SGD procedure.\n        regularization(float): the regularization parameter\n            of the cost function that is optimized.\n        learning_rate(float): the learning rate of SGD.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBaseline with method 'sgd' as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_with_means", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_with_means", "type": "function", "doc": "<p>Create the KNNWithMeans recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNWithMeans as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_with_zscore", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_with_zscore", "type": "function", "doc": "<p>Create the KNNWithZScore recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNWithZScore as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_nmf", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_nmf", "type": "function", "doc": "<p>Create the NMF recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        reg_pu(float): the regularization term for users.\n        reg_qi(float): the regularization term for items.\n        init_low(int): lower bound for random initialization of factors.\n        init_high(int): higher bound for random initialization of factors.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of NMF as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_normal_predictor", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_normal_predictor", "type": "function", "doc": "<p>Create the NormalPredictor recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of NormalPredictor as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_slope_one", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_slope_one", "type": "function", "doc": "<p>Create the SlopeOne recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SlopeOne as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_svd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_svd", "type": "function", "doc": "<p>Create the SVD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        biased(bool): whether to use baselines (or biases).\n        init_mean(int): the mean of the normal distribution for factor vectors initialization.\n        init_std_dev(float): the standard deviation of the normal distribution for\n            factor vectors initialization.\n        learning_rate(float): the learning rate for users and items.\n        regularization(float): the regularization term for users and items.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SVD as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_svd_pp", "type": "function", "doc": "<p>Create the SVDpp recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        init_mean(int): the mean of the normal distribution for factor vectors initialization.\n        init_std_dev(float): the standard deviation of the normal distribution for\n            factor vectors initialization.\n        learning_rate(float): the learning rate for users and items.\n        regularization(float): the regularization term for users and items.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SVDpp as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "type": "module", "doc": "<p>This module contains a recommender that utilizes a predictor to produce item recommendations.</p>\n\n<p>Classes:</p>\n\n<pre><code>TopK: wrap a predictor to be used as a recommender.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK", "type": "class", "doc": "<p>Recommender that implements top K recommendations using a predictor.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.__init__", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.__init__", "type": "function", "doc": "<p>Construct the TopK recommender.</p>\n\n<p>Args:\n    predictor: the underlying predictor to use for recommendations.\n    rated_items_filter: whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(\n    self,\n    predictor: src.fairreckitlib.model.algorithms.base_predictor.BasePredictor,\n    rated_items_filter: bool\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.get_name", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.get_name", "type": "function", "doc": "<p>Get the name of the underlying predictor.</p>\n\n<p>Returns:\n    the name of the underlying predictor.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.get_num_threads", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.get_num_threads", "type": "function", "doc": "<p>Get the max number of threads the underlying predictor can use.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.get_params", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.get_params", "type": "function", "doc": "<p>Get the parameters of the underlying predictor.</p>\n\n<p>Returns:\n    the parameters of the underlying predictor.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.on_train", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.on_train", "type": "function", "doc": "<p>Train the underlying predictor on the train set.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by the underlying predictor on training.\n    MemoryError: possibly raised by the underlying predictor on training.\n    RuntimeError: possibly raised by the underlying predictor on training.</p>\n", "signature": "(self, _) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.on_recommend", "type": "function", "doc": "<p>Compute item recommendations using the underlying predictor.</p>\n\n<p>Go through all user-item combinations for the specified user and\npredict a score. Sort in descending order and return the topK items.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by the underlying predictor on testing.\n    MemoryError: possibly raised by the underlying predictor on testing.\n    RuntimeError: when the underlying predictor is not trained yet.</p>\n\n<p>Returns:\n    dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.model_factory", "modulename": "src.fairreckitlib.model.model_factory", "type": "module", "doc": "<p>This module contains functionality to create a model factory.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_MODELS: key that is used to identify models.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_algorithm_pipeline_factory: wrap algorithm factory with pipeline creation.\ncreate_model_factory: create factory with prediction/recommendation factories.\ncreate_prediction_model_factory: create factory with predictor API factories.\ncreate_recommendation_model_factory: create factory with recommender API factories.\n</code></pre>\n\n<p>Deprecated:</p>\n\n<p>from .algorithms.elliot import elliot_factory\nfrom .pipeline.recommendation_pipeline_elliot import RecommendationPipelineElliot</p>\n\n<p>def create_recommendation_model_factory() -> GroupFactory:\n    ...\n    # elliot recommenders\n    model_factory.add_factory(create_algorithm_pipeline_factory(\n        elliot_factory.create_recommender_factory(),\n        RecommendationPipelineElliot\n    ))\n    ...</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.model_factory.create_algorithm_pipeline_factory", "modulename": "src.fairreckitlib.model.model_factory", "qualname": "create_algorithm_pipeline_factory", "type": "function", "doc": "<p>Create an algorithm pipeline factory.</p>\n\n<p>Args:\n    algo_factory: the factory with available algorithms.\n    create_pipeline: the pipeline creation function associated with the factory.</p>\n\n<p>Returns\n    the algorithm pipeline factory.</p>\n", "signature": "(\n    algo_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    create_pipeline: Callable[[src.fairreckitlib.core.config.config_factories.Factory, src.fairreckitlib.data.data_transition.DataTransition, src.fairreckitlib.core.events.event_dispatcher.EventDispatcher], src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline]\n) -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.model_factory.create_model_factory", "modulename": "src.fairreckitlib.model.model_factory", "qualname": "create_model_factory", "type": "function", "doc": "<p>Create a model factory with all predictor and recommender algorithms.</p>\n\n<p>Returns:\n    the group factory with all predictors and recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.model_factory.create_prediction_model_factory", "modulename": "src.fairreckitlib.model.model_factory", "qualname": "create_prediction_model_factory", "type": "function", "doc": "<p>Create a model factory with all predictor algorithms.</p>\n\n<p>Consists of algorithms from two APIs:\n    1) LensKit predictor algorithms.\n    2) Surprise predictor algorithms.</p>\n\n<p>Returns:\n    the group factory with all predictors.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.model_factory.create_recommendation_model_factory", "modulename": "src.fairreckitlib.model.model_factory", "qualname": "create_recommendation_model_factory", "type": "function", "doc": "<p>Create a model factory with all recommender algorithms.</p>\n\n<p>Consists of algorithms from four APIs:\n    1) LensKit recommender algorithms.\n    2) Implicit recommender algorithms.\n    3) Surprise recommender algorithms.</p>\n\n<p>Returns:\n    the group factory with all recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline", "modulename": "src.fairreckitlib.model.pipeline", "type": "module", "doc": "<p>This package contains functionality for running the model pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>model_config: model configuration class.\nmodel_config_parsing: parse model configuration(s).\nmodel_event: event ids, event args and a print switch for the model pipeline.\nmodel_pipeline: base model pipeline class.\nmodel_pipeline_surprise: model pipeline classes for the surprise package.\nmodel_run: run (multiple) model pipelines.\nprediction_pipeline: model pipeline class for predictions.\nrecommendation_pipeline: model pipeline class for recommendations.\nrecommendation_pipeline_elliot: recommender pipeline class for the elliot framework.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config", "modulename": "src.fairreckitlib.model.pipeline.model_config", "type": "module", "doc": "<p>This module contains the model configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>ModelConfig: model configuration.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>api_models_to_yml_format: format model configurations from different APIs to be yml compatible.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config.ModelConfig", "modulename": "src.fairreckitlib.model.pipeline.model_config", "qualname": "ModelConfig", "type": "class", "doc": "<p>Model Configuration.</p>\n\n<p>name: the name of the model.\nparams: the parameters of the model.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config.ModelConfig.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_config", "qualname": "ModelConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config_parsing", "modulename": "src.fairreckitlib.model.pipeline.model_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the model configuration(s).</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_models_config: parse models from the experiment configuration.\nparse_api_models_config: parse multiple API model configurations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config_parsing.parse_models_config", "modulename": "src.fairreckitlib.model.pipeline.model_config_parsing", "qualname": "parse_models_config", "type": "function", "doc": "<p>Parse the experiment KEY_MODELS section of the experiment configuration.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.\n    model_type_factory: the model type factory containing the available models.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a dictionary of parsed ModelConfig's keyed by API name or None when empty.</p>\n", "signature": "(\n    experiment_config: Dict[str, Any],\n    model_type_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config_parsing.parse_api_models_config", "modulename": "src.fairreckitlib.model.pipeline.model_config_parsing", "qualname": "parse_api_models_config", "type": "function", "doc": "<p>Parse all model configurations.</p>\n\n<p>Args:\n    models_config: the KEY_MODELS configuration.\n    model_type_factory: the model type factory containing the available models.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a dictionary of parsed ModelConfig's keyed by API name or None when empty.</p>\n", "signature": "(\n    models_config: Any,\n    model_type_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event", "modulename": "src.fairreckitlib.model.pipeline.model_event", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch for the model pipeline.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_BEGIN_LOAD_TEST_SET: id of the event that is used when a test set is being loaded.\nON_BEGIN_LOAD_TRAIN_SET: id of the event that is used when a train set is being loaded.\nON_BEGIN_MODEL_PIPELINE: id of the event that is used when the model pipeline starts.\nON_BEGIN_RECONSTRUCT_RATINGS: id of the event that is used when reconstructing ratings starts.\nON_BEGIN_TEST_MODEL: id of the event that is used when testing a model started.\nON_BEGIN_TRAIN_MODEL: id of the event that is used when training a model started.\nON_BEGIN_MODEL: id of the event that is used when a model computation started.\nON_END_LOAD_TEST_SET: id of the event that is used when a test set has been loaded.\nON_END_LOAD_TRAIN_SET: id of the event that is used when a train set has been loaded.\nON_END_MODEL_PIPELINE: id of the event that is used when the model pipeline ends.\nON_END_RECONSTRUCT_RATINGS: id of the event that is used when reconstructing ratings finishes.\nON_END_TEST_MODEL: id of the event that is used when testing a model finishes.\nON_END_TRAIN_MODEL: id of the event that is used when training a model finishes.\nON_END_MODEL: id of the event that is used when a model computation finishes.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>ModelPipelineEventArgs: event args related to the model pipeline.\nModelEventArgs: event args related to a model.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_model_events: list of model pipeline event IDs.\nget_model_event_print_switch: switch to print model pipeline event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.ModelPipelineEventArgs", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "ModelPipelineEventArgs", "type": "class", "doc": "<p>Model Pipeline Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the model pipeline event.\napi_name: the name of the api that is used in the model pipeline.\nmodels_config: list of model configurations that is used in the model pipeline.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.ModelPipelineEventArgs.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "ModelPipelineEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    api_name: str,\n    models_config: List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.ModelEventArgs", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "ModelEventArgs", "type": "class", "doc": "<p>Model Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the model event.\nmodel_name: the name of the model.\nmodel_params: the parameters of the model.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.ModelEventArgs.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "ModelEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, model_name: str, model_params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.get_model_events", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "get_model_events", "type": "function", "doc": "<p>Get a list of model pipeline event IDs.</p>\n\n<p>Returns:\n    a list of unique model pipeline event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.get_model_event_print_switch", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "get_model_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints model pipeline event IDs.</p>\n\n<p>Returns:\n    the print model pipeline event switch.</p>\n", "signature": "(\n    elapsed_time: float = None\n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "type": "module", "doc": "<p>This module contains base functionality of the complete model pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>ModelPipeline: class that batches multiple model computations for a specific API.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline", "type": "class", "doc": "<p>Model Pipeline to run computations for algorithms from a specific API.</p>\n\n<p>Wraps the common functionality that applies to all models disregarding the type.\nLoading the train and test is only done once each time the pipeline is run.\nAfter the previously mentioned sets are done loading, the pipeline loops\nthrough all specified models and executes the following steps:</p>\n\n<p>1) create the output directory.\n2) create the model.\n3) save the model's creation settings.\n4) train the model using the train set.\n5) test the model using the test set.</p>\n\n<p>After all models are trained and tested the computed rating files are updated\nwith the original ratings from the train and test set.</p>\n\n<p>Abstract methods:</p>\n\n<p>load_test_set_users\ntest_model_ratings</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n", "bases": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.__init__", "type": "function", "doc": "<p>Construct the model pipeline.</p>\n\n<p>Args:\n    algo_factory: factory of available algorithms for this API.\n    data_transition: data input.\n    event_dispatcher: used to dispatch model/IO events when running the pipeline.</p>\n", "signature": "(\n    self,\n    algo_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    data_transition: src.fairreckitlib.data.data_transition.DataTransition,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.run", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.run", "type": "function", "doc": "<p>Run the entire pipeline from beginning to end.</p>\n\n<p>Effectively running all computations of the specified models.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    models_config: list of ModelConfig objects to compute.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads an algorithm can use.\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Raises:\n    FileNotFoundError: when either the train and/or test fails to load.</p>\n\n<p>Returns:\n    a list of model directories where computation results are stored.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    models_config: List[src.fairreckitlib.model.pipeline.model_config.ModelConfig],\n    is_running: Callable[[], bool],\n    **kwargs\n) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.run_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.run_model", "type": "function", "doc": "<p>Run the model computation for the specified model configuration.</p>\n\n<p>Args:\n    model_dir: the path of the directory where the computed ratings can be stored.\n    model_config: the algorithm model configuration.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads an algorithm can use.\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a model on construction, training or testing.\n    MemoryError: possibly raised by a model on construction, training or testing.\n    RuntimeError: possibly raised by a model on construction, training or testing.</p>\n", "signature": "(\n    self,\n    model_dir: str,\n    model_config: src.fairreckitlib.model.pipeline.model_config.ModelConfig,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.begin_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.begin_model", "type": "function", "doc": "<p>Prepare the model computation.</p>\n\n<p>Resolves the output directory to create for the model computation,\nso that it is unique and creates the model.</p>\n\n<p>Args:\n    model_name: name of the model's algorithm.\n    model_params: parameters of the algorithm.\n    model_dir: the path of the directory where the computed ratings can be stored.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads an algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a model on construction.\n    MemoryError: possibly raised by a model on construction.\n    RuntimeError: possibly raised by a model on construction.</p>\n\n<p>Returns:\n    model: the created model according the specified name and parameters.\n    start: the time when the model computation started.</p>\n", "signature": "(\n    self,\n    model_name: str,\n    model_params: Dict[str, Any],\n    model_dir: str,\n    **kwargs\n) -> Tuple[src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm, float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.create_model_output_dir", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.create_model_output_dir", "type": "function", "doc": "<p>Create the output directory for a model.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    model_name: name of the model's algorithm.</p>\n\n<p>Returns:\n    the path of the directory where the model's computed ratings can be stored.</p>\n", "signature": "(self, output_dir: str, model_name: str) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.get_model_output_dir", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.get_model_output_dir", "type": "function", "doc": "<p>Get the model output directory path for the specified model name.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    model_name: name of the model's algorithm.</p>\n\n<p>Returns:\n    the path of the directory where the model's computed ratings can be stored.</p>\n", "signature": "(self, output_dir: str, model_name: str) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.end_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.end_model", "type": "function", "doc": "<p>Finalize the model computation.</p>\n\n<p>Updates the number of tested models so that additional\ncomputations remain unique for this model.</p>\n\n<p>Args:\n    model: the model that finished.\n    start: the time when the model computation started.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm,\n    start: float\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.on_load_train_set_matrix", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.on_load_train_set_matrix", "type": "function", "doc": "<p>Load the train set matrix that all models can use for training.</p>\n\n<p>The default train set matrix of the model pipeline is a dataframe.\nDerived classes are allowed to override this function to return a different type of matrix.</p>\n\n<p>Returns:\n    the loaded train set matrix dataframe.</p>\n", "signature": "(self) -> src.fairreckitlib.model.algorithms.matrix.Matrix", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.load_train_set_matrix", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.load_train_set_matrix", "type": "function", "doc": "<p>Load the train set matrix that all models can use for training.</p>\n\n<p>Raises:\n    FileNotFoundError: when the train set file is not found.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.load_train_set_dataframe", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.load_train_set_dataframe", "type": "function", "doc": "<p>Load the train set as a dataframe.</p>\n\n<p>Raises:\n    FileNotFoundError: when the train set file is not found.</p>\n\n<p>Returns:\n    the loaded train set dataframe.</p>\n", "signature": "(self) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.load_test_set_dataframe", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.load_test_set_dataframe", "type": "function", "doc": "<p>Load the test set as a dataframe.</p>\n\n<p>Args:\n    test_name: name of the test set dataframe to dispatch in the dataframe event.</p>\n\n<p>Raises:\n    FileNotFoundError: when the test set file is not found.</p>\n\n<p>Returns:\n    the loaded test set dataframe.</p>\n", "signature": "(self, test_name: str = 'data test set') -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.load_test_set_users", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.load_test_set_users", "type": "function", "doc": "<p>Load the test set users that all models can use for testing.</p>\n\n<p>Raises:\n    FileNotFoundError: when the test set file is not found.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.reconstruct_ratings", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.reconstruct_ratings", "type": "function", "doc": "<p>Reconstruct the original ratings for all the computed models ratings.</p>\n\n<p>Args:\n    result_dirs: a list of directories that contain a computed rating file.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n", "signature": "(self, result_dirs: List[str], is_running: Callable[[], bool]) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.test_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.test_model", "type": "function", "doc": "<p>Test the specified model using the test set.</p>\n\n<p>This function wraps the event dispatching and functionality\nthat both predictor and recommender models have in common.</p>\n\n<p>Args:\n    model: the model that needs to be tested.\n    model_dir: the path of the directory where the computed ratings can be stored.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a model on testing.\n    MemoryError: possibly raised by a model on testing.\n    RuntimeError: possibly raised by a model on testing.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm,\n    model_dir: str,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.test_model_ratings", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.test_model_ratings", "type": "function", "doc": "<p>Test the specified model for rating predictions or recommendations.</p>\n\n<p>Args:\n    model: the model that needs to be tested.\n    user_batch: the user batch to compute model ratings for.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a model on testing.\n    MemoryError: possibly raised by a model on testing.\n    RuntimeError: possibly raised by a model on testing.</p>\n\n<p>Returns:\n    a dataframe containing the computed model ratings.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm,\n    user_batch: List[int],\n    **kwargs\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.train_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.train_model", "type": "function", "doc": "<p>Train the specified model using the train set.</p>\n\n<p>Args:\n    model: the model that needs to be trained.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a model on training.\n    MemoryError: possibly raised by a model on training.\n    RuntimeError: possibly raised by a model on training.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.train_and_test_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.train_and_test_model", "type": "function", "doc": "<p>Train and test the specified model.</p>\n\n<p>Several possible errors can be raised during the executing of both training and\ntesting the model: namely ArithmeticError, MemoryError and RuntimeError.</p>\n\n<p>Args:\n    model: the model that needs to be trained.\n    model_dir: the path of the directory where the computed ratings can be stored.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a model on training or testing.\n    MemoryError: possibly raised by a model on training or testing.\n    RuntimeError: possibly raised by a model on training or testing.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm,\n    model_dir: str,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline_surprise", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline_surprise", "type": "module", "doc": "<p>This module contains the model pipelines for the Surprise package.</p>\n\n<p>Classes:</p>\n\n<pre><code>PredictionPipelineSurprise: prediction pipeline that uses a surprise matrix.\nRecommendationPipelineSurprise: recommendation pipeline that uses a surprise matrix.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline_surprise.PredictionPipelineSurprise", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline_surprise", "qualname": "PredictionPipelineSurprise", "type": "class", "doc": "<p>Prediction Pipeline implementation for a surprise matrix train set.</p>\n", "bases": "src.fairreckitlib.model.pipeline.prediction_pipeline.PredictionPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline_surprise.PredictionPipelineSurprise.on_load_train_set_matrix", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline_surprise", "qualname": "PredictionPipelineSurprise.on_load_train_set_matrix", "type": "function", "doc": "<p>Load the train set matrix that all models can use for training.</p>\n\n<p>Raises:\n    FileNotFoundError: when the train set file is not found.\n    RuntimeError: when the max of the rating scale is larger than the RATING_TYPE_THRESHOLD.</p>\n\n<p>Returns:\n    the loaded surprise train set matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.model.algorithms.matrix.Matrix", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline_surprise.RecommendationPipelineSurprise", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline_surprise", "qualname": "RecommendationPipelineSurprise", "type": "class", "doc": "<p>Recommendation Pipeline implementation for a surprise matrix train set.</p>\n", "bases": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline_surprise.RecommendationPipelineSurprise.on_load_train_set_matrix", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline_surprise", "qualname": "RecommendationPipelineSurprise.on_load_train_set_matrix", "type": "function", "doc": "<p>Load the train set matrix that all models can use for training.</p>\n\n<p>Raises:\n    FileNotFoundError: when the train set file is not found.\n    RuntimeError: when the max of the rating scale is larger than the RATING_TYPE_THRESHOLD.</p>\n\n<p>Returns:\n    the loaded surprise train set matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.model.algorithms.matrix.Matrix", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_run", "modulename": "src.fairreckitlib.model.pipeline.model_run", "type": "module", "doc": "<p>This module contains functionality that wraps running the model pipeline multiple times.</p>\n\n<p>Classes:</p>\n\n<pre><code>ModelPipelineConfig: configuration class to run the model pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>run_model_pipelines: run (multiple) pipelines for specified model configurations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_run.ModelPipelineConfig", "modulename": "src.fairreckitlib.model.pipeline.model_run", "qualname": "ModelPipelineConfig", "type": "class", "doc": "<p>Model Pipeline Configuration.</p>\n\n<p>output_dir: the directory to store the output.\ndata_transition: data input.\nmodel_factory: the factory with available algorithm factories.\nmodels: dictionary with api model configurations to compute.</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_run.ModelPipelineConfig.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_run", "qualname": "ModelPipelineConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_transition: src.fairreckitlib.data.data_transition.DataTransition,\n    model_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    models: Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_run.run_model_pipelines", "modulename": "src.fairreckitlib.model.pipeline.model_run", "qualname": "run_model_pipelines", "type": "function", "doc": "<p>Run several model pipelines according to the specified model pipeline configuration.</p>\n\n<p>Args:\n    pipeline_config: the configuration on how to run the model pipelines.\n    event_dispatcher: used to dispatch model/IO events when running the model pipelines.\n    is_running: function that returns whether the pipelines\n        are still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads a model can use.\n    num_items(int): the number of item recommendations to produce, only\n        needed when running recommender pipelines.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    list of directories where the computed model ratings are stored.</p>\n", "signature": "(\n    pipeline_config: src.fairreckitlib.model.pipeline.model_run.ModelPipelineConfig,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.prediction_pipeline", "modulename": "src.fairreckitlib.model.pipeline.prediction_pipeline", "type": "module", "doc": "<p>This module contains a model pipeline that predicts known item ratings.</p>\n\n<p>Classes:</p>\n\n<pre><code>PredictionPipeline: can batch predictions from multiple models for a specific API.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.prediction_pipeline.PredictionPipeline", "modulename": "src.fairreckitlib.model.pipeline.prediction_pipeline", "qualname": "PredictionPipeline", "type": "class", "doc": "<p>Prediction Pipeline that computes user/item rating predictions.</p>\n\n<p>The (user,item) prediction will be computed and for each pair that is present in the test set.</p>\n", "bases": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.prediction_pipeline.PredictionPipeline.load_test_set_users", "modulename": "src.fairreckitlib.model.pipeline.prediction_pipeline", "qualname": "PredictionPipeline.load_test_set_users", "type": "function", "doc": "<p>Load the test set users that all models can use for testing.</p>\n\n<p>Predictions are made for every user-item pair in the test set.</p>\n\n<p>Raises:\n    FileNotFoundError: when the test set file is not found.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.prediction_pipeline.PredictionPipeline.test_model_ratings", "modulename": "src.fairreckitlib.model.pipeline.prediction_pipeline", "qualname": "PredictionPipeline.test_model_ratings", "type": "function", "doc": "<p>Test the specified model for rating predictions.</p>\n\n<p>Predict ratings for each user-item pair that is present in the test set.</p>\n\n<p>Args:\n    model: the model that needs to be tested.\n    user_batch: the user batch to compute model ratings for.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a predictor model on testing.\n    MemoryError: possibly raised by a predictor model on testing.\n    RuntimeError: possibly raised by a predictor model on testing.</p>\n\n<p>Returns:\n    a dataframe containing the computed rating predictions.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_predictor.BasePredictor,\n    user_batch: List[int],\n    **kwargs\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "type": "module", "doc": "<p>This module contains a model pipeline that recommends items based on rating predictions.</p>\n\n<p>Classes:</p>\n\n<pre><code>RecommendationPipeline: can batch recommendations from multiple models for a specific API.\nRecommendationPipelineCSR: recommendation pipeline with a csr matrix instead of a dataframe.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "qualname": "RecommendationPipeline", "type": "class", "doc": "<p>Recommendation Pipeline that computes item recommendations.</p>\n\n<p>The topK item recommendations will be computed for each user that is present in the test set.</p>\n", "bases": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline.load_test_set_users", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "qualname": "RecommendationPipeline.load_test_set_users", "type": "function", "doc": "<p>Load the test set users that all models can use for testing.</p>\n\n<p>Recommendations are made for every user in the test set.</p>\n\n<p>Raises:\n    FileNotFoundError: when the test set file is not found.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline.test_model_ratings", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "qualname": "RecommendationPipeline.test_model_ratings", "type": "function", "doc": "<p>Test the specified model for rating recommendations.</p>\n\n<p>Produce a top K number of item scores for each user that is present in the test set.</p>\n\n<p>Args:\n    model: the model that needs to be tested.\n    user_batch: the user batch to compute model ratings for.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a recommender model on testing.\n    MemoryError: possibly raised by a recommender model on testing.\n    RuntimeError: possibly raised by a recommender model on testing.</p>\n\n<p>Returns:\n    a dataframe containing the computed item recommendations.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender,\n    user_batch: List[int],\n    **kwargs\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipelineCSR", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "qualname": "RecommendationPipelineCSR", "type": "class", "doc": "<p>Recommendation Pipeline implementation for a CSR matrix train set.</p>\n", "bases": "RecommendationPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipelineCSR.on_load_train_set_matrix", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "qualname": "RecommendationPipelineCSR.on_load_train_set_matrix", "type": "function", "doc": "<p>Load the train set matrix that all models can use for training.</p>\n\n<p>Raises:\n    FileNotFoundError: when the train set file is not found.</p>\n\n<p>Returns:\n    the loaded train set csr matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.model.algorithms.matrix.Matrix", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "type": "module", "doc": "<p>This module contains a model pipeline that recommends items using the Elliot framework.</p>\n\n<p>Classes:</p>\n\n<pre><code>RecommendationPipelineElliot: can batch recommendations from multiple elliot models.\n</code></pre>\n\n<p>Deprecated:</p>\n\n<p>from elliot.run import run_experiment</p>\n\n<p>class RecommendationPipelineElliot(RecommendationPipeline):\n    ...\n    def train_and_test_model(\n            self,\n            model: ElliotRecommender,\n            model_dir: str,\n            is_running: Callable[[], bool],\n            **kwargs) -> str:\n        ...\n        create_yml(yml_path, data, self.event_dispatcher)</p>\n\n<pre><code>    run_experiment(yml_path)\n\n    delete_dir(temp_dir, self.event_dispatcher)\n    ...\n...\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot", "type": "class", "doc": "<p>Recommendation Pipeline implementation for the Elliot framework.</p>\n", "bases": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.train_and_test_model", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.train_and_test_model", "type": "function", "doc": "<p>Train and test the specified model.</p>\n\n<p>Convert the model configuration into a yml file that is accepted by the framework.\nFeed it to the framework to obtain results, clear unwanted artifacts and modify the\nratings file so that it conforms to the standard convention.</p>\n\n<p>Args:\n    model: the model that needs to be trained.\n    model_dir: the path of the directory where the computed ratings can be stored.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce.</p>\n\n<p>Raises:\n    ArithmeticError: possibly raised by a model on training or testing.\n    MemoryError: possibly raised by a model on training or testing.\n    RuntimeError: possibly raised by a model on training or testing.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender,\n    model_dir: str,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.clear_unused_epochs", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.clear_unused_epochs", "type": "function", "doc": "<p>Clear unused epochs from the model output directory.</p>\n\n<p>Recommenders with an 'epochs' parameter will generate computed ratings\nfor each epoch. Only the final epoch is needed.</p>\n\n<p>Args:\n    num_epochs: the number of epochs that was run by the algorithm.\n    model_dir: the directory where the computed ratings are stored.</p>\n", "signature": "(self, num_epochs: int, model_dir: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.reconstruct_rank_column", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.reconstruct_rank_column", "type": "function", "doc": "<p>Reconstruct the rank column in the result file that the framework generated.</p>\n\n<p>Args:\n    model_dir: the directory where the computed ratings are stored.\n    top_k: the topK that was used to compute the ratings.</p>\n", "signature": "(self, model_dir: str, top_k: int) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.rename_result", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.rename_result", "type": "function", "doc": "<p>Rename the computed ratings file to be consistent with other pipelines.</p>\n\n<p>Args:\n    model_dir: the directory where the computed ratings are stored.</p>\n\n<p>Returns:\n    the file path of the result after renaming.</p>\n", "signature": "(model_dir: str) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system", "modulename": "src.fairreckitlib.recommender_system", "type": "module", "doc": "<p>This module contains the FairRecKit recommender system.</p>\n\n<p>Classes:</p>\n\n<pre><code>RecommenderSystem: class that includes the entire recommender system.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem", "type": "class", "doc": "<p>The FairReckit Recommender System.</p>\n\n<p>Defines the top level API intended for use by applications.</p>\n\n<p>Public methods:</p>\n\n<p>abort_computation\nrun_experiment\nrun_experiment_from_yml\nvalidate_experiment\nget_active_computations\nget_available_algorithms\nget_available_datasets\nget_available_data_filters\nget_available_metrics\nget_available_rating_converters\nget_available_splitters</p>\n"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.__init__", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.__init__", "type": "function", "doc": "<p>Construct the RecommenderSystem.</p>\n\n<p>Initializes the data registry with available datasets on which the\nrecommender system depends and therefore the data directory is expected to exist.\nThe result directory however is created when non-existing.</p>\n\n<p>Args:\n    data_dir: path to the directory that contains the datasets.\n    result_dir: path to the directory to store computation results.\n    verbose: whether the data registry should give verbose output on startup.</p>\n\n<p>Raises:\n    IOError: when the specified data directory does not exist.</p>\n", "signature": "(self, data_dir: str, result_dir: str, verbose: bool = True)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.abort_computation", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.abort_computation", "type": "function", "doc": "<p>Attempt to abort a running computation thread.</p>\n\n<p>The name of the computation is the same as specified in the configuration\nfile when the computation is run. If the computation with the specified\nname does not exist this function returns False.\nNote that the computation is only requested to abort as soon as possible,\ntherefore it might take a while until the computation actually stops.</p>\n\n<p>Args:\n    computation_name: name of the active computation thread to abort.</p>\n\n<p>Returns:\n    whether the computation is successfully requested to abort.</p>\n", "signature": "(self, computation_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.run_experiment", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.run_experiment", "type": "function", "doc": "<p>Run an experiment with the specified configuration.</p>\n\n<p>It is advised to validate the configuration (default) before running the\nexperiment, to make sure the configuration describes a valid experiment.\nThe configuration is invalid when it contains no selected datasets or\nmodels, only the evaluation is optional. If the configuration is invalidated\nthis function will return False.</p>\n\n<p>Args:\n    events: the external events to dispatch during the experiment.\n    config: the configuration of the experiment.\n    num_threads: the max number of threads the experiment can use.\n    verbose: whether the internal events should give verbose output.\n    validate_config: whether to validate the configuration beforehand.</p>\n\n<p>Raises:\n    KeyError: when a computation with the same name is already active.\n    IOError: when the experiment result directory already exists.\n    TypeError: when the provided configuration is not a valid experiment configuration.</p>\n\n<p>Returns:\n    whether the experiment successfully started.</p>\n", "signature": "(\n    self,\n    config: Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig],\n    *,\n    events: Dict[str, Callable[[Any], NoneType]] = None,\n    num_threads: int = 0,\n    verbose: bool = True,\n    validate_config: bool = True\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.run_experiment_from_yml", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.run_experiment_from_yml", "type": "function", "doc": "<p>Run an experiment from a yml file.</p>\n\n<p>The configuration in the file is validated before starting the experiment.\nIt is invalid when it contains no selected datasets or models,\nonly the evaluation is optional.  If the configuration is invalidated\nthis function will return False.</p>\n\n<p>Args:\n    events: the external events to dispatch during the experiment.\n    file_path: path to the yml file without extension.\n    num_threads: the max number of threads the experiment can use.\n    verbose: whether the internal events should give verbose output.</p>\n\n<p>Raises:\n    FileNotFoundError: when the specified yml file does not exist.\n    KeyError: when a computation with the same name is already active.\n    IOError: when the experiment result directory already exists.</p>\n\n<p>Returns:\n    whether the experiment successfully started.</p>\n", "signature": "(\n    self,\n    file_path: str,\n    *,\n    events: Dict[str, Callable[[Any], NoneType]] = None,\n    num_threads: int = 0,\n    verbose: bool = True\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.validate_experiment", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.validate_experiment", "type": "function", "doc": "<p>Validate an experiment for an additional number of runs.</p>\n\n<p>It is not possible to validate an active experiment computation until it is done.\nThe configuration file is expected to be stored in the specified result directory.\nMoreover, the configuration is validated before starting the experiment validation.\nIf the configuration is invalidated this function will return False.</p>\n\n<p>Args:\n    events: the external events to dispatch during the experiment.\n    result_dir: path to an existing experiment result directory.\n    num_runs: the number of runs to validate the experiment.\n    num_threads: the max number of threads the experiment can use.\n    verbose: whether the internal events should give verbose output.</p>\n\n<p>Raises:\n    FileNotFoundError: when the configuration file does not exist in the result directory.\n    KeyError: when a computation with the same name is already active.\n    IOError: when the experiment result directory does not exist.</p>\n\n<p>Returns:\n    whether the experiment successfully started.</p>\n", "signature": "(\n    self,\n    result_dir: str,\n    num_runs: int,\n    *,\n    events: Dict[str, Callable[[Any], NoneType]] = None,\n    num_threads: int = 0,\n    verbose: bool = True\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_active_computations", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_active_computations", "type": "function", "doc": "<p>Get the names of any active computations.</p>\n\n<p>Returns:\n    a list of computations names that are currently running.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_algorithms", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_algorithms", "type": "function", "doc": "<p>Get the available algorithms of the recommender system.</p>\n\n<p>Args:\n    model_type: type of model to query for availability, accepted values are\n        TYPE_PREDICTION, TYPE_RECOMMENDATION or None.</p>\n\n<p>Returns:\n    a dictionary with the availability of algorithms categorized by API.</p>\n", "signature": "(self, model_type: str = None)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_datasets", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_datasets", "type": "function", "doc": "<p>Get the available datasets of the recommender system.</p>\n\n<p>Returns:\n    a dictionary where the key corresponds to the dataset name and\n        the value corresponds to the matrix information dictionary.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_data_filters", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_data_filters", "type": "function", "doc": "<p>Get the available data filters of the recommender system.</p>\n\n<p>Returns:\n    a dictionary with the availability of data filters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_metrics", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_metrics", "type": "function", "doc": "<p>Get the available metrics of the recommender system.</p>\n\n<p>Args:\n    eval_type(str): type of evaluation to query for availability, accepted values are\n        TYPE_PREDICTION, TYPE_RECOMMENDATION or None.</p>\n\n<p>Returns:\n    a dictionary with the availability of metrics categorized by evaluation type.</p>\n", "signature": "(self, eval_type: str = None) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_rating_converters", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_rating_converters", "type": "function", "doc": "<p>Get the available data rating converters of the recommender system.</p>\n\n<p>Returns:\n    a dictionary with the availability of rating converters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_splitters", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_splitters", "type": "function", "doc": "<p>Get the available data splitters of the recommender system.</p>\n\n<p>Returns:\n    a dictionary with the availability of data splitters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();